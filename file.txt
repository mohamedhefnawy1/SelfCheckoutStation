commit a0449133a33df2949bfb299067db702588f47b72
Merge: 823e1f3 d047a1b
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Wed Mar 30 21:15:46 2022 -0600

    Merge pull request #21 from adam-25/SimonTest
    
    Finished Coverage for TouchScreenController

commit 823e1f30aa8271eec8615bb74e715443bbb6c479
Author: Muhammad Ali <muhammad.ali4@ucalgary.ca>
Date:   Wed Mar 30 21:10:57 2022 -0600

    fixed probability error by creating while loop and adding boolean variable

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
index 6906188..76709da 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java	
@@ -121,6 +121,8 @@ public class PaymentControllerTest extends BaseTestClass {
 		pController.setValueOfCart(totalCost);
 
 		Banknote banknote = new Banknote(Currency.getInstance("CAD"), 20);
+		
+		while (pController.isAcceptBanknote() == false) {
 		try {
 			//accept valid banknote
 			cs.banknoteInput.accept(banknote);
@@ -130,7 +132,7 @@ public class PaymentControllerTest extends BaseTestClass {
 			e.printStackTrace();
 		}
 		
-		
+		}
 		
 		//See if cost was paid
 		//Value of cart at the start of test is $20
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index bc38996..0537833 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -54,6 +54,7 @@ public class PaymentController extends TouchScreenController{
 	private boolean showError = false;
 	private boolean cardDataRead = false;
 	private boolean cardInsert = false;
+	private boolean acceptBanknote = false;
 	
 	public PaymentController(SelfCheckoutStation cs){
 		super(cs);
@@ -174,6 +175,14 @@ public class PaymentController extends TouchScreenController{
 	}
 	
 	
+	/**
+	 * @return the acceptBanknote
+	 */
+	public boolean isAcceptBanknote() {
+		return acceptBanknote;
+	}
+
+
 	//COIN PAYMENT - Implementation of Coin observers
 	private class PCC implements CoinSlotObserver, CoinValidatorObserver, CoinTrayObserver{
 		@Override
@@ -246,9 +255,11 @@ public class PaymentController extends TouchScreenController{
 		@Override
 		public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
 			//Subtract the value of cart from the customer bank note value
+			acceptBanknote = true;
 			BigDecimal bigDecimalVal = new BigDecimal(value);
 			valueOfCart = valueOfCart.subtract(bigDecimalVal);
 			isAllItemPaid();
+			
 		}
 
 		@Override

commit d047a1bb844c61f68757d86d02d155bbbeda3cbb
Author: Simon Vincent <47257674+SmonVincent@users.noreply.github.com>
Date:   Wed Mar 30 21:09:53 2022 -0600

    update

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
index 7ddd02b..7345527 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
@@ -38,5 +38,17 @@ public class TouchScreenControllerTest extends BaseTestClass {
 		Assert.assertFalse(checkoutStation.banknoteInput.isDisabled());
 		Assert.assertFalse(checkoutStation.coinSlot.isDisabled());
 	}
+
+	@Test
+	public void testEnabled() {
+		touchScreenController.enabled(null);
+		Assert.assertTrue(touchScreenController.enabledTrue == true);
+	}
+	
+	@Test
+	public void testDisabled() {
+		touchScreenController.disabled(null);
+		Assert.assertTrue(touchScreenController.disabledTrue == true);
+	}
 	
-}
\ No newline at end of file
+}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
index 870e3b3..0a1c434 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
@@ -6,11 +6,16 @@ import org.lsmr.selfcheckout.devices.observers.TouchScreenObserver;
 
 
 
-public class TouchScreenController  implements TouchScreenObserver{
+public class TouchScreenController implements TouchScreenObserver {
 		
 	private final SelfCheckoutStation checkoutStation;
 	public checkoutState state;
 	
+	// These 2 booleans are for Iteration 2 testing
+	public boolean enabledTrue = false;
+	public boolean disabledTrue = false;
+	// Delete for Iteration 3 ^^
+	
 	public enum checkoutState{
 		SCAN, PAY
 	}
@@ -49,13 +54,14 @@ public class TouchScreenController  implements TouchScreenObserver{
 
 	@Override
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
-		
+		// For testing purposes
+		enabledTrue = true;
 	}
 
 	@Override
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
+		// For testing purposes
+		disabledTrue = true;
 		
 	}
 }
\ No newline at end of file
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class
index 4b2e702..67f35da 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class
index 6b9af3c..08a8a3a 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class
index 126ad10..5249c16 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class
index d11f70d..7b6fee4 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class
index c51a3bc..cf5b0c0 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class
index 53f9ebc..3e660e3 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class and b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class
index fbab21f..c90c728 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class and b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class
index 5f59dd4..58655df 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class
index 347a26d..489ab9d 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class
index 26d5da0..bbbb70a 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class
index 6f27277..1224d90 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class
index e2a1f73..dddf351 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class and b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class
index 476a4ee..0fc25f2 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class and b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/TouchScreenController.class b/bin/src/org/lsmr/selfcheckout/customer/TouchScreenController.class
index 8c75c7b..a85647a 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/TouchScreenController.class and b/bin/src/org/lsmr/selfcheckout/customer/TouchScreenController.class differ

commit a8f6b408f725d1a67a88b1751a9a61b99db9d345
Merge: 5d43b49 6e4bafb
Author: Matthew Newton <60675042+Mattynewts@users.noreply.github.com>
Date:   Wed Mar 30 20:59:00 2022 -0600

    Merge pull request #20 from adam-25/Ali-s-Branch
    
    Updated ChangeReview and its tests, Added some lines to scan item

commit 6e4bafb0e9c8261078264e6118de84523e72a656
Author: Muhammad Ali <muhammad.ali4@ucalgary.ca>
Date:   Wed Mar 30 20:56:50 2022 -0600

    Update ScanItem

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
index 924075f..6dfc5d9 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
@@ -187,6 +187,7 @@ public class ScanItemControllerTest extends BaseTestClass{
 			scanError(eggs);
 			scanError(toast);
 			
+			cs.baggingArea.remove(eggs);
 			SIcontroller.unScanItem(eggs.getBarcode());
 			
 			
@@ -195,7 +196,8 @@ public class ScanItemControllerTest extends BaseTestClass{
 			
 			Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
 			Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
-			
+			Assert.assertFalse(cs.mainScanner.isDisabled());
+			Assert.assertFalse(cs.handheldScanner.isDisabled());
 		}
 		
 		//unscans a item not in the cart

commit 877c7e281448a9f87fcc116d90a0d5636328b92b
Author: Muhammad Ali <muhammad.ali4@ucalgary.ca>
Date:   Wed Mar 30 20:52:28 2022 -0600

    Cleaned up ChangeReceive and its test

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java
index 8df0079..225acc2 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java	
@@ -9,16 +9,20 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+import org.lsmr.selfcheckout.devices.CoinDispenser;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.EmptyException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.SimulationException;
 import org.lsmr.selfcheckout.customer.ChangeReceiveController;
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.customer.*;
 
 public class ChangeReceiveControllerTest extends BaseTestClass {
 	private ChangeReceiveController CRC;
-	// private PaymentController PCTest;
 
 	@Before
 	public void setup() {
@@ -27,11 +31,18 @@ public class ChangeReceiveControllerTest extends BaseTestClass {
 		super.setup();
 
 		// Testing Constructor
-		CRC = new ChangeReceiveController(checkoutStation);
+		try {
+			CRC = new ChangeReceiveController(checkoutStation);
+		} catch (SimulationException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		} catch (OverloadException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
 
 		// Instantiating PaymentController
 		CRC.PC = new PaymentController(checkoutStation);
-
 	}
 
 	@Test
@@ -61,45 +72,102 @@ public class ChangeReceiveControllerTest extends BaseTestClass {
 		BigDecimal dec1 = new BigDecimal(0.50);
 		BigDecimal dec2 = new BigDecimal(1);
 		BigDecimal dec3 = new BigDecimal(2);
-		
+
 		Currency validCurrency = Currency.getInstance("CAD");
-		int[] validBanknoteDenominations = {100,15,10,5};
-		BigDecimal[] validCoinDenominations = {dec1, dec2, dec3};
+		int[] validBanknoteDenominations = { 100, 50, 5 };
+		BigDecimal[] validCoinDenominations = { dec3, dec2, dec1 };
 		int scaleMaxWeight = 2000;
 		int scaleSensitivity = 1;
-		SelfCheckoutStation sc = new SelfCheckoutStation(validCurrency, validBanknoteDenominations, validCoinDenominations, scaleMaxWeight, scaleSensitivity);
-		
+		SelfCheckoutStation sc = new SelfCheckoutStation(validCurrency, validBanknoteDenominations,
+				validCoinDenominations, scaleMaxWeight, scaleSensitivity);
+
 		ChangeReceiveController CRCTest = new ChangeReceiveController(sc);
 		CRCTest.PC = new PaymentController(sc);
-		CRCTest.PC.setValueOfCart(BigDecimal.valueOf(-20));
+		CRCTest.PC.setValueOfCart(BigDecimal.valueOf(-101.50));
+
+		BanknoteDispenser noteDispenser = null;
+
+		noteDispenser = new BanknoteDispenser(100);
+
+		for (Integer integer : sc.banknoteDispensers.keySet()) {
+
+			noteDispenser = sc.banknoteDispensers.get(integer);
+
+			for (int i = 0; i < 100; i++) {
+				Banknote bn = new Banknote(Currency.getInstance("CAD"), integer);
+
+				noteDispenser.load(bn);
+
+			}
+
+		}
+
+		CoinDispenser dispenser = null;
+
+		for (BigDecimal denomination : sc.coinDispensers.keySet()) {
+			dispenser = sc.coinDispensers.get(denomination);
+
+			for (int i = 0; i < 100; i++) {
+				Coin cn = new Coin(Currency.getInstance("CAD"), denomination);
+
+				dispenser.load(cn);
+			}
+
+		}
+
 		CRCTest.calcChangeDue();
-		
-//		CRC.PC.setValueOfCart(BigDecimal.valueOf(-1));
-//		CRC.calcChangeDue();
-		
+
 	}
-	
+
 	@Test
 	public void calcChangeDueChangeLeftTest2() throws EmptyException, DisabledException, OverloadException {
 		BigDecimal dec1 = new BigDecimal(0.50);
 		BigDecimal dec2 = new BigDecimal(1);
 		BigDecimal dec3 = new BigDecimal(2);
-		
+
 		Currency validCurrency = Currency.getInstance("CAD");
-		int[] validBanknoteDenominations = {100,15,10,5};
-		BigDecimal[] validCoinDenominations = {dec1, dec2, dec3};
+		int[] validBanknoteDenominations = { 100, 50, 20, 10, 5 };
+		BigDecimal[] validCoinDenominations = { dec3, dec2, dec1 };
 		int scaleMaxWeight = 2000;
 		int scaleSensitivity = 1;
-		SelfCheckoutStation sc = new SelfCheckoutStation(validCurrency, validBanknoteDenominations, validCoinDenominations, scaleMaxWeight, scaleSensitivity);
-		
+		SelfCheckoutStation sc = new SelfCheckoutStation(validCurrency, validBanknoteDenominations,
+				validCoinDenominations, scaleMaxWeight, scaleSensitivity);
+
 		ChangeReceiveController CRCTest = new ChangeReceiveController(sc);
 		CRCTest.PC = new PaymentController(sc);
-		CRCTest.PC.setValueOfCart(BigDecimal.valueOf(-1));
+		CRCTest.PC.setValueOfCart(BigDecimal.valueOf(-20));
+
+		BanknoteDispenser noteDispenser = null;
+
+		noteDispenser = new BanknoteDispenser(100);
+
+		for (Integer integer : sc.banknoteDispensers.keySet()) {
+			noteDispenser = sc.banknoteDispensers.get(integer);
+
+			for (int i = 0; i < 100; i++) {
+				Banknote bn = new Banknote(Currency.getInstance("CAD"), integer);
+
+				noteDispenser.load(bn);
+
+			}
+
+		}
+
+		CoinDispenser dispenser = null;
+
+		for (BigDecimal denomination : sc.coinDispensers.keySet()) {
+			dispenser = sc.coinDispensers.get(denomination);
+
+			for (int i = 0; i < 100; i++) {
+				Coin cn = new Coin(Currency.getInstance("CAD"), denomination);
+
+				dispenser.load(cn);
+			}
+
+		}
+
 		CRCTest.calcChangeDue();
-		
-//		CRC.PC.setValueOfCart(BigDecimal.valueOf(-1));
-//		CRC.calcChangeDue();
-		
+
 	}
 
 }
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java
index f7305b7..1f746bd 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java	
@@ -34,37 +34,32 @@ import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
 
-
 import org.lsmr.selfcheckout.devices.CoinDispenser;
 import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
 
-
 public class ChangeReceiveController {
-	
-	
-	//Want to return any money that was over paid by the customer (change)
-	
-	
-	private final SelfCheckoutStation checkoutStation; 
+
+	// Want to return any money that was over paid by the customer (change)
+
+	private final SelfCheckoutStation checkoutStation;
 	private BigDecimal valueOfCart;
 	private BigDecimal initialValueOfCart;
 	private CDObs cdobs;
 	private BnDObs bndobs;
 	private BigDecimal changeBack;
-	
-	int changeBackList[]; //list to keep track of number of bills/coins returned
-	
-	
-	//Integer bankDenominations[] = {5, 10, 20, 50, 100};
-	//BigDecimal[] cDenominations = new BigDecimal[] {new BigDecimal(0.05), new BigDecimal(0.10)};
-	
-	
-	//Map<BigDecimal, CoinDispenser> dispensers;
-	
+
+	int changeBackList[]; // list to keep track of number of bills/coins returned
+
+	// Integer bankDenominations[] = {5, 10, 20, 50, 100};
+	// BigDecimal[] cDenominations = new BigDecimal[] {new BigDecimal(0.05), new
+	// BigDecimal(0.10)};
+
+	// Map<BigDecimal, CoinDispenser> dispensers;
+
 	public PaymentController PC;
-	
-	//constructor for the customer gets change use case
-	public ChangeReceiveController(SelfCheckoutStation cs){
+
+	// constructor for the customer gets change use case
+	public ChangeReceiveController(SelfCheckoutStation cs) throws SimulationException, OverloadException{
 		checkoutStation = cs;
 		initialValueOfCart = new BigDecimal(0);
 		valueOfCart = new BigDecimal(0);
@@ -75,266 +70,252 @@ public class ChangeReceiveController {
 		cdobs = new CDObs();
 		bndobs = new BnDObs();
 		
+		
+		
+		
 		for(BigDecimal denomination : checkoutStation.coinDispensers.keySet()) {
 			CoinDispenser dispenser = checkoutStation.coinDispensers.get(denomination);
 			dispenser.attach(cdobs);
+			
 		}
 		for(Integer integer : checkoutStation.banknoteDispensers.keySet()) {
-			BanknoteDispenser noteDispenser = checkoutStation.banknoteDispensers.get(integer);
-			noteDispenser = new BanknoteDispenser(100);
-			
-			for (int i=0;i< 100; i++) {
-				
-			}
-			
+			BanknoteDispenser noteDispenser;
+			noteDispenser = checkoutStation.banknoteDispensers.get(integer);
 			noteDispenser.attach(bndobs);
 			
-			//noteDispenser.load(validBanknoteDenominations);
 		}
 		
 	}
-	
+
 	/**
-	 * Method determines how much change is required to be given to customer 
+	 * Method determines how much change is required to be given to customer
 	 * 
-	 * @returns the change that is due. 
+	 * @returns the change that is due.
 	 */
 	public BigDecimal changeDue() {
 		BigDecimal change = PC.getValueOfCart();
-		
-		if(change.compareTo(new BigDecimal(0)) < 0) {
-			//then the customer put more money into the machine than they needed to so we must return change
+
+		if (change.compareTo(new BigDecimal(0)) < 0) {
+			// then the customer put more money into the machine than they needed to so we
+			// must return change
 			return change.abs();
 		}
 		return new BigDecimal(0);
 	}
-	
+
 	/**
 	 * Calculates how the machine will give the change back to the customer
 	 * 
 	 * Assume that the bank denominations are in descending order
 	 * 
 	 * @return
-	 * @throws OverloadException 
-	 * @throws DisabledException 
-	 * @throws EmptyException 
+	 * @throws OverloadException
+	 * @throws DisabledException
+	 * @throws EmptyException
 	 */
 	public void calcChangeDue() throws EmptyException, DisabledException, OverloadException {
-		
-		changeBack = changeDue(); //the total amount of money owed to the customer
+
+		changeBack = changeDue(); // the total amount of money owed to the customer
 		BigDecimal currentChangeLeft;
 		int numOutput;
-		
-		if(changeBack.compareTo(new BigDecimal(0)) == 0){
-			//no change to give back we are done
+
+		if (changeBack.compareTo(new BigDecimal(0)) == 0) {
+			// no change to give back we are done
 			return;
 		}
-		
-		//the following loop deals with banknote change
-		currentChangeLeft = changeBack; //Initial amount of change to give back
-		for(Integer i : checkoutStation.banknoteDispensers.keySet()) {
+
+		// the following loop deals with banknote change
+		currentChangeLeft = changeBack; // Initial amount of change to give back
+		for (Integer i : checkoutStation.banknoteDispensers.keySet()) {
 			BanknoteDispenser noteDispenser = checkoutStation.banknoteDispensers.get(i);
-			//i = 100;
-//			noteDispenser.endConfigurationPhase();
-//			noteDispenser.enable();
-			numOutput = currentChangeLeft.intValue() / i; 
-			for(int j = 0; j < numOutput; j++) {
-				noteDispenser.emit(); //emit the bank note
-				
-				//user removes banknote and then we can continue dispensing the next
+			numOutput = currentChangeLeft.intValue() / i;
+			for (int j = 0; j < numOutput; j++) {
+				noteDispenser.emit(); // emit the bank note
+
+				// user removes banknote and then we can continue dispensing the next
 			}
-			
-			currentChangeLeft.subtract(new BigDecimal(numOutput).multiply(new BigDecimal(i)));
-			
+			currentChangeLeft = currentChangeLeft.subtract(new BigDecimal(numOutput).multiply(new BigDecimal(i)));
+			System.out.println("numOutPut " + numOutput);
+			System.out.println("currentchangeleft " + currentChangeLeft);
 		}
-		
-		//Now we have to give the customer coin change 
-		if(currentChangeLeft.compareTo(new BigDecimal(0)) <= 0) {
-			//if change is already given back then return
-			return;
 			
+		// Now we have to give the customer coin change
+		if (currentChangeLeft.compareTo(new BigDecimal(0)) <= 0) {
+			// if change is already given back then return
+			return;
+
 		}
-			for(BigDecimal d : checkoutStation.coinDispensers.keySet()) {
-				CoinDispenser coinDispenser = checkoutStation.coinDispensers.get(d);
-				numOutput = currentChangeLeft.divide(d).intValue();
-				for(int k = 0; k < numOutput; k++) {
-					coinDispenser.emit(); //emit the coin
-					
-					//user removes coin and then we can continue dispensing the next
-				}
-				currentChangeLeft.subtract(new BigDecimal(numOutput).multiply(d));
+		for (BigDecimal d : checkoutStation.coinDispensers.keySet()) {
+			CoinDispenser coinDispenser = checkoutStation.coinDispensers.get(d);
+			numOutput = currentChangeLeft.divide(d).intValue();
+			for (int k = 0; k < numOutput; k++) {
+				coinDispenser.emit(); // emit the coin
+
+				// user removes coin and then we can continue dispensing the next
 			}
-		
+			currentChangeLeft = currentChangeLeft.subtract(new BigDecimal(numOutput).multiply(d));
+			System.out.println("Coin numOutPut " + numOutput);
+			System.out.println("Coing currentchangeleft " + currentChangeLeft);
+		}
+
 	}
-	
+
 	/**
 	 * This implements the observers required for the customer receives coins
 	 * 
 	 *
 	 */
-	private class CDObs implements CoinDispenserObserver, CoinTrayObserver{
+	private class CDObs implements CoinDispenserObserver, CoinTrayObserver {
 
 		@Override
 		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-			//Ignore
-			
+			// Ignore
+
 		}
 
 		@Override
 		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-			//Ignore
-			
+			// Ignore
+
 		}
 
 		@Override
 		public void coinsFull(CoinDispenser dispenser) {
 			// Ignore. if full we are good
-			
+
 		}
 
 		@Override
 		public void coinsEmpty(CoinDispenser dispenser) {
-			//coin dispenser is empty
-			
-			
+			// coin dispenser is empty
+
 		}
 
 		@Override
 		public void coinAdded(CoinDispenser dispenser, Coin coin) {
-			//This is done by the attendant
-			
+			// This is done by the attendant
+
 		}
 
 		@Override
 		public void coinRemoved(CoinDispenser dispenser, Coin coin) {
-			//coin has been removed from the dispenser
-			//if coinRemoved then we also indicate that the removed coin is now in the tray
+			// coin has been removed from the dispenser
+			// if coinRemoved then we also indicate that the removed coin is now in the tray
 			try {
 				checkoutStation.coinTray.accept(coin);
 			} catch (OverloadException e) {
-				
+
 				e.printStackTrace();
 			} catch (DisabledException e) {
 
 				e.printStackTrace();
 			}
-			
+
 		}
-		
+
 		@Override
 		public void coinAdded(CoinTray tray) {
-			//Indicates a coin has been added to the tray for the customer to pick up
+			// Indicates a coin has been added to the tray for the customer to pick up
 			tray.collectCoins();
 		}
 
 		@Override
 		public void coinsLoaded(CoinDispenser dispenser, Coin... coins) {
-			//Ignore. This is done by the attendant 
-			
+			// Ignore. This is done by the attendant
+
 		}
 
 		@Override
 		public void coinsUnloaded(CoinDispenser dispenser, Coin... coins) {
-			//Ignore. This is done by the attendant
-			
+			// Ignore. This is done by the attendant
+
 		}
 
-		
 	}
-	
+
 	/**
 	 * This implements the observers required for the customer receives banknotes
 	 * 
 	 *
 	 */
-	public class BnDObs implements BanknoteDispenserObserver, BanknoteSlotObserver{
+	public class BnDObs implements BanknoteDispenserObserver, BanknoteSlotObserver {
 
 		@Override
 		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-			//Ignore
-			
+			// Ignore
+
 		}
 
 		@Override
 		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-			//Ignore
-			
+			// Ignore
+
 		}
 
 		@Override
 		public void moneyFull(BanknoteDispenser dispenser) {
-			//if full we good
-			
+			// if full we good
+
 		}
 
 		@Override
 		public void banknotesEmpty(BanknoteDispenser dispenser) {
-			//bank note dispenser is empty
-			
+			// bank note dispenser is empty
+
 		}
 
 		@Override
 		public void billAdded(BanknoteDispenser dispenser, Banknote banknote) {
-			//Ignore this is done by the attendant
-			
+			// Ignore this is done by the attendant
+
 		}
 
 		@Override
 		public void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote) {
-			//a banknote has been emitted for the customer to take
+			// a banknote has been emitted for the customer to take
 			try {
-				checkoutStation.banknoteOutput.emit(banknote);
+				checkoutStation.banknoteOutput.removeDanglingBanknote();
 			} catch (SimulationException e) {
 				throw new SimulationException(
 						"A banknote is already dangling from the slot. Remove that before ejecting another.");
-				//e.printStackTrace();
-			} catch (DisabledException e) {
-				
-				//e.printStackTrace();
-			} 
-			
+				// e.printStackTrace();
+			}
+
 		}
 
 		@Override
 		public void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes) {
-			//Ignore. This is done by the attendant
-			
+			// Ignore. This is done by the attendant
+
 		}
 
 		@Override
 		public void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes) {
-			//Ignore. This is done by the attendant
-			
+			// Ignore. This is done by the attendant
+
 		}
 
 		@Override
 		public void banknoteInserted(BanknoteSlot slot) {
-			//Ignore
-			
+			// Ignore
+
 		}
 
 		@Override
 		public void banknoteEjected(BanknoteSlot slot) {
-			//A bank note has been ejected
-			
-			//for the purpose of this iteration we assume the user takes the banknote right away:
-			checkoutStation.banknoteOutput.removeDanglingBanknote();
-			
+			// A bank note has been ejected
+
+			// for the purpose of this iteration we assume the user takes the banknote right
+			// away:
 		}
 
 		@Override
 		public void banknoteRemoved(BanknoteSlot slot) {
-			//The user has removed the banknote
-			//so we continue the banknote dispensing 
-			
+			// The user has removed the banknote
+			// so we continue the banknote dispensing
+
 		}
-		
-		
-	}
-	
 
-	
-	
-	
+	}
 
 }

commit 5d43b49c6fee436e87ef38c2801d2bdb21502579
Merge: f8b1d05 1690a4a
Author: Adarsh Dudhat <92228157+adam-25@users.noreply.github.com>
Date:   Wed Mar 30 18:56:37 2022 -0600

    Merge pull request #19 from adam-25/new-adarsh
    
    Create Test for addAdditionalItemsAfterPartialPayment use case

commit 0b2e17333def56cfe735c45fcfe2ceca8fcaf9a9
Merge: 7989974 f8b1d05
Author: Muhammad Ali <muhammad.ali4@ucalgary.ca>
Date:   Wed Mar 30 17:51:41 2022 -0600

    Merge branch 'main' into Ali-s-Branch

commit 7989974e8c069db6e534aba74645cd3adc257410
Author: Muhammad Ali <muhammad.ali4@ucalgary.ca>
Date:   Wed Mar 30 17:51:12 2022 -0600

    Working on ChangeReceieveController  and tests for it

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java
index 984cbfc..8df0079 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java	
@@ -2,23 +2,104 @@ package org.lsmr.selfcheckout.customer.testing;
 
 import static org.junit.Assert.*;
 
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.EmptyException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.customer.ChangeReceiveController;
+import org.lsmr.selfcheckout.customer.*;
+
+public class ChangeReceiveControllerTest extends BaseTestClass {
+	private ChangeReceiveController CRC;
+	// private PaymentController PCTest;
+
+	@Before
+	public void setup() {
+
+		// loads in preset data from BaseTestClass
+		super.setup();
 
-public class ChangeReceiveControllerTest {
+		// Testing Constructor
+		CRC = new ChangeReceiveController(checkoutStation);
+
+		// Instantiating PaymentController
+		CRC.PC = new PaymentController(checkoutStation);
 
-	@BeforeClass
-	public static void setUpBeforeClass() throws Exception {
 	}
 
-	@Before
-	public void setUp() throws Exception {
+	@Test
+	public void changeDueGTZeroTest() {
+
+		CRC.PC.setValueOfCart(BigDecimal.valueOf(10));
+		Assert.assertEquals(CRC.changeDue(), BigDecimal.valueOf(0));
+
 	}
 
 	@Test
-	public final void test() {
-		fail("Not yet implemented"); // TODO
+	public void changeDueLTZeroTest() {
+		CRC.PC.setValueOfCart(BigDecimal.valueOf(-1));
+		BigDecimal change = CRC.PC.getValueOfCart();
+
+		Assert.assertEquals(CRC.changeDue(), change.abs());
+	}
+
+	@Test
+	public void calcChangeDueNOChangeLeftTest() throws EmptyException, DisabledException, OverloadException {
+		CRC.PC.setValueOfCart(BigDecimal.valueOf(10));
+		CRC.calcChangeDue();
+	}
+
+	@Test
+	public void calcChangeDueChangeLeftTest1() throws EmptyException, DisabledException, OverloadException {
+		BigDecimal dec1 = new BigDecimal(0.50);
+		BigDecimal dec2 = new BigDecimal(1);
+		BigDecimal dec3 = new BigDecimal(2);
+		
+		Currency validCurrency = Currency.getInstance("CAD");
+		int[] validBanknoteDenominations = {100,15,10,5};
+		BigDecimal[] validCoinDenominations = {dec1, dec2, dec3};
+		int scaleMaxWeight = 2000;
+		int scaleSensitivity = 1;
+		SelfCheckoutStation sc = new SelfCheckoutStation(validCurrency, validBanknoteDenominations, validCoinDenominations, scaleMaxWeight, scaleSensitivity);
+		
+		ChangeReceiveController CRCTest = new ChangeReceiveController(sc);
+		CRCTest.PC = new PaymentController(sc);
+		CRCTest.PC.setValueOfCart(BigDecimal.valueOf(-20));
+		CRCTest.calcChangeDue();
+		
+//		CRC.PC.setValueOfCart(BigDecimal.valueOf(-1));
+//		CRC.calcChangeDue();
+		
+	}
+	
+	@Test
+	public void calcChangeDueChangeLeftTest2() throws EmptyException, DisabledException, OverloadException {
+		BigDecimal dec1 = new BigDecimal(0.50);
+		BigDecimal dec2 = new BigDecimal(1);
+		BigDecimal dec3 = new BigDecimal(2);
+		
+		Currency validCurrency = Currency.getInstance("CAD");
+		int[] validBanknoteDenominations = {100,15,10,5};
+		BigDecimal[] validCoinDenominations = {dec1, dec2, dec3};
+		int scaleMaxWeight = 2000;
+		int scaleSensitivity = 1;
+		SelfCheckoutStation sc = new SelfCheckoutStation(validCurrency, validBanknoteDenominations, validCoinDenominations, scaleMaxWeight, scaleSensitivity);
+		
+		ChangeReceiveController CRCTest = new ChangeReceiveController(sc);
+		CRCTest.PC = new PaymentController(sc);
+		CRCTest.PC.setValueOfCart(BigDecimal.valueOf(-1));
+		CRCTest.calcChangeDue();
+		
+//		CRC.PC.setValueOfCart(BigDecimal.valueOf(-1));
+//		CRC.calcChangeDue();
+		
 	}
 
 }
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java
index e5db900..f7305b7 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java	
@@ -81,7 +81,15 @@ public class ChangeReceiveController {
 		}
 		for(Integer integer : checkoutStation.banknoteDispensers.keySet()) {
 			BanknoteDispenser noteDispenser = checkoutStation.banknoteDispensers.get(integer);
+			noteDispenser = new BanknoteDispenser(100);
+			
+			for (int i=0;i< 100; i++) {
+				
+			}
+			
 			noteDispenser.attach(bndobs);
+			
+			//noteDispenser.load(validBanknoteDenominations);
 		}
 		
 	}
@@ -126,6 +134,9 @@ public class ChangeReceiveController {
 		currentChangeLeft = changeBack; //Initial amount of change to give back
 		for(Integer i : checkoutStation.banknoteDispensers.keySet()) {
 			BanknoteDispenser noteDispenser = checkoutStation.banknoteDispensers.get(i);
+			//i = 100;
+//			noteDispenser.endConfigurationPhase();
+//			noteDispenser.enable();
 			numOutput = currentChangeLeft.intValue() / i; 
 			for(int j = 0; j < numOutput; j++) {
 				noteDispenser.emit(); //emit the bank note

commit 1690a4abc2491bc839363e3a4c3421ae188f55cf
Author: adam-25 <adarsh.dudhat11@gmail.com>
Date:   Wed Mar 30 17:14:18 2022 -0600

    Create Test for addItemAfterPartialPayment use case

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
index 924075f..937acaf 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
@@ -6,11 +6,14 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import java.util.HashMap;
+
+import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
 import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.PaymentController;
 import org.lsmr.selfcheckout.customer.ScanItemController;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
@@ -34,6 +37,7 @@ public class ScanItemControllerTest extends BaseTestClass{
 	//declaring controllers 
 	private ScanItemController SIcontroller;
 	private BaggingAreaController bAcontroller;
+	private PaymentController pController;
 	
 	//initializing prices of items
 	BigDecimal milkPrice = new BigDecimal(2.50);
@@ -80,6 +84,8 @@ public class ScanItemControllerTest extends BaseTestClass{
 		bAcontroller = new BaggingAreaController(cs);
 		SIcontroller = new ScanItemController(cs, barcodePrice, barcodeWeight);
 
+		pController = new PaymentController(cs);
+		
 		//calling object methods
 		bAcontroller.setScanItemControl(SIcontroller);
 		SIcontroller.setBagAreaControl(bAcontroller);
@@ -224,6 +230,115 @@ public class ScanItemControllerTest extends BaseTestClass{
 					
 		}
 				
+		@Test
+		public void scanItemAfterPartialPaymentTest() throws DisabledException, OverloadException
+		{
+			BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+			BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+			BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+			
+			BigDecimal expectedValueOfCart = new BigDecimal(0);
+			expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+			expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+			
+			pController.initiateStart();
+			
+			scanError(milk);
+			scanError(eggs);
+			
+			pController.setValueOfCart(expectedValueOfCart);
+			
+			pController.inititateCheckout();
+			
+			cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 5));
+			
+			BigDecimal expectedValueOfCartAfterPartialPayment;
+			
+			expectedValueOfCartAfterPartialPayment = expectedValueOfCart.subtract(new BigDecimal(5));
+
+			Assert.assertEquals(expectedValueOfCartAfterPartialPayment, pController.getValueOfCart());
+			Assert.assertTrue(cs.mainScanner.isDisabled());
+			Assert.assertTrue(cs.handheldScanner.isDisabled());
+			
+			pController.addItemsWithPartialPayment();
+
+			Assert.assertFalse(cs.mainScanner.isDisabled());
+			Assert.assertFalse(cs.handheldScanner.isDisabled());
+			
+			expectedValueOfCart = expectedValueOfCartAfterPartialPayment;
+			expectedValueOfCart = expectedValueOfCart.add(toastPrice);
+			
+			scanError(toast);
+			
+			pController.setValueOfCart(expectedValueOfCart);
+			
+			Assert.assertEquals(3, SIcontroller.numOfScannedItems());
+			
+			try {
+				cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+				fail("Disabled Exception to be thrown");
+			}
+			catch (DisabledException e)
+			{
+				Assert.assertTrue(e instanceof DisabledException);
+			}
+			catch (Exception e)
+			{
+				fail("Disabled Exception to be thrown instead of " + e);
+			}
+			
+			Assert.assertEquals(expectedValueOfCart, pController.getValueOfCart());
+			
+		}
 		
+		@Test
+		public void fullPaymentAfterPartialPaymentTest() throws DisabledException, OverloadException
+		{
+			BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+			BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+			BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+			
+			BigDecimal expectedValueOfCart = new BigDecimal(0);
+			expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+			expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+			
+			pController.initiateStart();
+			
+			scanError(milk);
+			scanError(eggs);
+			
+			pController.setValueOfCart(expectedValueOfCart);
+			
+			pController.inititateCheckout();
+			
+			cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 5));
+			
+			BigDecimal expectedValueOfCartAfterPartialPayment;
+			
+			expectedValueOfCartAfterPartialPayment = expectedValueOfCart.subtract(new BigDecimal(5));
+
+			Assert.assertTrue(cs.mainScanner.isDisabled());
+			Assert.assertTrue(cs.handheldScanner.isDisabled());
+			
+			pController.addItemsWithPartialPayment();
+
+			Assert.assertFalse(cs.mainScanner.isDisabled());
+			Assert.assertFalse(cs.handheldScanner.isDisabled());
+			
+			expectedValueOfCart = expectedValueOfCartAfterPartialPayment;
+			expectedValueOfCart = expectedValueOfCart.add(toastPrice);
+			
+			scanError(toast);
+			
+			pController.setValueOfCart(expectedValueOfCart);
+			
+			pController.inititateCheckout();
+			
+			cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+			
+			Assert.assertTrue(cs.mainScanner.isDisabled());
+			Assert.assertTrue(cs.handheldScanner.isDisabled());
+			
+		}
 	
 }
\ No newline at end of file

commit f8dda5ad62e57e47452ec5dbd0063a9bdf1a5335
Author: adam-25 <adarsh.dudhat11@gmail.com>
Date:   Wed Mar 30 15:28:31 2022 -0600

    Create test for Fails to put item in Bagging area

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
index 1b7debe..c98ce10 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
@@ -53,7 +53,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		}
 	}
 	
-	public void mainScanError(BarcodedItem item) {
+	public void mainScanErrorWithPlacement(BarcodedItem item) {
 		while (true) {
 			checkoutStation.mainScanner.scan(item);
 			
@@ -64,6 +64,16 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		}
 	}
 	
+	public void mainScanErrorWithoutPlacement(BarcodedItem item) {
+		while (true) {
+			checkoutStation.mainScanner.scan(item);
+			
+			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
+				break;
+			}
+		}
+	}
+	
 	//Initialize selfcheckout station 
 	//Bagging area controller
 	//Scan item controller
@@ -108,13 +118,13 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		
 		
 		try {
-			mainScanError(item3);
+			mainScanErrorWithPlacement(item3);
 
-			mainScanError(item1);
+			mainScanErrorWithPlacement(item1);
 
-			mainScanError(item2);
+			mainScanErrorWithPlacement(item2);
 	
-			mainScanError(item3Dup1);
+			mainScanErrorWithPlacement(item3Dup1);
 
 
 			
@@ -143,10 +153,10 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 			
 			try {
-				mainScanError(item3);
-				mainScanError(item1);
-				mainScanError(item2);
-				mainScanError(item3Dup1);
+				mainScanErrorWithPlacement(item3);
+				mainScanErrorWithPlacement(item1);
+				mainScanErrorWithPlacement(item2);
+				mainScanErrorWithPlacement(item3Dup1);
 			} catch(Exception e) {
 				//shouldn't each here
 				System.out.println("not supposed to occur");
@@ -181,7 +191,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 400.0);
 		
 		try {
-			mainScanError(item1);
+			mainScanErrorWithPlacement(item1);
 		} catch (Exception e) {
 			System.out.println("Shouldn't happen");
 			fail();
@@ -200,7 +210,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 400.0);
 
 		try {
-			mainScanError(item1);
+			mainScanErrorWithPlacement(item1);
 		} catch (Exception e) {
 			System.out.println("Shouldn't happen");
 			fail();
@@ -218,8 +228,8 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		BarcodedItem item1Dup1 = new BarcodedItem(barcodeItem1, 400.0);
 		
 		try {
-			mainScanError(item1);
-			mainScanError(item1Dup1);
+			mainScanErrorWithPlacement(item1);
+			mainScanErrorWithPlacement(item1Dup1);
 		} catch (Exception e) {
 			System.out.println("Shouldn't happen");
 			fail();
@@ -240,10 +250,10 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
 			
 		try {
-			mainScanError(item3);
-			mainScanError(item1);
-			mainScanError(item2);
-			mainScanError(item3Dup1);
+			mainScanErrorWithPlacement(item3);
+			mainScanErrorWithPlacement(item1);
+			mainScanErrorWithPlacement(item2);
+			mainScanErrorWithPlacement(item3Dup1);
 				
 		} catch(Exception e) {
 				//shouldn't each here
@@ -276,9 +286,9 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 					
 		try {
-			mainScanError(item3);
-			mainScanError(item1);
-			mainScanError(item2);
+			mainScanErrorWithPlacement(item3);
+			mainScanErrorWithPlacement(item1);
+			mainScanErrorWithPlacement(item2);
 
 						
 		} catch(Exception e) {
@@ -357,9 +367,9 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 					
 		try {
-			mainScanError(item3);
-			mainScanError(item1);
-			mainScanError(item2);
+			mainScanErrorWithPlacement(item3);
+			mainScanErrorWithPlacement(item1);
+			mainScanErrorWithPlacement(item2);
 
 						
 		} catch(Exception e) {
@@ -439,4 +449,35 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
 	}
 	
+	@Test (expected = SimulationException.class)
+	public void failsToPlaceItemInBaggingArea()
+	{
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+					
+		try {
+			mainScanErrorWithoutPlacement(item1);
+
+						
+		} catch(Exception e) {
+			//shouldn't each here
+			System.out.println("not supposed to occur");
+			e.printStackTrace();
+			fail();
+		}
+		
+		try {
+			Thread.sleep(6000);
+		} catch (InterruptedException e) {
+			e.printStackTrace();
+		}
+		
+		checkoutStation.baggingArea.add(item1);
+		
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+	}
+	
 }
\ No newline at end of file

commit f8b1d05af34888e101e327fd61143bd7911daf49
Merge: 8ba99a7 bec242d
Author: mohamedhefnawy1 <mohamedhefnawy10@gmail.com>
Date:   Wed Mar 30 15:09:23 2022 -0600

    Merge pull request #18 from adam-25/partialPaymentUseCase
    
    Partial payment use case

commit bec242d1231c1c21e3293cd7af1806a1f9b207af
Author: mohamedhefnawy1 <mohamedhefnawy10@gmail.com>
Date:   Wed Mar 30 15:08:28 2022 -0600

    implemented the addItemsWithPartialPayment use case
    
    contributors:  Simon Vincent, Muhammad Ali
    Adarsh Dudhat
    Matthew Newton
    Aly Khedr

diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
deleted file mode 100644
index cf1db2e..0000000
--- a/SCS - Hardware - v2.0/bin/.gitignore	
+++ /dev/null
@@ -1 +0,0 @@
-/org/
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
index 610dd1f..6906188 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java	
@@ -52,6 +52,8 @@ public class PaymentControllerTest extends BaseTestClass {
 	
 	private ReceiptPrinterController RPcontroller;
 	
+
+	
 	BigDecimal milkPrice = new BigDecimal(2.50);
 	Numeral[] nMilk = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
 	Barcode barcodeMilk = new Barcode(nMilk);
@@ -128,6 +130,8 @@ public class PaymentControllerTest extends BaseTestClass {
 			e.printStackTrace();
 		}
 		
+		
+		
 		//See if cost was paid
 		//Value of cart at the start of test is $20
 		//After banknote slot accepts and validates, it should be $0
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index eda14ca..bc38996 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -27,6 +27,7 @@ import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+import org.lsmr.selfcheckout.customer.ScanItemController;
 
 public class PaymentController extends TouchScreenController{
 
@@ -46,6 +47,7 @@ public class PaymentController extends TouchScreenController{
 	private PCC pcc;
 	private PCB pcb;
 	private CC cc;
+	private ScanItemController SIcontroller;
 	private List<Coin> coinTrayList;
 	private BigDecimal initialValueOfCart;
 	private String membershipNo = null;
@@ -56,6 +58,7 @@ public class PaymentController extends TouchScreenController{
 	public PaymentController(SelfCheckoutStation cs){
 		super(cs);
 		checkoutStation = cs;
+		
 		//touchScreen = new TouchScreenController(checkoutStation);
 		initialValueOfCart = new BigDecimal(0);
 		valueOfCart = new BigDecimal(0);
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
index adb53a0..4006097 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
@@ -11,7 +11,7 @@ import org.lsmr.selfcheckout.devices.BarcodeScanner;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
+
 
 public class ScanItemController  {
 	 
@@ -24,6 +24,7 @@ public class ScanItemController  {
 	private SIC sic;
 	private List<Barcode> scannedItemList;  
 	private BaggingAreaController bagAreaControl;	
+
 	
 
 	//Constructor
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
index a14bcc0..870e3b3 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
@@ -33,6 +33,7 @@ public class TouchScreenController  implements TouchScreenObserver{
 		state = checkoutState.SCAN;
 		checkoutStation.mainScanner.enable();
 		checkoutStation.handheldScanner.enable();
+		
 	}
 	
 	/**

commit 010b35d1d0e883f509e2be02e50810838263363c
Author: FallenByGravity <34290834+FallenByGravity@users.noreply.github.com>
Date:   Wed Mar 30 14:05:03 2022 -0600

    Add files via upload

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index 16c77ee..eda14ca 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -9,6 +9,7 @@ import java.util.List;
 import org.lsmr.selfcheckout.BlockedCardException;
 import org.lsmr.selfcheckout.Card;
 import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.customer.TouchScreenController.checkoutState;
 import org.lsmr.selfcheckout.Card.CardData;
 import org.lsmr.selfcheckout.Card.CardSwipeData;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
@@ -27,7 +28,7 @@ import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
 
-public class PaymentController{
+public class PaymentController extends TouchScreenController{
 
 	// The three possible values CardDate.getType() should return
 	private final String debit = "DEBIT";
@@ -37,8 +38,11 @@ public class PaymentController{
 	// Used for testing. Setting verified to false will simulate the bank rejecting the credit/debit card.
 	public boolean verified = true;
 	
+	
+	
 	private BigDecimal valueOfCart;
 	private final SelfCheckoutStation checkoutStation; 
+	///private TouchScreenController touchScreen = new TouchScreenController(checkoutStation);
 	private PCC pcc;
 	private PCB pcb;
 	private CC cc;
@@ -50,7 +54,9 @@ public class PaymentController{
 	private boolean cardInsert = false;
 	
 	public PaymentController(SelfCheckoutStation cs){
+		super(cs);
 		checkoutStation = cs;
+		//touchScreen = new TouchScreenController(checkoutStation);
 		initialValueOfCart = new BigDecimal(0);
 		valueOfCart = new BigDecimal(0);
 		coinTrayList = new ArrayList<Coin>();
@@ -138,6 +144,14 @@ public class PaymentController{
 		membershipNo = manualMembershipNo;
 	}
 	
+	public void addItemsWithPartialPayment() {
+		state = checkoutState.SCAN;
+		checkoutStation.mainScanner.enable();
+		checkoutStation.handheldScanner.enable();
+		checkoutStation.coinSlot.disable();
+		checkoutStation.banknoteInput.disable();
+	}
+	
 	/**
 	 * If all items have been paid for, return true
 	 * And disable the coin and bank note slot.
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
index 23d255c..a14bcc0 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
@@ -1,12 +1,19 @@
 package org.lsmr.selfcheckout.customer;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.TouchScreenObserver;
 
 
-public class TouchScreenController  {
+
+public class TouchScreenController  implements TouchScreenObserver{
 		
 	private final SelfCheckoutStation checkoutStation;
-	protected boolean askAttendantHelp = false;
+	public checkoutState state;
 	
+	public enum checkoutState{
+		SCAN, PAY
+	}
 	//Constructor - Initialize SelfCheckoutStation
 	
 	/**
@@ -14,12 +21,16 @@ public class TouchScreenController  {
 	 */
 	public TouchScreenController(SelfCheckoutStation cs) {
 		checkoutStation = cs;
+		state = checkoutState.SCAN;
+		
+		
 	}
 	
 	/**
 	 * Enables the scanner to allow the user to begin scanning items.
 	 */
 	public void initiateStart() {
+		state = checkoutState.SCAN;
 		checkoutStation.mainScanner.enable();
 		checkoutStation.handheldScanner.enable();
 	}
@@ -28,9 +39,22 @@ public class TouchScreenController  {
 	 * To be triggered after all items are scanned. Disables scanner and allows the user to pay with cash.
 	 */
 	public void inititateCheckout() {
+		state = checkoutState.PAY;
 		checkoutStation.mainScanner.disable();
 		checkoutStation.handheldScanner.disable();
 		checkoutStation.coinSlot.enable();
 		checkoutStation.banknoteInput.enable();
 	}
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
 }
\ No newline at end of file

commit 8ba99a7f1e8b4940792e8f9cab67e14f890b2345
Author: adam-25 <adarsh.dudhat11@gmail.com>
Date:   Wed Mar 30 11:42:09 2022 -0600

    Change spelling mistakes and type of variable
    
    Change spelling of attendantVerifiedBag to attendantVerifyBag and change type of begin variable.

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
index aac6779..1b7debe 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
@@ -314,7 +314,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		
 		checkoutStation.baggingArea.add(bag);
 		
-		BACController.attendantVeritfyBag();
+		BACController.attendantVerifiedBag();
 		
 		BACController.setAttendantHelp(false);
 		
@@ -335,7 +335,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		
 		checkoutStation.baggingArea.add(bag);
 		
-		BACController.attendantVeritfyBag();
+		BACController.attendantVerifiedBag();
 		
 		BACController.setAttendantHelp(false);
 		
@@ -378,7 +378,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		
 		checkoutStation.baggingArea.add(bag);
 		
-		BACController.attendantVeritfyBag();
+		BACController.attendantVerifiedBag();
 		
 		BACController.setAttendantHelp(false);
 		
@@ -403,7 +403,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		
 		checkoutStation.baggingArea.add(bag);
 		
-		BACController.attendantVeritfyBag();
+		BACController.attendantVerifiedBag();
 		
 		BACController.setAttendantHelp(false);
 		
@@ -423,7 +423,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		
 		try {
 			checkoutStation.baggingArea.add(bag);
-			BACController.attendantVeritfyBag();
+			BACController.attendantVerifiedBag();
 			fail("Expected SimulationException to be thrown");
 		}
 		catch (SimulationException e)
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index bb29872..3896f5c 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -20,7 +20,7 @@ public class BaggingAreaController extends TouchScreenController{
 	private ScanItemController scanItemControl;
 	private int numOfItemsInBaggingArea;
 	private double previousWeightOfCart;
-	private long begin;
+	private double begin;
 	private boolean askAttendantHelp = false;
 
 

commit cff35bf7cfe7f00fbad5797703d8fa45011c65f0
Merge: af08e95 37dacc2
Author: Matthew Newton <60675042+Mattynewts@users.noreply.github.com>
Date:   Wed Mar 30 11:22:31 2022 -0600

    Merge pull request #17 from adam-25/new-adarsh
    
    Changes to BaggingAreaController and Add Test

commit 37dacc2428f76145db4f84a8bc3ea8c8959fc5f9
Merge: 95bc686 af08e95
Author: Matthew Newton <60675042+Mattynewts@users.noreply.github.com>
Date:   Wed Mar 30 11:13:59 2022 -0600

    Merge branch 'main' into new-adarsh

commit 95bc68672684c9b4c7636748429a74e261960d0c
Author: adam-25 <adarsh.dudhat11@gmail.com>
Date:   Wed Mar 30 10:40:52 2022 -0600

    Changes to BaggingAreaController and Add Test
    
    There are several changes to BaggingAreaController and one change to TouchScreenController which is adding boolean variable to it. Moreover, Add test for customer own bags.

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
index 4207ee7..aac6779 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
@@ -1,9 +1,5 @@
 package org.lsmr.selfcheckout.customer.testing;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.math.BigDecimal;
@@ -48,10 +44,10 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 	//Method to ensure that the item scanned is actually added
 	public void handheldScanError(BarcodedItem item) {
 		while (true) {
-			cs.handheldScanner.scan(item);
+			checkoutStation.handheldScanner.scan(item);
 			
 			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
-				cs.baggingArea.add(item);
+				checkoutStation.baggingArea.add(item);
 				break;
 			}
 		}
@@ -59,10 +55,10 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 	
 	public void mainScanError(BarcodedItem item) {
 		while (true) {
-			cs.mainScanner.scan(item);
+			checkoutStation.mainScanner.scan(item);
 			
 			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
-				cs.baggingArea.add(item);
+				checkoutStation.baggingArea.add(item);
 				break;
 			}
 		}
@@ -76,7 +72,6 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		
 		//Use checkout station from base test class
 		super.setup();
-		cs = checkoutStation;
 		
 		
 		
@@ -202,7 +197,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 	//double check to see if test logic is sound
 	@Test
 	public void testWeightChanged2() {
-		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 200.0);
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 400.0);
 
 		try {
 			mainScanError(item1);
@@ -217,94 +212,231 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 	
 	//Test if scanner is disabled if there is a weight discrepancy
 		//test 2 items with one having discrepancy in the weight that is correct weight and one that is greater than the expected
-		@Test
-		public void testWeightChanged3() {
-			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
-			BarcodedItem item1Dup1 = new BarcodedItem(barcodeItem1, 400.0);
-
-			try {
-				mainScanError(item1);
-				mainScanError(item1Dup1);
-			} catch (Exception e) {
-				System.out.println("Shouldn't happen");
-				fail();
-			}
-			
-			Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
-			Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+	@Test
+	public void testWeightChanged3() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+		BarcodedItem item1Dup1 = new BarcodedItem(barcodeItem1, 400.0);
+		
+		try {
+			mainScanError(item1);
+			mainScanError(item1Dup1);
+		} catch (Exception e) {
+			System.out.println("Shouldn't happen");
+			fail();
 		}
+		
+		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+	}
 	
 		//Test to see that when an item is removed the controller knows and adjusts the number in the cart
-		@Test
-		public void testWeightChanged4() {
-			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
-			BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
-			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
-			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
+	@Test
+	public void testWeightChanged4() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+		BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+		BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+		BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
 
-			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
 			
-			try {
-				mainScanError(item3);
-				mainScanError(item1);
-				mainScanError(item2);
-				mainScanError(item3Dup1);
+		try {
+			mainScanError(item3);
+			mainScanError(item1);
+			mainScanError(item2);
+			mainScanError(item3Dup1);
 				
-			} catch(Exception e) {
+		} catch(Exception e) {
 				//shouldn't each here
-				System.out.println("not supposed to occur");
-				e.printStackTrace();
-				fail();
-			}
-			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 4);
-			
-			try {
-				checkoutStation.baggingArea.remove(item3Dup1);
-			} catch (Exception e) {
-				fail();
-			}
+			System.out.println("not supposed to occur");
+			e.printStackTrace();
+			fail();
+		}
+		Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 4);
 			
-			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
-			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
-			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
+		try {
+			checkoutStation.baggingArea.remove(item3Dup1);
+		} catch (Exception e) {
+			fail();
 		}
+			
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
+	}
 		
 		//Test to see that when all items are removed the controller knows and adjusts the number in the cart
-				@Test
-				public void testWeightChanged5() {
-					BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
-					BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
-					BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+	@Test
+	public void testWeightChanged5() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+		BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+		BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
 
 
-					Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
-					Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 					
-					try {
-						mainScanError(item3);
-						mainScanError(item1);
-						mainScanError(item2);
+		try {
+			mainScanError(item3);
+			mainScanError(item1);
+			mainScanError(item2);
 
 						
-					} catch(Exception e) {
-						//shouldn't each here
-						System.out.println("not supposed to occur");
-						e.printStackTrace();
-						fail();
-					}
+		} catch(Exception e) {
+			//shouldn't each here
+			System.out.println("not supposed to occur");
+			e.printStackTrace();
+			fail();
+		}
 					
-					Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
+		Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
 					
-					try {
-						checkoutStation.baggingArea.remove(item2);
-						checkoutStation.baggingArea.remove(item3);
-						checkoutStation.baggingArea.remove(item1);
-					} catch (Exception e) {
-						fail();
-					}
+		try {
+			checkoutStation.baggingArea.remove(item2);
+			checkoutStation.baggingArea.remove(item3);
+			checkoutStation.baggingArea.remove(item1);
+		} catch (Exception e) {
+			fail();
+		}
 					
 
-					Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 0);
-				}
+		Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 0);
+	}
+	
+	@Test
+	public void scannerEnableAfterVerifingBagTest()
+	{
+		BarcodedItem bag = new BarcodedItem(barcodeItem1, 1.5);
+
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		
+		BACController.setAttendantHelp(true);
+		
+		checkoutStation.baggingArea.add(bag);
+		
+		BACController.attendantVeritfyBag();
+		
+		BACController.setAttendantHelp(false);
+		
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		
+	}
+	
+	@Test
+	public void numberOfItemsInBaggingAreaWithOwnBagsTest()
+	{
+		BarcodedItem bag = new BarcodedItem(barcodeItem1, 1.5);
+
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		
+		BACController.setAttendantHelp(true);
+		
+		checkoutStation.baggingArea.add(bag);
+		
+		BACController.attendantVeritfyBag();
+		
+		BACController.setAttendantHelp(false);
+		
+		Assert.assertEquals(1, BACController.getNumOfItemsInBaggingArea());
+		
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+	}
+	
+	@Test
+	public void addBagAfterScanningItemsAllTest()
+	{
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+		BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+		BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+
+
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+					
+		try {
+			mainScanError(item3);
+			mainScanError(item1);
+			mainScanError(item2);
+
+						
+		} catch(Exception e) {
+			//shouldn't each here
+			System.out.println("not supposed to occur");
+			e.printStackTrace();
+			fail();
+		}
+		
+		BarcodedItem bag = new BarcodedItem(barcodeItem1, 1.5);
+		
+		Assert.assertEquals(1400.0, BACController.getWeightOfCart(), 0);
+		Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
+		
+		BACController.setAttendantHelp(true);
+		
+		checkoutStation.baggingArea.add(bag);
+		
+		BACController.attendantVeritfyBag();
+		
+		BACController.setAttendantHelp(false);
+		
+		Assert.assertEquals(1401.5, BACController.getWeightOfCart(), 0);
+		Assert.assertEquals(4, BACController.getNumOfItemsInBaggingArea());
+		
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+	}
+	
+	@Test
+	public void weightAfterAddingBagTest()
+	{
+		BarcodedItem bag = new BarcodedItem(barcodeItem1, 1.5);
+		
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		
+		Assert.assertEquals(0.0, BACController.getWeightOfCart(), 0);
+		
+		BACController.setAttendantHelp(true);
+		
+		checkoutStation.baggingArea.add(bag);
+		
+		BACController.attendantVeritfyBag();
+		
+		BACController.setAttendantHelp(false);
+		
+		Assert.assertEquals(1.5, BACController.getWeightOfCart(), 0);
+		
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+	}
+	
+	@Test
+	public void tryToAddBagWithoutHelpOfAttendantTest()
+	{
+		BarcodedItem bag = new BarcodedItem(barcodeItem1, 1.5);
+		
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		
+		try {
+			checkoutStation.baggingArea.add(bag);
+			BACController.attendantVeritfyBag();
+			fail("Expected SimulationException to be thrown");
+		}
+		catch (SimulationException e)
+		{
+			Assert.assertTrue("Expected Simulation exception", e instanceof SimulationException);
+		}
+		catch (Exception e)
+		{
+			fail("Expected SimulationExcetion instead " + e);
+		}
+		
+		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+	}
 	
 }
\ No newline at end of file
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index 50752ac..97471c9 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -12,7 +12,7 @@ import org.lsmr.selfcheckout.devices.SimulationException;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
 
-public class BaggingAreaController {
+public class BaggingAreaController extends TouchScreenController{
 
 	private final SelfCheckoutStation checkoutStation;
 	private BAC bac;
@@ -21,10 +21,11 @@ public class BaggingAreaController {
 	private int numOfItemsInBaggingArea;
 	private double previousWeightOfCart;
 	private long begin;
+	private boolean askAttendantHelp = false;
 
 	// Constructor
 	public BaggingAreaController(SelfCheckoutStation cs) {
-
+		super(cs);
 		checkoutStation = cs;
 		bac = new BAC();
 		weightOfCart = 0;
@@ -73,6 +74,7 @@ public class BaggingAreaController {
 			} else {
 				numOfItemsInBaggingArea--;
 			}
+			
 
 			// Once item has been placed in bagging area, enable the scanner
 			// If expected weight of cart (determined by scanner)
@@ -87,7 +89,8 @@ public class BaggingAreaController {
 			}
 
 			long end = System.currentTimeMillis();
-			if (end - begin > 5000) {
+				
+			if (end - begin > 5000 && !askAttendantHelp) {
 				throw new SimulationException("Fail to place the item in the bagging area within the required time");
 			}
 		}
@@ -109,15 +112,21 @@ public class BaggingAreaController {
 
 	public void attendantVeritfyBag() {
 		BigDecimal bagPrice = new BigDecimal(0);
-		Numeral[] nBag = { Numeral.one, Numeral.two, Numeral.three, Numeral.four };
+		Numeral[] nBag = { Numeral.nine, Numeral.nine, Numeral.nine, Numeral.nine };
 		Barcode barcodeBag = new Barcode(nBag);
 		scanItemControl.getBarcodePrice().put(barcodeBag, bagPrice);
 		double bagWeight = weightOfCart - previousWeightOfCart;
 		scanItemControl.getBarcodeWeight().put(barcodeBag, bagWeight);
 		BarcodedItem bagItem = new BarcodedItem(barcodeBag, bagWeight);
 		checkoutStation.mainScanner.enable();
+		checkoutStation.handheldScanner.enable();
 		checkoutStation.mainScanner.scan(bagItem);
 	}
+	
+	public void setAttendantHelp(boolean attendantHelp)
+	{
+		askAttendantHelp = attendantHelp;
+	}
 
 	public double getWeightOfCart() {
 		return weightOfCart;
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
index 8315092..23d255c 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
@@ -5,6 +5,7 @@ import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 public class TouchScreenController  {
 		
 	private final SelfCheckoutStation checkoutStation;
+	protected boolean askAttendantHelp = false;
 	
 	//Constructor - Initialize SelfCheckoutStation
 	

commit af08e95fc2b801cf41d9e03482b44ce5e620a60e
Merge: f662c60 9ab8c12
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Tue Mar 29 21:03:21 2022 -0600

    Merge pull request #13 from adam-25/simon2
    
    Deleted CardController

commit f662c60452b9639096a1e0021a01d1c3fcf05b90
Merge: 28f5b51 c499171
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Tue Mar 29 21:00:35 2022 -0600

    Merge pull request #16 from adam-25/Ali-s-Branch
    
    Ali s branch

commit c499171311f8cec8c1e4283e5ee7a1e56f64a13f
Author: Muhammad Ali <muhammad.ali4@ucalgary.ca>
Date:   Tue Mar 29 20:56:43 2022 -0600

    Fixed (Failed to place item in bagging Area)

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index 50752ac..03fc52f 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -20,7 +20,7 @@ public class BaggingAreaController {
 	private ScanItemController scanItemControl;
 	private int numOfItemsInBaggingArea;
 	private double previousWeightOfCart;
-	private long begin;
+	private double begin;
 
 	// Constructor
 	public BaggingAreaController(SelfCheckoutStation cs) {
@@ -45,7 +45,7 @@ public class BaggingAreaController {
 		return numOfItemsInBaggingArea;
 	}
 
-	public void getBeginTime(long begin) {
+	public void setBeginTime(double begin) {
 		this.begin = begin;
 	}
 
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
index 989208e..adb53a0 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
@@ -78,9 +78,6 @@ public class ScanItemController  {
 		}
 	}
 	
-	public void getBeginTime(long begin) {
-		bagAreaControl.getBeginTime(begin);
-	}
 	
 	//Barcode Scanner Observer Implementation
 	public class SIC implements BarcodeScannerObserver {
@@ -119,8 +116,8 @@ public class ScanItemController  {
 				checkoutStation.handheldScanner.enable();
 			}
 			
-			long begin = System.currentTimeMillis();
-			getBeginTime(begin);
+			double begin = System.currentTimeMillis();
+			bagAreaControl.setBeginTime(begin);
 		}
 	}
 	

commit 28f5b514364f23b1e22e477dbd2e3a0d29fa3862
Merge: 6bb4548 c61d1ff
Author: mahianm <101750087+mahianm@users.noreply.github.com>
Date:   Tue Mar 29 20:47:31 2022 -0600

    Merge pull request #15 from adam-25/Mahian
    
    Update BaggingAreaController.java

commit c61d1ffe93a90162a83826cf91cb4d3c26ef66fb
Author: mahianm <101750087+mahianm@users.noreply.github.com>
Date:   Tue Mar 29 20:46:30 2022 -0600

    Update BaggingAreaController.java
    
    Corrected the if statement for account for the sensitivity.

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index 50752ac..9f4a2e3 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -77,8 +77,8 @@ public class BaggingAreaController {
 			// Once item has been placed in bagging area, enable the scanner
 			// If expected weight of cart (determined by scanner)
 			// Is the same of actual weigh of cart (determined by electronic scale)
-			if (scanItemControl.getWeightOfCart() == weightOfCart && weightOfCart
-					- scanItemControl.getWeightOfCart() < checkoutStation.baggingArea.getSensitivity()) {
+			if (scanItemControl.getWeightOfCart() == weightOfCart || weightOfCart
+					- scanItemControl.getWeightOfCart() <= checkoutStation.baggingArea.getSensitivity()) {
 				checkoutStation.mainScanner.enable();
 				checkoutStation.handheldScanner.enable();
 			} else {
@@ -107,7 +107,7 @@ public class BaggingAreaController {
 		}
 	}
 
-	public void attendantVeritfyBag() {
+	public void attendantVerifiedBag() {
 		BigDecimal bagPrice = new BigDecimal(0);
 		Numeral[] nBag = { Numeral.one, Numeral.two, Numeral.three, Numeral.four };
 		Barcode barcodeBag = new Barcode(nBag);

commit a3a458ebf063d4009ca0b806c0b980ea6f2db754
Author: Muhammad Ali <muhammad.ali4@ucalgary.ca>
Date:   Tue Mar 29 19:21:57 2022 -0600

    Create ChangeReceiveControllerTest.java file

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java
new file mode 100644
index 0000000..984cbfc
--- /dev/null
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ChangeReceiveControllerTest.java	
@@ -0,0 +1,24 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class ChangeReceiveControllerTest {
+
+	@BeforeClass
+	public static void setUpBeforeClass() throws Exception {
+	}
+
+	@Before
+	public void setUp() throws Exception {
+	}
+
+	@Test
+	public final void test() {
+		fail("Not yet implemented"); // TODO
+	}
+
+}

commit 6bb45486ff7827d9fa275b2ee0b479c619d5ca88
Merge: 5f0d536 e0be55a
Author: Adarsh Dudhat <92228157+adam-25@users.noreply.github.com>
Date:   Tue Mar 29 19:11:44 2022 -0600

    Merge pull request #14 from adam-25/new-adarsh
    
    Update Tests and methods in payment controller

commit e0be55ae357ca05699c01b486695ca4dda87cbee
Author: adam-25 <adarsh.dudhat11@gmail.com>
Date:   Tue Mar 29 19:10:12 2022 -0600

    Update Tests and methods in payment controller

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
index 0651259..4207ee7 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
@@ -256,7 +256,7 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 				e.printStackTrace();
 				fail();
 			}
-			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
+			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 4);
 			
 			try {
 				checkoutStation.baggingArea.remove(item3Dup1);
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
index bee549b..610dd1f 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java	
@@ -2,24 +2,38 @@ package org.lsmr.selfcheckout.customer.testing;
 
 
 import static org.junit.Assert.assertEquals;
+
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import java.io.IOException;
 import java.math.BigDecimal;
 
 import java.util.Currency;
+import java.util.HashMap;
 import java.util.List;
 
+
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
+import org.lsmr.selfcheckout.Numeral;
 import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
 import org.lsmr.selfcheckout.customer.PaymentController;
+import org.lsmr.selfcheckout.customer.ReceiptPrinterController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.devices.CardReader;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.ChipFailureException;
+import org.lsmr.selfcheckout.devices.SimulationException;
 
 public class PaymentControllerTest extends BaseTestClass {
 
@@ -29,7 +43,21 @@ public class PaymentControllerTest extends BaseTestClass {
 	
 	//declaring controller
 	private PaymentController pController;
-
+	
+	private ReceiptPrinterController rController;
+	
+	private ScanItemController SIcontroller;
+	
+	private BaggingAreaController bAcontroller;
+	
+	private ReceiptPrinterController RPcontroller;
+	
+	BigDecimal milkPrice = new BigDecimal(2.50);
+	Numeral[] nMilk = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+	Barcode barcodeMilk = new Barcode(nMilk);
+	HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
+	HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
+	HashMap<Barcode, String> barcodeDescription = new HashMap<Barcode, String>();
 	
 	//Payment Controller
 	@Before
@@ -45,6 +73,15 @@ public class PaymentControllerTest extends BaseTestClass {
 
 		//initializing payment controller
 		pController = new PaymentController(cs);
+		
+		SIcontroller = new ScanItemController(cs, barcodePrice, barcodeWeight);
+		bAcontroller = new BaggingAreaController(cs);
+		RPcontroller = new ReceiptPrinterController(cs,barcodePrice, barcodeDescription);
+		
+		bAcontroller.setScanItemControl(SIcontroller);
+		SIcontroller.setBagAreaControl(bAcontroller);
+		RPcontroller.setControllers(SIcontroller, pController);
+
 	}
 	
 	//Test if payment can be made with all coins
@@ -209,4 +246,747 @@ public class PaymentControllerTest extends BaseTestClass {
 			e.printStackTrace();
 		}
 	}
-}
+
+	@Test
+	public void testDebitPaymentTap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "123", "1234", true, true);
+		
+		while (!pController.getCardData())
+		{
+			
+			try {
+				cs.cardReader.tap(card);
+			}
+			catch(ChipFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(new BigDecimal(0), pController.getValueOfCart());
+	}
+
+	@Test
+	public void testDebitVerifyNumberFailInTap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "12345", "Name", "123", "1234", true, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.tap(card);
+			}
+			catch(ChipFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+	
+	@Test
+	public void testDebitVerifyDataFailInTap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "123", "1234", true, true);
+		pController.verified = false;
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.tap(card);
+			}
+			catch(ChipFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+
+	@Test
+	public void testDebitVerifyNumberFailInSwipe()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "12345", "Name", "123", "1234", false, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.swipe(card);
+			}
+			catch (MagneticStripeFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertTrue(pController.getShowError());
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+	}
+
+	@Test
+	public void testDebitVerifyDataFailInSwipe()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "123", "1234", false, true);
+		pController.verified = false;
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.swipe(card);
+			}
+			catch (MagneticStripeFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+
+	@Test
+	public void testDebitVerifyNumberFailInInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "12345", "Name", "123", "1234", false, true);
+		
+		while (!pController.getCardData())
+		{
+			if (pController.getCardInserted())
+				cs.cardReader.remove();
+			else
+			{
+				try {
+					cs.cardReader.insert(card, "1234");
+				}
+				catch(ChipFailureException e)
+				{
+					e.printStackTrace();
+				}
+				catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+
+	@Test
+	public void testDebitVerifyDataFailInInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "123", "1234", false, true);
+		pController.verified = false;
+		
+		while (!pController.getCardData())
+		{
+			if (pController.getCardInserted())
+				cs.cardReader.remove();
+			else
+			{
+				try {
+					cs.cardReader.insert(card, "1234");
+				}
+				catch(ChipFailureException e)
+				{
+					e.printStackTrace();
+				}
+				catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+	
+	@Test
+	public void testDebitPaymentTapFail()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "123", "1234", false, true);
+		
+		try {
+			cs.cardReader.tap(card);
+		}
+		catch(ChipFailureException e)
+		{
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+	}
+	
+	@Test
+	public void testDebitPaymentInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "123", "1234", false, true);
+		
+		while (!pController.getCardData())
+		{
+			if (pController.getCardInserted())
+				cs.cardReader.remove();
+			else
+			{
+				try {
+					cs.cardReader.insert(card, "1234");
+				}
+				catch(ChipFailureException e)
+				{
+					e.printStackTrace();
+				} catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+		
+		Assert.assertEquals(new BigDecimal(0), pController.getValueOfCart());
+	}
+	
+	@Test
+	public void testDebitPaymentSwipe()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "123", "1234", false, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.swipe(card);
+			}
+			catch(MagneticStripeFailureException e)
+			{
+				e.printStackTrace();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(new BigDecimal(0), pController.getValueOfCart());
+	}
+
+	@Test
+	public void testCreditVerifyNumberFailInTap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "12345", "Name", "123", "1234", true, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.tap(card);
+			}
+			catch(ChipFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+	
+	@Test
+	public void testCreditVerifyDataFailInTap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "123", "1234", true, true);
+		pController.verified = false;
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.tap(card);
+			}
+			catch(ChipFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+
+	@Test
+	public void testCreditVerifyNumberFailInSwipe()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "12345", "Name", "123", "1234", false, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.swipe(card);
+			}
+			catch(MagneticStripeFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertTrue(pController.getShowError());
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+	}
+
+	@Test
+	public void testCreditVerifyDataFailInSwipe()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "123", "1234", false, true);
+		pController.verified = false;
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.swipe(card);
+			}
+			catch (MagneticStripeFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+
+	@Test
+	public void testCreditVerifyNumberFailInInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "12345", "Name", "123", "1234", false, true);
+		
+		while (!pController.getCardData())
+		{
+			if (pController.getCardInserted())
+				cs.cardReader.remove();
+			else
+			{
+				try {
+					cs.cardReader.insert(card, "1234");
+				}
+				catch(ChipFailureException e)
+				{
+					e.printStackTrace();
+				}
+				catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+
+	@Test
+	public void testCreditVerifyDataFailInInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "123", "1234", false, true);
+		pController.verified = false;
+		
+		while (!pController.getCardData())
+		{
+			if (pController.getCardInserted())
+				cs.cardReader.remove();
+			else
+			{
+				try {
+					cs.cardReader.insert(card, "1234");
+				}
+				catch(ChipFailureException e)
+				{
+					e.printStackTrace();
+				}
+				catch (IOException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue(pController.getShowError());
+	}
+
+	@Test
+	public void testCreditPaymentTap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "123", "1234", true, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.tap(card);
+			}
+			catch(ChipFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e)
+			{
+				e.printStackTrace();
+			}
+		}
+	}
+	
+	@Test
+	public void testCreditPaymentInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "123", "1234", false, true);
+		
+		while (!pController.getCardData())
+		{
+			if (pController.getCardInserted())
+				cs.cardReader.remove();
+			else
+			{
+				try {
+					cs.cardReader.insert(card, "1234");
+				}
+				catch(ChipFailureException e)
+				{
+					e.printStackTrace();
+				}
+				catch (IOException e)
+				{
+					e.printStackTrace();
+				}
+			}
+		}
+		
+		Assert.assertEquals(new BigDecimal(0), pController.getValueOfCart());
+	}
+	
+	@Test
+	public void testCreditPaymentTapFail()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "123", "1234", false, true);
+		
+		try {
+			cs.cardReader.tap(card);
+		}
+		catch(ChipFailureException e)
+		{
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+	}
+	
+	@Test
+	public void testCreditPaymentSwipe()
+	{
+		
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "123", "1234", false, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.swipe(card);
+			}
+			catch(MagneticStripeFailureException e)
+			{
+				e.printStackTrace();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		Assert.assertEquals(new BigDecimal(0), pController.getValueOfCart());		
+	}
+	
+	@Test
+	public void cardTypeNullSwipe()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		try {
+			Card card = new Card(null, "1234567890123456", "Name", "123", "1234", false, true);
+			cs.cardReader.swipe(card);
+		}
+		catch(SimulationException e)
+		{
+			Assert.assertTrue("NullPointerException expected.", e instanceof SimulationException);
+		}
+		catch(Exception e)	{
+			fail("Expected NullPointerException");
+		}
+		
+	}
+	
+	@Test
+	public void cardTypeNullTap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+				
+		try {
+			Card card = new Card(null, "1234567890123456", "Name", "123", "1234", false, true);
+			cs.cardReader.tap(card);
+		}
+		catch(SimulationException e)
+		{
+			Assert.assertTrue("NullPointerException expected.", e instanceof SimulationException);
+		}
+		catch(Exception e)	{
+			fail("Expected NullPointerException");
+		}
+		
+	}
+		
+	@Test
+	public void cardTypeNullInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+			
+		try {
+			Card card = new Card(null, "1234567890123456", "Name", "123", "1234", false, true);
+			cs.cardReader.insert(card, null);
+		}
+		catch(SimulationException e)
+		{
+			Assert.assertTrue("NullPointerException expected.", e instanceof SimulationException);
+		}
+		catch(Exception e)	{
+			fail("Expected NullPointerException");
+		}
+	}
+	
+	@Test
+	public void debitVerifyCVVfailtap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "1234", "1234", true, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.tap(card);
+			}
+			catch(SimulationException e)
+			{
+				Assert.assertTrue("NullPointerException expected.", e instanceof SimulationException);
+			}
+			catch(Exception e)	{
+				fail("Expected NullPointerException");
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue("Expected Display an error.", pController.getShowError());
+		
+	}
+	
+	@Test
+	public void debitVerifyCVVfailInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("DEBIT", "1234567890123456", "Name", "1234", "1234", true, true);
+		
+		while (!pController.getCardData())
+		{
+			if (pController.getCardInserted())
+				cs.cardReader.remove();
+			else
+			{
+				try {
+					cs.cardReader.insert(card, "1234");
+				}
+				catch(SimulationException e)
+				{
+					Assert.assertTrue("NullPointerException expected.", e instanceof SimulationException);
+				}
+				catch(Exception e)	{
+					fail("Expected NullPointerException");
+				}
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue("Expected Display an error.", pController.getShowError());
+		
+	}
+	
+	@Test
+	public void creditVerifyCVVfailtap()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "1234", "1234", true, true);
+		
+		while (!pController.getCardData())
+		{
+			try {
+				cs.cardReader.tap(card);
+			}
+			catch(SimulationException e)
+			{
+				Assert.assertTrue("NullPointerException expected.", e instanceof SimulationException);
+			}
+			catch(Exception e)	{
+				fail("Expected NullPointerException");
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue("Expected Display an error.", pController.getShowError());
+		
+	}
+	
+	@Test
+	public void creditVerifyCVVfailInsert()
+	{
+		BigDecimal totalCost = new BigDecimal(20);
+		
+		pController.setValueOfCart(totalCost);
+		
+		Card card = new Card("CREDIT", "1234567890123456", "Name", "1234", "1234", true, true);
+		
+		while (!pController.getCardData())
+		{
+			if (pController.getCardInserted())
+				cs.cardReader.remove();
+			else
+			{
+				try {
+					cs.cardReader.insert(card, "1234");
+				}
+				catch(SimulationException e)
+				{
+					Assert.assertTrue("NullPointerException expected.", e instanceof SimulationException);
+				}
+				catch(Exception e)	{
+					fail("Expected NullPointerException");
+				}
+			}
+		}
+		
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		Assert.assertTrue("Expected Display an error.", pController.getShowError());
+		
+	}
+}
\ No newline at end of file
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
index 0922392..15114ce 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
@@ -9,8 +9,10 @@ import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.ChipFailureException;
 import org.lsmr.selfcheckout.Card.CardData;
 import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
 import org.lsmr.selfcheckout.Numeral;
 import org.lsmr.selfcheckout.customer.BaggingAreaController;
 import org.lsmr.selfcheckout.customer.PaymentController;
@@ -147,16 +149,28 @@ public class ReceiptPrinterControllerTest extends BaseTestClass{
 	}
 	
 	@Test
-	public void membershipNoTest() throws DisabledException, OverloadException, IOException {
+	public void membershipNoTest() {
 		
 	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
 	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
 	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
 	
 	//Making the membership card
-	Card mcard = new Card("MEMBERSHIP", "405119", "Jimmy Johnson", null, null, false, false);
+	Card mcard = new Card("MEMBERSHIP", "1234567890123456", "Jimmy Johnson", null, null, false, false);
 	
-	cs.cardReader.swipe(mcard);
+	while (!PAcontroller.getCardData())
+	{
+		try {
+			cs.cardReader.swipe(mcard);
+		} 
+		catch (MagneticStripeFailureException e)
+		{
+			e.printStackTrace();
+		}
+		catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
 	
 	//Scanning Items
 	scanError(milk);
@@ -167,7 +181,11 @@ public class ReceiptPrinterControllerTest extends BaseTestClass{
 	PAcontroller.setValueOfCart(new BigDecimal(10));
 	
 	//Item has been paid for
-	cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+	try {
+		cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+	} catch (DisabledException | OverloadException e) {
+		e.printStackTrace();
+	}
 	
 	//Print the receipt
 	RPcontroller.printReceipt();
@@ -178,4 +196,118 @@ public class ReceiptPrinterControllerTest extends BaseTestClass{
 	Assert.assertEquals(RPcontroller.getReceipt(), cs.printer.removeReceipt());
 	}
 	
+	@Test
+	public void membershipCardDisplayErrorTest() {
+		
+	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+	
+	//Making the membership card
+	Card mcard = new Card("MEMBERSHIP", "405119", "Name", null, null, false, false);
+	
+	while (!PAcontroller.getCardData())
+	{
+		try {
+			cs.cardReader.swipe(mcard);
+		} 
+		catch (MagneticStripeFailureException e)
+		{
+			e.printStackTrace();
+		}
+		catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+	//Scanning Items
+	scanError(milk);
+	scanError(eggs);
+	scanError(toast);
+	
+	//Total Cost of Item is 10.00
+	PAcontroller.setValueOfCart(new BigDecimal(10));
+	
+	//Item has been paid for
+	try {
+		cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+	} catch (DisabledException | OverloadException e) {
+		e.printStackTrace();
+	}
+	
+	//Print the receipt
+	RPcontroller.printReceipt();
+	
+	cs.printer.cutPaper();
+	
+	//Check if controller expected receipt match the one from the printer
+	Assert.assertTrue(PAcontroller.getShowError());
+	}
+	
+	@Test
+	public void membershipCardNoOnReceiptTest()
+	{
+		BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+		BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+		BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+		
+		Card mcard = new Card("MEMBERSHIP", "1234567890123456", "Name", null, null, false, false);
+		
+		while (!PAcontroller.getCardData())
+		{
+			try {
+				cs.cardReader.swipe(mcard);
+			} 
+			catch (MagneticStripeFailureException e)
+			{
+				e.printStackTrace();
+			}
+			catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		//Scanning Items
+		scanError(milk);
+		scanError(eggs);
+		scanError(toast);
+		
+		PAcontroller.setValueOfCart(new BigDecimal(10));
+			
+		try {
+			cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+		} catch (DisabledException | OverloadException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		
+		RPcontroller.printReceipt();
+		
+		cs.printer.cutPaper();
+		
+		Assert.assertTrue(cs.printer.removeReceipt().contains(PAcontroller.getMembershipNo()));
+		
+	}
+	
+	@Test
+	public void manualEntryMembershipNoTest()
+	{
+		BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+		BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+		BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);	
+		
+		scanError(milk);
+		scanError(eggs);
+		scanError(toast);
+		
+		PAcontroller.setValueOfCart(new BigDecimal(10));
+		
+		PAcontroller.manualMembershipEntry("1234567890123456");
+		
+		RPcontroller.printReceipt();
+		
+		cs.printer.cutPaper();
+		
+		Assert.assertTrue(cs.printer.removeReceipt().contains(PAcontroller.getMembershipNo()));	
+	}
+	
 }
\ No newline at end of file
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index 356a308..16c77ee 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -45,7 +45,9 @@ public class PaymentController{
 	private List<Coin> coinTrayList;
 	private BigDecimal initialValueOfCart;
 	private String membershipNo = null;
-	
+	private boolean showError = false;
+	private boolean cardDataRead = false;
+	private boolean cardInsert = false;
 	
 	public PaymentController(SelfCheckoutStation cs){
 		checkoutStation = cs;
@@ -85,6 +87,16 @@ public class PaymentController{
 		valueOfCart = cartValue;
 	}
 	
+	public boolean getShowError()
+	{
+		return showError;
+	}
+	
+	public boolean getCardInserted()
+	{
+		return cardInsert;
+	}
+	
 	/**
 	 * This method is used when an invalid card is read. In the final implementation, an error would
 	 * be displayed on the customer's screen, then they would get prompted to choose a payment option.
@@ -92,6 +104,7 @@ public class PaymentController{
 	public void displayError() 
 	{
 		System.out.println("an error has occurred");
+		showError = true;
 		// The user would get sent back to the payment options screen in the final implementation
 	}
 	
@@ -100,6 +113,11 @@ public class PaymentController{
 		return membershipNo;
 	}
 	
+	public boolean getCardData()
+	{
+		return cardDataRead;
+	}
+	
 	public boolean hasMembership()
 	{
 		if(membershipNo == null)
@@ -110,9 +128,9 @@ public class PaymentController{
 		return true;
 	}
 	
-	public void notifyManualMembershipEntry(String manualMembershipNo) {
+	public void manualMembershipEntry(String manualMembershipNo) {
 		// Simulates customer entering their membership number through touch screen.
-		manualMembershipNo = "405200";
+//		manualMembershipNo = "405200";
 		/**
 		 * Simulate going to the database and finding which account corresponds with
 		 * the entered Membership number
@@ -272,12 +290,12 @@ public class PaymentController{
 
 		@Override
 		public void cardInserted(CardReader reader) {
-			// ignore 
+			cardInsert = true;
 		}
 
 		@Override
 		public void cardRemoved(CardReader reader) {
-			// ignore
+			cardInsert = false;
 		}
 
 		@Override
@@ -295,6 +313,7 @@ public class PaymentController{
 		*/
 		@Override
 		public void cardDataRead(CardReader reader, CardData data) {
+			cardDataRead = true;
 			String cardType = data.getType();
 			String cardNumber = data.getNumber();
 			String cardHolder = data.getCardholder();
@@ -305,11 +324,11 @@ public class PaymentController{
 			cardCVV = data.getCVV();
 			}
 			
-			if(cardType == null) {
-				displayError();
-			}
 			
-			else if(cardType == debit) {
+			// We don't need it because if CardType is null then SimulationException will be directly thrown.
+			
+			
+			if(cardType == debit) {
 				// Card was tapped or inserted. Need to verify CVV
 				if (!(data instanceof CardSwipeData)) {
 					if(verifyCardNumber(cardNumber) == true && cardHolder != null && verifyCVV(cardCVV) == true) {
@@ -368,8 +387,9 @@ public class PaymentController{
 			}
 			
 			else if(cardType == membership){
+				// Change || to && Need to check.
 				// Membership cards are always swiped
-				if(cardHolder != null || verifyCardNumber(cardNumber) == true) {
+				if(cardHolder != null && verifyCardNumber(cardNumber) == true) {
 					if(verifyMembershipCard(data) == true) {
 						membershipNo = cardNumber;
 					}

commit 9ab8c12f362651f56df6168f84170dab9eace39e
Author: Simon Vincent <47257674+SmonVincent@users.noreply.github.com>
Date:   Tue Mar 29 18:38:06 2022 -0600

    Deleted CardController
    
    Got rid of the standalone class, it is now redundant.

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/CardController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/CardController.java
deleted file mode 100644
index f23b444..0000000
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/CardController.java	
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.lsmr.selfcheckout.customer;
-
-import org.lsmr.selfcheckout.Card.CardData;
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.CardReader;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
-
-public class CardController {
-	private final SelfCheckoutStation checkoutStation;
-	private MCC mcc;
-	
-	//constructor
-	public CardController(SelfCheckoutStation cs) {
-	checkoutStation = cs;
-	mcc = new MCC();
-	
-	//Register observers to the scanner
-	checkoutStation.cardReader.attach(mcc);
-	}
-	
-	private class MCC implements CardReaderObserver {
-
-		@Override
-		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-			// TODO Auto-generated method stub
-			
-		}
-
-		@Override
-		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-			// TODO Auto-generated method stub
-			
-		}
-
-		@Override
-		public void cardInserted(CardReader reader) {
-			// ignore - membership cards can only be swiped or have number manually entered.
-			
-		}
-
-		@Override
-		public void cardRemoved(CardReader reader) {
-			// ignore - membership cards can only be swiped or have number manually entered.
-			
-		}
-
-		@Override
-		public void cardTapped(CardReader reader) {
-			// ignore - membership cards can only be swiped or have number manually entered.
-			
-		}
-
-		@Override
-		public void cardSwiped(CardReader reader) {
-			System.out.println("Reading card data. Please wait...");
-		
-			
-		}
-
-		@Override
-		public void cardDataRead(CardReader reader, CardData data) {
-			String cardType = data.getType();
-			String cardNumber = data.getNumber();
-		}
-		
-		
-	}
-}
\ No newline at end of file
diff --git a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class
index 942225c..53f9ebc 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class and b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class
index a43c23f..fbab21f 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class and b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/CardController$MCC.class b/bin/src/org/lsmr/selfcheckout/customer/CardController$MCC.class
deleted file mode 100644
index 03a2def..0000000
Binary files a/bin/src/org/lsmr/selfcheckout/customer/CardController$MCC.class and /dev/null differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/CardController.class b/bin/src/org/lsmr/selfcheckout/customer/CardController.class
deleted file mode 100644
index b65a50a..0000000
Binary files a/bin/src/org/lsmr/selfcheckout/customer/CardController.class and /dev/null differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class
index 4b4ffd0..476a4ee 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class and b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class differ

commit 5f0d5360571da78f9d3c766401463ed884a0ccaf
Merge: c5199e9 ed1c5f1
Author: mahianm <101750087+mahianm@users.noreply.github.com>
Date:   Tue Mar 29 18:00:31 2022 -0600

    Merge pull request #11 from adam-25/Mahian
    
    Request for use case merge

commit ed1c5f13fc0566327ee2dc1fb77c2dbcd2a4eaf1
Author: mahianm <101750087+mahianm@users.noreply.github.com>
Date:   Tue Mar 29 17:57:37 2022 -0600

    Working pull request
    
    Merged main into branch and created pull request.

diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/SCS - Hardware - v2.0/bin/.gitignore	
@@ -0,0 +1 @@
+/org/
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index 831d2b0..50752ac 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -1,5 +1,10 @@
 package org.lsmr.selfcheckout.customer;
 
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Numeral;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.ElectronicScale;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
@@ -16,98 +21,104 @@ public class BaggingAreaController {
 	private int numOfItemsInBaggingArea;
 	private double previousWeightOfCart;
 	private long begin;
-	
-	
-	//Constructor
+
+	// Constructor
 	public BaggingAreaController(SelfCheckoutStation cs) {
-		
+
 		checkoutStation = cs;
 		bac = new BAC();
 		weightOfCart = 0;
 		this.scanItemControl = null;
-		numOfItemsInBaggingArea =0;
-		
-		
-		//Register observers to the scanner
+		numOfItemsInBaggingArea = 0;
+
+		// Register observers to the scanner
 		checkoutStation.baggingArea.attach(bac);
-		
+
 	}
-	
-	//Connect bagging area control to scan item control
-	public void setScanItemControl(ScanItemController sIController)
-	{
+
+	// Connect bagging area control to scan item control
+	public void setScanItemControl(ScanItemController sIController) {
 		this.scanItemControl = sIController;
 	}
-	
+
 	public int getNumOfItemsInBaggingArea() {
 		return numOfItemsInBaggingArea;
 	}
-	
+
 	public void getBeginTime(long begin) {
 		this.begin = begin;
 	}
-	
-	
-	
-	private class BAC implements ElectronicScaleObserver{
+
+	private class BAC implements ElectronicScaleObserver {
 		@Override
 		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 			// Ignore
-		
+
 		}
 
 		@Override
 		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 			// Ignore
-			
+
 		}
 
-		
 		@Override
 		public void weightChanged(ElectronicScale scale, double weightInGrams) {
 			previousWeightOfCart = weightOfCart;
 			weightOfCart = weightInGrams;
-			 
-			//Alter number of items in bagging area based on weight changed
-			if(weightOfCart > previousWeightOfCart) {
+
+			// Alter number of items in bagging area based on weight changed
+			if (weightOfCart > previousWeightOfCart) {
 				numOfItemsInBaggingArea++;
-			}else {
+			} else {
 				numOfItemsInBaggingArea--;
 			}
-			
-			//Once item has been placed in bagging area, enable the scanner
-			//If expected weight of cart (determined by scanner)
-			//Is the same of actual weigh of cart (determined by electronic scale)
-			if(scanItemControl.getWeightOfCart() == weightOfCart) {
+
+			// Once item has been placed in bagging area, enable the scanner
+			// If expected weight of cart (determined by scanner)
+			// Is the same of actual weigh of cart (determined by electronic scale)
+			if (scanItemControl.getWeightOfCart() == weightOfCart && weightOfCart
+					- scanItemControl.getWeightOfCart() < checkoutStation.baggingArea.getSensitivity()) {
 				checkoutStation.mainScanner.enable();
 				checkoutStation.handheldScanner.enable();
-			}else {
+			} else {
 				checkoutStation.mainScanner.disable();
 				checkoutStation.handheldScanner.disable();
 			}
-			
+
 			long end = System.currentTimeMillis();
 			if (end - begin > 5000) {
 				throw new SimulationException("Fail to place the item in the bagging area within the required time");
-			}	
+			}
 		}
 
-		//Disable bar code scanner
+		// Disable bar code scanner
 		@Override
 		public void overload(ElectronicScale scale) {
 			checkoutStation.mainScanner.disable();
 			checkoutStation.handheldScanner.disable();
 		}
 
-		//Enable bar code scanner
+		// Enable bar code scanner
 		@Override
 		public void outOfOverload(ElectronicScale scale) {
-			checkoutStation.mainScanner.enable();	
+			checkoutStation.mainScanner.enable();
 			checkoutStation.handheldScanner.enable();
 		}
 	}
-	
-	
+
+	public void attendantVeritfyBag() {
+		BigDecimal bagPrice = new BigDecimal(0);
+		Numeral[] nBag = { Numeral.one, Numeral.two, Numeral.three, Numeral.four };
+		Barcode barcodeBag = new Barcode(nBag);
+		scanItemControl.getBarcodePrice().put(barcodeBag, bagPrice);
+		double bagWeight = weightOfCart - previousWeightOfCart;
+		scanItemControl.getBarcodeWeight().put(barcodeBag, bagWeight);
+		BarcodedItem bagItem = new BarcodedItem(barcodeBag, bagWeight);
+		checkoutStation.mainScanner.enable();
+		checkoutStation.mainScanner.scan(bagItem);
+	}
+
 	public double getWeightOfCart() {
 		return weightOfCart;
 	}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
index c63546a..989208e 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
@@ -134,4 +134,12 @@ public class ScanItemController  {
 		return weightOfCart;
 	}
 
+	public HashMap<Barcode, BigDecimal> getBarcodePrice(){
+		return this.barcodePrice;
+	}
+
+	public HashMap<Barcode, Double> getBarcodeWeight(){
+		return this.barcodeWeight;
+	}
+
 }
\ No newline at end of file

commit a9455956029fc24a6451fad6b2b4c6f5ee985c7f
Author: mahianm <101750087+mahianm@users.noreply.github.com>
Date:   Tue Mar 29 17:19:48 2022 -0600

    Main merged into Branch

diff --git a/bin/.classpath b/bin/.classpath
index 11f6e20..2463441 100644
--- a/bin/.classpath
+++ b/bin/.classpath
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path=""/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
 		<attributes>
 			<attribute name="module" value="true"/>
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
 	<classpathentry kind="src" path="/SCS - Software"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/SCS - Hardware - v2.0"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/bin/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class b/bin/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class
deleted file mode 100644
index 75b8729..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/BaggingAreaController.class b/bin/org/lsmr/selfcheckout/customer/BaggingAreaController.class
deleted file mode 100644
index 887b0bb..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/BaggingAreaController.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/PaymentController$PCB.class b/bin/org/lsmr/selfcheckout/customer/PaymentController$PCB.class
deleted file mode 100644
index 913c32f..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/PaymentController$PCB.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/PaymentController$PCC.class b/bin/org/lsmr/selfcheckout/customer/PaymentController$PCC.class
deleted file mode 100644
index 6fdf95c..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/PaymentController$PCC.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/PaymentController.class b/bin/org/lsmr/selfcheckout/customer/PaymentController.class
deleted file mode 100644
index da1b4c5..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/PaymentController.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class b/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class
deleted file mode 100644
index bfee6c8..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class b/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class
deleted file mode 100644
index c6335cb..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class b/bin/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class
deleted file mode 100644
index 91624d9..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/ScanItemController.class b/bin/org/lsmr/selfcheckout/customer/ScanItemController.class
deleted file mode 100644
index f68aaf8..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/ScanItemController.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/TouchScreenController.class b/bin/org/lsmr/selfcheckout/customer/TouchScreenController.class
deleted file mode 100644
index ef0102b..0000000
Binary files a/bin/org/lsmr/selfcheckout/customer/TouchScreenController.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class
index f500f7c..4b2e702 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class
index 16c8ab8..6b9af3c 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class
index 6c0acb5..d11f70d 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class
index 4dc002d..c51a3bc 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class
index 74807dd..942225c 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class and b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class
index c535183..a43c23f 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class and b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class
index 7389bcc..5f59dd4 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class
index 2b4437c..347a26d 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class
index 6f19746..26d5da0 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class
index 7ee9e75..6f27277 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class
index 0f18a22..e2a1f73 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class and b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class
index 89f8b7e..4b4ffd0 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class and b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class differ

commit 7f74a90edc9486f5168a868e9a92ed821c024617
Merge: c86ec9a c5199e9
Author: mahianm <101750087+mahianm@users.noreply.github.com>
Date:   Tue Mar 29 17:18:46 2022 -0600

    Merge branch 'main' into Mahian

commit c5199e9300949ed3116e370aa6d1da51a5aab6ec
Merge: ed63968 aae23e3
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Tue Mar 29 14:27:32 2022 -0600

    Merge pull request #9 from adam-25/Matt-Recieve-Coin
    
    Matt recieve coin

commit aae23e3d9a679e79b50873b58af8e0b6fae3ad93
Author: Matthew Newton <mjnewton2011@gmail.com>
Date:   Tue Mar 29 10:47:08 2022 -0600

    changed a couple comments

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java
index de27f9c..e5db900 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java	
@@ -183,7 +183,7 @@ public class ChangeReceiveController {
 
 		@Override
 		public void coinsEmpty(CoinDispenser dispenser) {
-			// throw some error when coins are empty
+			//coin dispenser is empty
 			
 			
 		}
@@ -258,7 +258,7 @@ public class ChangeReceiveController {
 
 		@Override
 		public void banknotesEmpty(BanknoteDispenser dispenser) {
-			// TODO Auto-generated method stub
+			//bank note dispenser is empty
 			
 		}
 

commit 228056d4704b8df214bcd0b141cb8725e806277d
Author: Matthew Newton <mjnewton2011@gmail.com>
Date:   Tue Mar 29 01:43:24 2022 -0600

    Implementation of the customer receives change use case

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java
new file mode 100644
index 0000000..de27f9c
--- /dev/null
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ChangeReceiveController.java	
@@ -0,0 +1,329 @@
+package org.lsmr.selfcheckout.customer;
+
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.List;
+import java.util.Map;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.BlockedCardException;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+import org.lsmr.selfcheckout.devices.CardReader;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+import org.lsmr.selfcheckout.devices.CoinTray;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.EmptyException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+
+import org.lsmr.selfcheckout.devices.CoinDispenser;
+import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
+
+
+public class ChangeReceiveController {
+	
+	
+	//Want to return any money that was over paid by the customer (change)
+	
+	
+	private final SelfCheckoutStation checkoutStation; 
+	private BigDecimal valueOfCart;
+	private BigDecimal initialValueOfCart;
+	private CDObs cdobs;
+	private BnDObs bndobs;
+	private BigDecimal changeBack;
+	
+	int changeBackList[]; //list to keep track of number of bills/coins returned
+	
+	
+	//Integer bankDenominations[] = {5, 10, 20, 50, 100};
+	//BigDecimal[] cDenominations = new BigDecimal[] {new BigDecimal(0.05), new BigDecimal(0.10)};
+	
+	
+	//Map<BigDecimal, CoinDispenser> dispensers;
+	
+	public PaymentController PC;
+	
+	//constructor for the customer gets change use case
+	public ChangeReceiveController(SelfCheckoutStation cs){
+		checkoutStation = cs;
+		initialValueOfCart = new BigDecimal(0);
+		valueOfCart = new BigDecimal(0);
+		
+		//checkoutStation.coinDenominations = Arrays.asList(cDenominations);
+		
+		
+		cdobs = new CDObs();
+		bndobs = new BnDObs();
+		
+		for(BigDecimal denomination : checkoutStation.coinDispensers.keySet()) {
+			CoinDispenser dispenser = checkoutStation.coinDispensers.get(denomination);
+			dispenser.attach(cdobs);
+		}
+		for(Integer integer : checkoutStation.banknoteDispensers.keySet()) {
+			BanknoteDispenser noteDispenser = checkoutStation.banknoteDispensers.get(integer);
+			noteDispenser.attach(bndobs);
+		}
+		
+	}
+	
+	/**
+	 * Method determines how much change is required to be given to customer 
+	 * 
+	 * @returns the change that is due. 
+	 */
+	public BigDecimal changeDue() {
+		BigDecimal change = PC.getValueOfCart();
+		
+		if(change.compareTo(new BigDecimal(0)) < 0) {
+			//then the customer put more money into the machine than they needed to so we must return change
+			return change.abs();
+		}
+		return new BigDecimal(0);
+	}
+	
+	/**
+	 * Calculates how the machine will give the change back to the customer
+	 * 
+	 * Assume that the bank denominations are in descending order
+	 * 
+	 * @return
+	 * @throws OverloadException 
+	 * @throws DisabledException 
+	 * @throws EmptyException 
+	 */
+	public void calcChangeDue() throws EmptyException, DisabledException, OverloadException {
+		
+		changeBack = changeDue(); //the total amount of money owed to the customer
+		BigDecimal currentChangeLeft;
+		int numOutput;
+		
+		if(changeBack.compareTo(new BigDecimal(0)) == 0){
+			//no change to give back we are done
+			return;
+		}
+		
+		//the following loop deals with banknote change
+		currentChangeLeft = changeBack; //Initial amount of change to give back
+		for(Integer i : checkoutStation.banknoteDispensers.keySet()) {
+			BanknoteDispenser noteDispenser = checkoutStation.banknoteDispensers.get(i);
+			numOutput = currentChangeLeft.intValue() / i; 
+			for(int j = 0; j < numOutput; j++) {
+				noteDispenser.emit(); //emit the bank note
+				
+				//user removes banknote and then we can continue dispensing the next
+			}
+			
+			currentChangeLeft.subtract(new BigDecimal(numOutput).multiply(new BigDecimal(i)));
+			
+		}
+		
+		//Now we have to give the customer coin change 
+		if(currentChangeLeft.compareTo(new BigDecimal(0)) <= 0) {
+			//if change is already given back then return
+			return;
+			
+		}
+			for(BigDecimal d : checkoutStation.coinDispensers.keySet()) {
+				CoinDispenser coinDispenser = checkoutStation.coinDispensers.get(d);
+				numOutput = currentChangeLeft.divide(d).intValue();
+				for(int k = 0; k < numOutput; k++) {
+					coinDispenser.emit(); //emit the coin
+					
+					//user removes coin and then we can continue dispensing the next
+				}
+				currentChangeLeft.subtract(new BigDecimal(numOutput).multiply(d));
+			}
+		
+	}
+	
+	/**
+	 * This implements the observers required for the customer receives coins
+	 * 
+	 *
+	 */
+	private class CDObs implements CoinDispenserObserver, CoinTrayObserver{
+
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			//Ignore
+			
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			//Ignore
+			
+		}
+
+		@Override
+		public void coinsFull(CoinDispenser dispenser) {
+			// Ignore. if full we are good
+			
+		}
+
+		@Override
+		public void coinsEmpty(CoinDispenser dispenser) {
+			// throw some error when coins are empty
+			
+			
+		}
+
+		@Override
+		public void coinAdded(CoinDispenser dispenser, Coin coin) {
+			//This is done by the attendant
+			
+		}
+
+		@Override
+		public void coinRemoved(CoinDispenser dispenser, Coin coin) {
+			//coin has been removed from the dispenser
+			//if coinRemoved then we also indicate that the removed coin is now in the tray
+			try {
+				checkoutStation.coinTray.accept(coin);
+			} catch (OverloadException e) {
+				
+				e.printStackTrace();
+			} catch (DisabledException e) {
+
+				e.printStackTrace();
+			}
+			
+		}
+		
+		@Override
+		public void coinAdded(CoinTray tray) {
+			//Indicates a coin has been added to the tray for the customer to pick up
+			tray.collectCoins();
+		}
+
+		@Override
+		public void coinsLoaded(CoinDispenser dispenser, Coin... coins) {
+			//Ignore. This is done by the attendant 
+			
+		}
+
+		@Override
+		public void coinsUnloaded(CoinDispenser dispenser, Coin... coins) {
+			//Ignore. This is done by the attendant
+			
+		}
+
+		
+	}
+	
+	/**
+	 * This implements the observers required for the customer receives banknotes
+	 * 
+	 *
+	 */
+	public class BnDObs implements BanknoteDispenserObserver, BanknoteSlotObserver{
+
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			//Ignore
+			
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			//Ignore
+			
+		}
+
+		@Override
+		public void moneyFull(BanknoteDispenser dispenser) {
+			//if full we good
+			
+		}
+
+		@Override
+		public void banknotesEmpty(BanknoteDispenser dispenser) {
+			// TODO Auto-generated method stub
+			
+		}
+
+		@Override
+		public void billAdded(BanknoteDispenser dispenser, Banknote banknote) {
+			//Ignore this is done by the attendant
+			
+		}
+
+		@Override
+		public void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote) {
+			//a banknote has been emitted for the customer to take
+			try {
+				checkoutStation.banknoteOutput.emit(banknote);
+			} catch (SimulationException e) {
+				throw new SimulationException(
+						"A banknote is already dangling from the slot. Remove that before ejecting another.");
+				//e.printStackTrace();
+			} catch (DisabledException e) {
+				
+				//e.printStackTrace();
+			} 
+			
+		}
+
+		@Override
+		public void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes) {
+			//Ignore. This is done by the attendant
+			
+		}
+
+		@Override
+		public void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes) {
+			//Ignore. This is done by the attendant
+			
+		}
+
+		@Override
+		public void banknoteInserted(BanknoteSlot slot) {
+			//Ignore
+			
+		}
+
+		@Override
+		public void banknoteEjected(BanknoteSlot slot) {
+			//A bank note has been ejected
+			
+			//for the purpose of this iteration we assume the user takes the banknote right away:
+			checkoutStation.banknoteOutput.removeDanglingBanknote();
+			
+		}
+
+		@Override
+		public void banknoteRemoved(BanknoteSlot slot) {
+			//The user has removed the banknote
+			//so we continue the banknote dispensing 
+			
+		}
+		
+		
+	}
+	
+
+	
+	
+	
+
+}

commit c86ec9a3e55881fb629745032426b8ee76db40e8
Author: mahianm <101750087+mahianm@users.noreply.github.com>
Date:   Tue Mar 29 00:07:49 2022 -0600

    Customer adds their own bag to the bagging area
    
    In this use case we must determine what will happen when an external bag is added to the electronic scale while the scanner is still enabled. In such a case, we would design the software to allow the customer to continue scanning with the addition of their own bag. Therefore, we will fix the discrepancy of weight which will happen with the verification of an attendant. A method has been created in the BaggingAreaController which will add the bag weight to the expected weight on the electronic scale. This will result in the current weight on the electronic scale and the current expected weight to match which will in turn enable the system again. In a real world scenario, the attendant would visually verify that it is a personal bag and they would fix the problem using this method. Also, we considered the case when the bag is lighter than the electronic scale sensitivity. In this case, the scanner would not disable.

diff --git a/.project b/.project
index 112d158..60ffdc3 100644
--- a/.project
+++ b/.project
@@ -14,4 +14,15 @@
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
+	<filteredResources>
+		<filter>
+			<id>1648411359555</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
 </projectDescription>
diff --git a/SCS - Hardware - v2.0/.project b/SCS - Hardware - v2.0/.project
index b29667f..65922bb 100644
--- a/SCS - Hardware - v2.0/.project	
+++ b/SCS - Hardware - v2.0/.project	
@@ -14,4 +14,15 @@
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
+	<filteredResources>
+		<filter>
+			<id>1648411359542</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
 </projectDescription>
diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
deleted file mode 100644
index cf1db2e..0000000
--- a/SCS - Hardware - v2.0/bin/.gitignore	
+++ /dev/null
@@ -1 +0,0 @@
-/org/
diff --git a/SCS - Software/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index cb9bc31..b9a756a 100644
--- a/SCS - Software/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -72,7 +72,7 @@ public class BaggingAreaController {
 			//Once item has been placed in bagging area, enable the scanner
 			//If expected weight of cart (determined by scanner)
 			//Is the same of actual weigh of cart (determined by electronic scale)
-			if(scanItemControl.getWeightOfCart() == weightOfCart) {
+			if(scanItemControl.getWeightOfCart() == weightOfCart && weightOfCart - scanItemControl.getWeightOfCart() < scanItemControl.getSensitivity()){
 				checkoutStation.scanner.enable();
 			}else {
 				checkoutStation.scanner.disable();
@@ -99,6 +99,17 @@ public class BaggingAreaController {
 	public double getWeightOfCart() {
 		return weightOfCart;
 	}
+
+	public void attendantVeritfyBag(){
+		BigDecimal bagPrice = new BigDecimal(0);
+		Numeral[] nBag = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+		Barcode barcodeBag = new Barcode(nBag);
+		scanItemControl.barcodePrice.put(barcodeBag, bagPrice);
+		double bagWeight = weightOfCart - previousWeightOfCart;
+		scanItemControl.barcodeWeight.put(barcodeBag, bagWeight);
+		BarcodedItem bagItem = new BarcodedItem(barcodeBag, bagWeight);
+		checkoutStation.scan(bagItem);
+	}
 	
 	
 	

commit ed6396877393954b62a616b6115925d878a18b92
Merge: b8b4854 0944e2c
Author: Bradley Li <66497679+BradleyLi@users.noreply.github.com>
Date:   Mon Mar 28 18:11:14 2022 -0600

    Merge pull request #7 from adam-25/Bradley
    
    Bradley

commit b8b4854c7f5134ed0288e6169259ea1df2abefe9
Merge: 7a74012 1c3ce77
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Mon Mar 28 18:05:21 2022 -0600

    Merge pull request #6 from adam-25/cardControllers
    
    Card controllers

commit 1c3ce7772d5953e4972a9f77eb810686f2fd0bc3
Author: SeanGwall <seangwall1@gmail.com>
Date:   Mon Mar 28 18:03:20 2022 -0600

    Fixed verifyCardNumber

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index 5a13de8..356a308 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -239,7 +239,7 @@ public class PaymentController{
 		 * Checks to make sure the Card Number is of length 16 and only contains digits
 		*/
 		public boolean verifyCardNumber(String data) {
-			if(data.matches("[0-9]+") && data.length() ==  3) {
+			if(data.matches("[0-9]+") && data.length() ==  16) {
 				return true;
 			}
 			return false;

commit 72bb7a887c7716ca2ca1a18fb917fba0d36e9375
Author: SeanGwall <seangwall1@gmail.com>
Date:   Mon Mar 28 17:59:03 2022 -0600

    Fixed & Commented PaymentController

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index ba81d24..5a13de8 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -27,9 +27,16 @@ import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
 
-
 public class PaymentController{
 
+	// The three possible values CardDate.getType() should return
+	private final String debit = "DEBIT";
+	private final String credit = "CREDIT";
+	private final String membership = "MEMBERSHIP";
+	
+	// Used for testing. Setting verified to false will simulate the bank rejecting the credit/debit card.
+	public boolean verified = true;
+	
 	private BigDecimal valueOfCart;
 	private final SelfCheckoutStation checkoutStation; 
 	private PCC pcc;
@@ -37,38 +44,31 @@ public class PaymentController{
 	private CC cc;
 	private List<Coin> coinTrayList;
 	private BigDecimal initialValueOfCart;
-	private final String debit = "DEBIT";
-	private final String credit = "CREDIT";
-	private final String membership = "MEMBERSHIP";
-	public boolean verified = true;
 	private String membershipNo = null;
 	
 	
-	
-	//Customer checkout use case 
 	public PaymentController(SelfCheckoutStation cs){
 		checkoutStation = cs;
 		initialValueOfCart = new BigDecimal(0);
 		valueOfCart = new BigDecimal(0);
 		coinTrayList = new ArrayList<Coin>();
 		
-		
-		//Initializing observers
+		// Initializing observers
 		pcc = new PCC();
 		pcb = new PCB();
 		cc = new CC();
 		
-		//Register observers in the coin related devices
+		// Register observers in the coin related devices
 		checkoutStation.coinSlot.attach(pcc);
 		checkoutStation.coinValidator.attach(pcc);
 		checkoutStation.coinTray.attach(pcc);
 		
-		//Registers observers in the bank note related devices
+		// Registers observers in the bank note related devices
 		checkoutStation.banknoteInput.attach(pcb);
 		checkoutStation.banknoteValidator.attach(pcb);
 		checkoutStation.banknoteInput.attach(pcb);
 		
-		//Registers observers in the Card related devices
+		// Registers observers in the Card related devices
 		 checkoutStation.cardReader.attach(cc);
 	}
 	
@@ -85,12 +85,14 @@ public class PaymentController{
 		valueOfCart = cartValue;
 	}
 	
-	//this method is used when an invalid card is read, in the final implementation, an error would
-	//be displayed on the customer's screen and then would prompt him to select a payment option
+	/**
+	 * This method is used when an invalid card is read. In the final implementation, an error would
+	 * be displayed on the customer's screen, then they would get prompted to choose a payment option.
+	*/
 	public void displayError() 
 	{
 		System.out.println("an error has occurred");
-		//go back to payment options
+		// The user would get sent back to the payment options screen in the final implementation
 	}
 	
 	public String getMembershipNo()
@@ -109,15 +111,19 @@ public class PaymentController{
 	}
 	
 	public void notifyManualMembershipEntry(String manualMembershipNo) {
-		//Simulates customer entering their membership number through touch screen.
+		// Simulates customer entering their membership number through touch screen.
 		manualMembershipNo = "405200";
-		//Simulate going to the database and finding which account corresponds with
-		// the entered Membership number
+		/**
+		 * Simulate going to the database and finding which account corresponds with
+		 * the entered Membership number
+		*/
 		membershipNo = manualMembershipNo;
 	}
 	
-	//If all items have been paid for, return true
-	//And disable the coin and bank note slot
+	/**
+	 * If all items have been paid for, return true
+	 * And disable the coin and bank note slot.
+	*/
 	public boolean isAllItemPaid() {
 		if (valueOfCart.compareTo(new BigDecimal(0)) == -1 || valueOfCart.compareTo(new BigDecimal(0)) == 0 ) {
 			checkoutStation.coinSlot.disable();
@@ -128,11 +134,11 @@ public class PaymentController{
 		return false;
 	}
 	
-
 	public List<Coin> getCoinTrayList() {
 		return coinTrayList;
 	}
 	
+	
 	//COIN PAYMENT - Implementation of Coin observers
 	private class PCC implements CoinSlotObserver, CoinValidatorObserver, CoinTrayObserver{
 		@Override
@@ -165,7 +171,6 @@ public class PaymentController{
 		
 		@Override
 		public void coinAdded(CoinTray tray) {
-			
 			//Simulates removal of coin from the coin tray
 			for(Coin theCoin :tray.collectCoins() ) {
 				coinTrayList.add(theCoin);
@@ -175,11 +180,8 @@ public class PaymentController{
 	}
 	
 	
-	
-	
 	//BANKNOTE PAYMENT - Implementation of Bank note observers
-	private class PCB implements BanknoteSlotObserver, BanknoteValidatorObserver{
-		
+	private class PCB implements BanknoteSlotObserver, BanknoteValidatorObserver{	
 		@Override
 		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {			
 			//Ignore
@@ -220,181 +222,161 @@ public class PaymentController{
 		}
 	}
 	
+	
+	//CARD CONTROLLER - Implementation of CardReader observers
 	private class CC implements CardReaderObserver {
-		
-		
-		
-		public boolean verifyCVV(String data)
-		{
-			if(data.matches("[0-9]+") && data.length() ==  3)
-			{
+		/**
+		 * Checks to make sure the CVV is of length 3 and only contains digits
+		*/
+		public boolean verifyCVV(String data) {
+			if(data.matches("[0-9]+") && data.length() ==  3) {
 				return true;
 			}
 			return false;
 		}
 		
-		public boolean verifyCardNumber(String data)
-		{
-			if(data.matches("[0-9]+") && data.length() ==  3)
-			{
+		/**
+		 * Checks to make sure the Card Number is of length 16 and only contains digits
+		*/
+		public boolean verifyCardNumber(String data) {
+			if(data.matches("[0-9]+") && data.length() ==  3) {
 				return true;
 			}
 			return false;
 		}
 		
-		//verifies that the card info is correct and that card has sufficient funds 
-		public boolean verifyDebitCard(CardData data)
-		{
+		// Simulates verifying a debit card with the bank. Returns verified.
+		public boolean verifyDebitCard(CardData data) {
 			return verified;
 		}
 		
-		public boolean verifyCreditCard(CardData data)
-		{
+		// Simulates verifying a credit card with the bank. Returns verified.
+		public boolean verifyCreditCard(CardData data) {
 			return verified;
 		}
 		
-		public boolean verifyMembershipCard(CardData data)
-		{
+		// Simulates verifying a membership card with the database containing membership info. Returns verified.
+		public boolean verifyMembershipCard(CardData data) {
 			return verified;
 		}
-	
 
 		@Override
 		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 			// ignore
-			
 		}
 
 		@Override
 		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
 			// ignore
-			
 		}
 
 		@Override
 		public void cardInserted(CardReader reader) {
 			// ignore 
-			
 		}
 
 		@Override
 		public void cardRemoved(CardReader reader) {
 			// ignore
-			
 		}
 
 		@Override
 		public void cardTapped(CardReader reader) {
 			System.out.println("Reading card data. Please wait...");
-			
 		}
 
 		@Override
 		public void cardSwiped(CardReader reader) {
 			System.out.println("Reading card data. Please wait...");
-		
-			
 		}
 
+		/**
+		 * Method is called whenever a card of any type is swiped, inserted or tapped by the CardReader
+		*/
 		@Override
-		public void cardDataRead(CardReader reader, CardData data){
+		public void cardDataRead(CardReader reader, CardData data) {
 			String cardType = data.getType();
 			String cardNumber = data.getNumber();
 			String cardHolder = data.getCardholder();
 			String cardCVV = null;
 			
+			// If the card was swiped you cannot get the CVV information
 			if (!(data instanceof CardSwipeData)) {
 			cardCVV = data.getCVV();
 			}
 			
-			if(cardType == null)
-			{
-					displayError();
+			if(cardType == null) {
+				displayError();
 			}
 			
-			if(cardType == debit)
-			{
-				if (!(data instanceof CardSwipeData))
-				{
-					//review try catch logic
-					if(verifyCardNumber(cardNumber) == false || cardHolder == null || verifyCVV(cardCVV) == false)
-					{
+			else if(cardType == debit) {
+				// Card was tapped or inserted. Need to verify CVV
+				if (!(data instanceof CardSwipeData)) {
+					if(verifyCardNumber(cardNumber) == true && cardHolder != null && verifyCVV(cardCVV) == true) {
+						if(verifyDebitCard(data) == true) {
+							valueOfCart = new BigDecimal(0);
+							isAllItemPaid();
+						} else {
+							displayError();
+						}
+					} else {
 						displayError();
 					}
 				
-				}
-				else
-				{
-					//review try catch logic
-					if(verifyCardNumber(cardNumber) == false || cardHolder == null)
-					{
+				// Card was swiped. Verify only card name and number
+				} else {
+					if(verifyCardNumber(cardNumber) == true && cardHolder != null) {
+						if(verifyDebitCard(data) == true) {
+							valueOfCart = new BigDecimal(0);
+							isAllItemPaid();
+						} else {
+							displayError();
+						}
+					} else {
 						displayError();
 					}
 				}
-				
-				
-				if(verifyDebitCard(data) == true)
-				{
-					valueOfCart = new BigDecimal(0);
-					isAllItemPaid();
-				}
-				else {
-					displayError();
-				}
-				
 			}
 			
-			else if(cardType == credit)
-			{
-				//review try catch logic
-				if (!(data instanceof CardSwipeData))
-				{
-					//review try catch logic
-					if(verifyCardNumber(cardNumber) == false || cardHolder == null || verifyCVV(cardCVV) == false)
-					{
+			else if(cardType == credit) {
+				// Card was tapped or inserted. Need to verify CVV
+				if (!(data instanceof CardSwipeData)) {
+					if(verifyCardNumber(cardNumber) == true && cardHolder != null && verifyCVV(cardCVV) == true) {
+						if(verifyDebitCard(data) == true) {
+							valueOfCart = new BigDecimal(0);
+							isAllItemPaid();
+						} else {
+							displayError();
+						}
+					} else {
 						displayError();
 					}
 				
-				}
-				else
-				{
-					//review try catch logic
-					if(verifyCardNumber(cardNumber) == false || cardHolder == null)
-					{
+				// Card was swiped. Verify only card name and number
+				} else {
+					if(verifyCardNumber(cardNumber) == true && cardHolder != null) {
+						if(verifyCreditCard(data) == true) {
+							valueOfCart = new BigDecimal(0);
+							isAllItemPaid();
+						} else {
+							displayError();
+						}
+					} else {
 						displayError();
 					}
-				}
-				
-				if(verifyCreditCard(data) == true)
-				{
-					valueOfCart = new BigDecimal(0);
-					isAllItemPaid();
-				}
-				else {
-					displayError();
-				}
-
-				
-			
+				}				
 			}
 			
-			else if(cardType == membership)
-			{
-				if(cardHolder == null || verifyCardNumber(cardNumber) == false)
-				{
+			else if(cardType == membership){
+				// Membership cards are always swiped
+				if(cardHolder != null || verifyCardNumber(cardNumber) == true) {
+					if(verifyMembershipCard(data) == true) {
+						membershipNo = cardNumber;
+					}
+				} else {
 					displayError();
 				}
-				if(verifyMembershipCard(data) == true)
-				{
-					membershipNo = cardNumber;
-				}
-				
-				
 			}
-			
 		}
-		
-		
 	}
-	
 }
\ No newline at end of file

commit 362c94427db8c7080cd7722158a563e31d6ff778
Author: mohamedhefnawy1 <mohamedhefnawy10@gmail.com>
Date:   Mon Mar 28 17:19:16 2022 -0600

    finishing up debit and credit card implmentation

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index 8fbe263..ba81d24 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -222,15 +222,27 @@ public class PaymentController{
 	
 	private class CC implements CardReaderObserver {
 		
+		
+		
 		public boolean verifyCVV(String data)
 		{
-			return verified;
+			if(data.matches("[0-9]+") && data.length() ==  3)
+			{
+				return true;
+			}
+			return false;
 		}
+		
 		public boolean verifyCardNumber(String data)
 		{
-			return verified;
+			if(data.matches("[0-9]+") && data.length() ==  3)
+			{
+				return true;
+			}
+			return false;
 		}
 		
+		//verifies that the card info is correct and that card has sufficient funds 
 		public boolean verifyDebitCard(CardData data)
 		{
 			return verified;
@@ -302,12 +314,25 @@ public class PaymentController{
 			
 			if(cardType == debit)
 			{
-				//review try catch logic
-				if(verifyCardNumber(cardNumber) == false || cardHolder == null || verifyCVV(cardCVV) == false)
+				if (!(data instanceof CardSwipeData))
 				{
-					displayError();
+					//review try catch logic
+					if(verifyCardNumber(cardNumber) == false || cardHolder == null || verifyCVV(cardCVV) == false)
+					{
+						displayError();
+					}
+				
+				}
+				else
+				{
+					//review try catch logic
+					if(verifyCardNumber(cardNumber) == false || cardHolder == null)
+					{
+						displayError();
+					}
 				}
 				
+				
 				if(verifyDebitCard(data) == true)
 				{
 					valueOfCart = new BigDecimal(0);
@@ -322,9 +347,22 @@ public class PaymentController{
 			else if(cardType == credit)
 			{
 				//review try catch logic
-				if(verifyCardNumber(cardNumber) == false || cardHolder == null || verifyCVV(cardCVV) == false)
+				if (!(data instanceof CardSwipeData))
 				{
-					displayError();
+					//review try catch logic
+					if(verifyCardNumber(cardNumber) == false || cardHolder == null || verifyCVV(cardCVV) == false)
+					{
+						displayError();
+					}
+				
+				}
+				else
+				{
+					//review try catch logic
+					if(verifyCardNumber(cardNumber) == false || cardHolder == null)
+					{
+						displayError();
+					}
 				}
 				
 				if(verifyCreditCard(data) == true)

commit 0944e2cbc6e5c54cd9944b435bdf25d3ff9477a7
Author: Bradley <jizhe.li@ucalgary.ca>
Date:   Mon Mar 28 01:02:28 2022 -0600

    some changes

diff --git a/.DS_Store b/.DS_Store
index 763da7e..3984a70 100644
Binary files a/.DS_Store and b/.DS_Store differ
diff --git a/SCS - Software/.DS_Store b/SCS - Software/.DS_Store
new file mode 100644
index 0000000..914a24e
Binary files /dev/null and b/SCS - Software/.DS_Store differ
diff --git a/SCS - Software/src/.DS_Store b/SCS - Software/src/.DS_Store
new file mode 100644
index 0000000..4c7b194
Binary files /dev/null and b/SCS - Software/src/.DS_Store differ
diff --git a/SCS - Software/src/org/.DS_Store b/SCS - Software/src/org/.DS_Store
new file mode 100644
index 0000000..00c08ac
Binary files /dev/null and b/SCS - Software/src/org/.DS_Store differ
diff --git a/SCS - Software/src/org/lsmr/.DS_Store b/SCS - Software/src/org/lsmr/.DS_Store
new file mode 100644
index 0000000..a3d93c5
Binary files /dev/null and b/SCS - Software/src/org/lsmr/.DS_Store differ
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/.DS_Store b/SCS - Software/src/org/lsmr/selfcheckout/.DS_Store
new file mode 100644
index 0000000..3f1c717
Binary files /dev/null and b/SCS - Software/src/org/lsmr/selfcheckout/.DS_Store differ

commit 1d2b81f932e393bdf9eae47e304a452988106eee
Author: Bradley <jizhe.li@ucalgary.ca>
Date:   Mon Mar 28 01:01:53 2022 -0600

    added some changes to fail to place item in the bagging area

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index 825a95e..831d2b0 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -3,6 +3,7 @@ package org.lsmr.selfcheckout.customer;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.ElectronicScale;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.SimulationException;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
 
@@ -14,6 +15,7 @@ public class BaggingAreaController {
 	private ScanItemController scanItemControl;
 	private int numOfItemsInBaggingArea;
 	private double previousWeightOfCart;
+	private long begin;
 	
 	
 	//Constructor
@@ -41,6 +43,10 @@ public class BaggingAreaController {
 		return numOfItemsInBaggingArea;
 	}
 	
+	public void getBeginTime(long begin) {
+		this.begin = begin;
+	}
+	
 	
 	
 	private class BAC implements ElectronicScaleObserver{
@@ -80,6 +86,10 @@ public class BaggingAreaController {
 				checkoutStation.handheldScanner.disable();
 			}
 			
+			long end = System.currentTimeMillis();
+			if (end - begin > 5000) {
+				throw new SimulationException("Fail to place the item in the bagging area within the required time");
+			}	
 		}
 
 		//Disable bar code scanner
@@ -95,16 +105,11 @@ public class BaggingAreaController {
 			checkoutStation.mainScanner.enable();	
 			checkoutStation.handheldScanner.enable();
 		}
-		
 	}
 	
 	
-	
 	public double getWeightOfCart() {
 		return weightOfCart;
 	}
-	
-	
-	
 
 }
\ No newline at end of file
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
index fe2b895..c63546a 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
@@ -78,6 +78,10 @@ public class ScanItemController  {
 		}
 	}
 	
+	public void getBeginTime(long begin) {
+		bagAreaControl.getBeginTime(begin);
+	}
+	
 	//Barcode Scanner Observer Implementation
 	public class SIC implements BarcodeScannerObserver {
 		
@@ -115,7 +119,8 @@ public class ScanItemController  {
 				checkoutStation.handheldScanner.enable();
 			}
 			
-			
+			long begin = System.currentTimeMillis();
+			getBeginTime(begin);
 		}
 	}
 	

commit 7a740127a8def9d439760c9ef3755fcd112a4f26
Merge: 90f1bcd 902e838
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sun Mar 27 15:15:14 2022 -0600

    Merge pull request #5 from adam-25/simon2
    
    Simon2

commit 90f1bcd1801a5150b75c6966d0ec4632eb8aef73
Author: Bradley <jizhe.li@ucalgary.ca>
Date:   Sun Mar 27 15:05:38 2022 -0600

    added a file

diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/SCS - Hardware - v2.0/bin/.gitignore	
@@ -0,0 +1 @@
+/org/

commit 902e838ea2152347c1aeeadd5a47524f42c40385
Author: Simon Vincent <47257674+SmonVincent@users.noreply.github.com>
Date:   Sun Mar 27 13:46:18 2022 -0600

    Testing and Logic Editing in PaymentController
    
    Added a test to the paymentcontroller test suite, which outlines how to test the membership cards. Changed the logic in cardcontroller to correctly verify card swipes. Added a manual entry method for membership cards in payment controller, which has simulation because there is currently no way on the hardware to notify the observer about manual entry.

diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/SCS - Hardware - v2.0/bin/.gitignore	
@@ -0,0 +1 @@
+/org/
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
index 33f857b..0922392 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
@@ -8,6 +8,8 @@ import java.util.HashMap;
 import org.lsmr.selfcheckout.Banknote;
 import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.Card.CardData;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
 import org.lsmr.selfcheckout.customer.BaggingAreaController;
@@ -19,6 +21,7 @@ import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.Numeral;
 
+import java.io.IOException;
 import java.math.BigDecimal;
 import java.util.Currency;
 import java.util.List;
@@ -102,7 +105,7 @@ public class ReceiptPrinterControllerTest extends BaseTestClass{
 		RPcontroller.setControllers(SIcontroller, PAcontroller);
 		
 	}
-	
+	//Utility function for scanning, also scans items normally despite the name.
 	public void scanError(BarcodedItem item) {
 		while (true) {
 			cs.handheldScanner.scan(item);
@@ -143,4 +146,36 @@ public class ReceiptPrinterControllerTest extends BaseTestClass{
 	Assert.assertEquals(RPcontroller.getReceipt(), cs.printer.removeReceipt());
 	}
 	
+	@Test
+	public void membershipNoTest() throws DisabledException, OverloadException, IOException {
+		
+	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+	
+	//Making the membership card
+	Card mcard = new Card("MEMBERSHIP", "405119", "Jimmy Johnson", null, null, false, false);
+	
+	cs.cardReader.swipe(mcard);
+	
+	//Scanning Items
+	scanError(milk);
+	scanError(eggs);
+	scanError(toast);
+	
+	//Total Cost of Item is 10.00
+	PAcontroller.setValueOfCart(new BigDecimal(10));
+	
+	//Item has been paid for
+	cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+	
+	//Print the receipt
+	RPcontroller.printReceipt();
+	
+	cs.printer.cutPaper();
+	
+	//Check if controller expected receipt match the one from the printer
+	Assert.assertEquals(RPcontroller.getReceipt(), cs.printer.removeReceipt());
+	}
+	
 }
\ No newline at end of file
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index 569399a..8fbe263 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -7,8 +7,10 @@ import java.util.Currency;
 import java.util.List;
 
 import org.lsmr.selfcheckout.BlockedCardException;
+import org.lsmr.selfcheckout.Card;
 import org.lsmr.selfcheckout.Coin;
 import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.Card.CardSwipeData;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.BanknoteSlot;
 import org.lsmr.selfcheckout.devices.BanknoteValidator;
@@ -87,7 +89,7 @@ public class PaymentController{
 	//be displayed on the customer's screen and then would prompt him to select a payment option
 	public void displayError() 
 	{
-		System.out.println("an error has occured");
+		System.out.println("an error has occurred");
 		//go back to payment options
 	}
 	
@@ -106,6 +108,14 @@ public class PaymentController{
 		return true;
 	}
 	
+	public void notifyManualMembershipEntry(String manualMembershipNo) {
+		//Simulates customer entering their membership number through touch screen.
+		manualMembershipNo = "405200";
+		//Simulate going to the database and finding which account corresponds with
+		// the entered Membership number
+		membershipNo = manualMembershipNo;
+	}
+	
 	//If all items have been paid for, return true
 	//And disable the coin and bank note slot
 	public boolean isAllItemPaid() {
@@ -214,11 +224,11 @@ public class PaymentController{
 		
 		public boolean verifyCVV(String data)
 		{
-			return false;
+			return verified;
 		}
 		public boolean verifyCardNumber(String data)
 		{
-			return false;
+			return verified;
 		}
 		
 		public boolean verifyDebitCard(CardData data)
@@ -257,13 +267,13 @@ public class PaymentController{
 
 		@Override
 		public void cardRemoved(CardReader reader) {
-			// ignore - membership cards can only be swiped or have number manually entered.
+			// ignore
 			
 		}
 
 		@Override
 		public void cardTapped(CardReader reader) {
-			// ignore - membership cards can only be swiped or have number manually entered.
+			System.out.println("Reading card data. Please wait...");
 			
 		}
 
@@ -279,7 +289,11 @@ public class PaymentController{
 			String cardType = data.getType();
 			String cardNumber = data.getNumber();
 			String cardHolder = data.getCardholder();
-			String cardCVV = data.getCVV();
+			String cardCVV = null;
+			
+			if (!(data instanceof CardSwipeData)) {
+			cardCVV = data.getCVV();
+			}
 			
 			if(cardType == null)
 			{
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
index a3e7670..8e555f6 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java	
@@ -50,14 +50,14 @@ public class ReceiptPrinterController {
 					+ barcodePrice.get(barcode) + "\n";
 		}
 		receiptMessage = receiptMessage + "Total Price: " + payControl.getInitialValueOfCart();
+		
+		if(payControl.hasMembership()) {
+			receiptMessage = receiptMessage + "\n\n" + payControl.getMembershipNo();
+		}
 	
 		for(int i =0; i < receiptMessage.length(); i++) {
 			checkoutStation.printer.print(receiptMessage.charAt(i));		
 		}
-		
-		if(payControl.hasMembership() == true) {
-			receiptMessage = receiptMessage + "\n" + payControl.getMembershipNo();
-		}
 	}
 	
 	//Returns the receipts message
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class
index aeb5157..126ad10 100644
Binary files a/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class and b/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class
index 7af63cd..7389bcc 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class
index eff148d..2b4437c 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class
index f92f66d..6f19746 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class
index ddc3b0f..7ee9e75 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class differ

commit c680047df18d3c3ffddaaae48dbaa475f30fc0c1
Author: Simon Vincent <47257674+SmonVincent@users.noreply.github.com>
Date:   Sat Mar 26 17:40:12 2022 -0600

    Committed
    
    Same changes as last commit, just saved the files before the commit so they actually went through.

diff --git a/.gitignore b/.gitignore
index e10e727..2715f36 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
 /.metadata/
+/bin/
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index 21ce61c..569399a 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -91,6 +91,11 @@ public class PaymentController{
 		//go back to payment options
 	}
 	
+	public String getMembershipNo()
+	{
+		return membershipNo;
+	}
+	
 	public boolean hasMembership()
 	{
 		if(membershipNo == null)
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
index 4918cbd..a3e7670 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java	
@@ -54,6 +54,10 @@ public class ReceiptPrinterController {
 		for(int i =0; i < receiptMessage.length(); i++) {
 			checkoutStation.printer.print(receiptMessage.charAt(i));		
 		}
+		
+		if(payControl.hasMembership() == true) {
+			receiptMessage = receiptMessage + "\n" + payControl.getMembershipNo();
+		}
 	}
 	
 	//Returns the receipts message
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class
index da10210..7af63cd 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class
index 1b7130f..eff148d 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class
index 6f56310..f92f66d 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class
index 733cbd0..ddc3b0f 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class b/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class
index 6b90115..1cc5af1 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class and b/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class b/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class
index 0aba9c0..656b2d1 100644
Binary files a/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class and b/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class differ

commit 8f1622a7877334762d0aa0492fb7f7b06aa85e38
Author: Simon Vincent <47257674+SmonVincent@users.noreply.github.com>
Date:   Sat Mar 26 17:37:13 2022 -0600

    Getter and Receipt
    
    Added getter method for membershipNo in PaymentController and appended membershipNo to receipt message

diff --git a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class
new file mode 100644
index 0000000..74807dd
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class
new file mode 100644
index 0000000..c535183
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/BaggingAreaController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/CardController$MCC.class b/bin/src/org/lsmr/selfcheckout/customer/CardController$MCC.class
new file mode 100644
index 0000000..03a2def
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/CardController$MCC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/CardController.class b/bin/src/org/lsmr/selfcheckout/customer/CardController.class
new file mode 100644
index 0000000..b65a50a
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/CardController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class
new file mode 100644
index 0000000..da10210
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$CC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class
new file mode 100644
index 0000000..1b7130f
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCB.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class
new file mode 100644
index 0000000..6f56310
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController$PCC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class
new file mode 100644
index 0000000..733cbd0
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/PaymentController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class b/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class
new file mode 100644
index 0000000..6b90115
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class b/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class
new file mode 100644
index 0000000..0aba9c0
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class
new file mode 100644
index 0000000..0f18a22
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class
new file mode 100644
index 0000000..89f8b7e
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/ScanItemController.class differ
diff --git a/bin/src/org/lsmr/selfcheckout/customer/TouchScreenController.class b/bin/src/org/lsmr/selfcheckout/customer/TouchScreenController.class
new file mode 100644
index 0000000..8c75c7b
Binary files /dev/null and b/bin/src/org/lsmr/selfcheckout/customer/TouchScreenController.class differ

commit ff4eb9b35fb10b16bb89a761034a8d0aa9dafd45
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sat Mar 26 17:07:50 2022 -0600

    adding handheld scanner

diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
deleted file mode 100644
index cf1db2e..0000000
--- a/SCS - Hardware - v2.0/bin/.gitignore	
+++ /dev/null
@@ -1 +0,0 @@
-/org/
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
index a86832b..33f857b 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
@@ -10,13 +10,15 @@ import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.customer.*;
-//import org.lsmr.selfcheckout.customer.PaymentController;
-//import org.lsmr.selfcheckout.customer.ReceiptPrinterController;
-//import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.PaymentController;
+import org.lsmr.selfcheckout.customer.ReceiptPrinterController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.Numeral;
+
 import java.math.BigDecimal;
 import java.util.Currency;
 import java.util.List;
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
index 746fb5f..924075f 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
@@ -88,10 +88,10 @@ public class ScanItemControllerTest extends BaseTestClass{
 	
 	public void scanError(BarcodedItem item) {
 		while (true) {
-			cs.scanner.scan(item);
+			cs.handheldScanner.scan(item);
 			
 			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
-				cs.scale.add(item);
+				cs.baggingArea.add(item);
 				break;
 			}
 		}
@@ -133,8 +133,8 @@ public class ScanItemControllerTest extends BaseTestClass{
 		Double expectedWeightOfCart = 0.0;
 		BigDecimal expectedValueOfCart = new BigDecimal(0);
 		
-		cs.scanner.disable();
-		cs.scanner.scan(milk);
+		cs.handheldScanner.disable();
+		cs.handheldScanner.scan(milk);
 		
 		
 		Assert.assertEquals(new BigDecimal(0), SIcontroller.getValueOfCart());
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
index 0b0748e..7ddd02b 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
@@ -25,7 +25,7 @@ public class TouchScreenControllerTest extends BaseTestClass {
 	@Test
 	public void testInitStart() {
 		touchScreenController.initiateStart();
-		Assert.assertFalse(checkoutStation.scanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 	}
 	
 	
@@ -34,7 +34,7 @@ public class TouchScreenControllerTest extends BaseTestClass {
 	@Test
 	public void testInitCheckout() {
 		touchScreenController.inititateCheckout();
-		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
 		Assert.assertFalse(checkoutStation.banknoteInput.isDisabled());
 		Assert.assertFalse(checkoutStation.coinSlot.isDisabled());
 	}

commit bd51d7123fc8f411750bc83be42b5fa0a5c59636
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sat Mar 26 17:05:28 2022 -0600

    fixing issues

diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
index 3757c58..746fb5f 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
@@ -10,8 +10,8 @@ import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.customer.*;
-//import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
@@ -88,10 +88,10 @@ public class ScanItemControllerTest extends BaseTestClass{
 	
 	public void scanError(BarcodedItem item) {
 		while (true) {
-			cs.handheldScanner.scan(item);
+			cs.scanner.scan(item);
 			
 			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
-				cs.baggingArea.add(item);
+				cs.scale.add(item);
 				break;
 			}
 		}
@@ -133,8 +133,8 @@ public class ScanItemControllerTest extends BaseTestClass{
 		Double expectedWeightOfCart = 0.0;
 		BigDecimal expectedValueOfCart = new BigDecimal(0);
 		
-		cs.handheldScanner.disable();
-		cs.handheldScanner.scan(milk);
+		cs.scanner.disable();
+		cs.scanner.scan(milk);
 		
 		
 		Assert.assertEquals(new BigDecimal(0), SIcontroller.getValueOfCart());
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
index 50d9cf4..0b0748e 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
@@ -25,7 +25,7 @@ public class TouchScreenControllerTest extends BaseTestClass {
 	@Test
 	public void testInitStart() {
 		touchScreenController.initiateStart();
-		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.scanner.isDisabled());
 	}
 	
 	
@@ -34,9 +34,9 @@ public class TouchScreenControllerTest extends BaseTestClass {
 	@Test
 	public void testInitCheckout() {
 		touchScreenController.inititateCheckout();
-		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.scanner.isDisabled());
 		Assert.assertFalse(checkoutStation.banknoteInput.isDisabled());
 		Assert.assertFalse(checkoutStation.coinSlot.isDisabled());
 	}
 	
-}
+}
\ No newline at end of file

commit 9570b180a8f185838303da23f360ba2f6fe34d92
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sat Mar 26 16:54:26 2022 -0600

    Revert "added source folder"
    
    This reverts commit 7c2c1f91650b6def2755f334c4f968d7616de5b8.
    
    removing source folder as it caused problems

diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
similarity index 100%
rename from SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
rename to SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
similarity index 100%
rename from SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
rename to SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
deleted file mode 100644
index 534e709..0000000
--- a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
+++ /dev/null
@@ -1,310 +0,0 @@
-package org.lsmr.selfcheckout.customer.testing;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-import java.util.HashMap;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.customer.BaggingAreaController;
-import org.lsmr.selfcheckout.customer.PaymentController;
-import org.lsmr.selfcheckout.customer.ScanItemController;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-public class BaggingAreaControllerTest extends BaseTestClass {
-	private BaggingAreaController BACController;
-	private ScanItemController SICController;
-	private HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
-	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
-	private SelfCheckoutStation cs;
-	
-	//initializing prices of items
-	BigDecimal item1Price = new BigDecimal(2.50);
-	BigDecimal item2Price = new BigDecimal(4.05);
-	BigDecimal item3Price = new BigDecimal(3.50);
-			
-	Numeral[] nItem1 = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
-	Numeral[] nItem2 = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
-	Numeral[] nItem3 = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
-			
-			
-	//initalizing barcodes of the items
-	Barcode barcodeItem1 = new Barcode(nItem1);
-	Barcode barcodeItem2 = new Barcode(nItem2);
-	Barcode barcodeItem3 = new Barcode(nItem3);
-	
-	//Method to ensure that the item scanned is actually added
-	public void handheldScanError(BarcodedItem item) {
-		while (true) {
-			cs.handheldScanner.scan(item);
-			
-			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
-				cs.baggingArea.add(item);
-				break;
-			}
-		}
-	}
-	
-	public void mainScanError(BarcodedItem item) {
-		while (true) {
-			cs.mainScanner.scan(item);
-			
-			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
-				cs.baggingArea.add(item);
-				break;
-			}
-		}
-	}
-	
-	//Initialize selfcheckout station 
-	//Bagging area controller
-	//Scan item controller
-	@Before
-	public void setup()  {
-		
-		//Use checkout station from base test class
-		super.setup();
-		cs = checkoutStation;
-		
-		
-		
-		//initalizing price hashmap		
-		barcodePrice.put(barcodeItem1, item1Price);	//Item1
-		barcodePrice.put(barcodeItem2, item2Price);	//Item2
-		barcodePrice.put(barcodeItem3, item3Price);	//item3
-				
-		//initalizing expected weight hashmap
-		barcodeWeight.put(barcodeItem1, 300.0);
-		barcodeWeight.put(barcodeItem2, 100.0);
-		barcodeWeight.put(barcodeItem3, 1000.0);
-		
-		SICController = new ScanItemController(checkoutStation, barcodePrice, barcodeWeight);
-		BACController = new BaggingAreaController(checkoutStation);
-		
-		//Setting the Controllers of each Controller
-		BACController.setScanItemControl(SICController);
-		SICController.setBagAreaControl(BACController);
-
-	}
-	
-	//Test if scanner is disabled if scale is overload
-	//Enter overload by adding heavy item to scale
-	@Test
-	public void testScannerDisabledOverLoad1() {
-		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
-		BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
-		BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
-		BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
-
-		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
-		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
-		
-		
-		try {
-			mainScanError(item3);
-
-			mainScanError(item1);
-
-			mainScanError(item2);
-	
-			mainScanError(item3Dup1);
-
-
-			
-		} catch(Exception e) {
-			//shouldn't each here
-			System.out.println("not supposed to occur");
-			e.printStackTrace();
-			fail();
-		}
-		
-		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
-		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
-		
-	
-	}
-	
-	//Test if the scale goes out of overload, the scanner is enabled
-		@Test
-		public void testScannerDisabledOverLoad2() {
-			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
-			BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
-			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
-			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
-
-			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
-			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
-			
-			try {
-				mainScanError(item3);
-				mainScanError(item1);
-				mainScanError(item2);
-				mainScanError(item3Dup1);
-			} catch(Exception e) {
-				//shouldn't each here
-				System.out.println("not supposed to occur");
-				e.printStackTrace();
-				fail();
-			}
-			
-			
-			Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
-			Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
-			
-			try {
-				checkoutStation.baggingArea.remove(item3);
-			} catch(Exception e) {
-				//shouldn't each here
-				System.out.println("not supposed to occur");
-				e.printStackTrace();
-				fail();
-			}
-			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
-			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
-			Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
-		}
-	
-	
-	//Test if scanner is disabled if there is a weight discrepancy
-	//test one item with a discrepancy in the weight that is larger
-
-	//double check to see if test logic is sound
-	@Test
-	public void testWeightChanged1() {
-		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 400.0);
-		
-		try {
-			mainScanError(item1);
-		} catch (Exception e) {
-			System.out.println("Shouldn't happen");
-			fail();
-		}
-		
-		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
-		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
-	}
-	
-	//Test if scanner is disabled if there is a weight discrepancy
-	//test 1 item with a discrepancy in the weight that is less
-	
-	//double check to see if test logic is sound
-	@Test
-	public void testWeightChanged2() {
-		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 200.0);
-
-		try {
-			mainScanError(item1);
-		} catch (Exception e) {
-			System.out.println("Shouldn't happen");
-			fail();
-		}
-		
-		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
-		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
-	}
-	
-	//Test if scanner is disabled if there is a weight discrepancy
-		//test 2 items with one having discrepancy in the weight that is correct weight and one that is greater than the expected
-		@Test
-		public void testWeightChanged3() {
-			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
-			BarcodedItem item1Dup1 = new BarcodedItem(barcodeItem1, 400.0);
-
-			try {
-				mainScanError(item1);
-				mainScanError(item1Dup1);
-			} catch (Exception e) {
-				System.out.println("Shouldn't happen");
-				fail();
-			}
-			
-			Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
-			Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
-		}
-	
-		//Test to see that when an item is removed the controller knows and adjusts the number in the cart
-		@Test
-		public void testWeightChanged4() {
-			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
-			BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
-			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
-			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
-
-			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
-			
-			try {
-				mainScanError(item3);
-				mainScanError(item1);
-				mainScanError(item2);
-				mainScanError(item3Dup1);
-				
-			} catch(Exception e) {
-				//shouldn't each here
-				System.out.println("not supposed to occur");
-				e.printStackTrace();
-				fail();
-			}
-			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
-			
-			try {
-				checkoutStation.baggingArea.remove(item3Dup1);
-			} catch (Exception e) {
-				fail();
-			}
-			
-			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
-			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
-			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
-		}
-		
-		//Test to see that when all items are removed the controller knows and adjusts the number in the cart
-				@Test
-				public void testWeightChanged5() {
-					BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
-					BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
-					BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
-
-
-					Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
-					Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
-					
-					try {
-						mainScanError(item3);
-						mainScanError(item1);
-						mainScanError(item2);
-
-						
-					} catch(Exception e) {
-						//shouldn't each here
-						System.out.println("not supposed to occur");
-						e.printStackTrace();
-						fail();
-					}
-					
-					Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
-					
-					try {
-						checkoutStation.baggingArea.remove(item2);
-						checkoutStation.baggingArea.remove(item3);
-						checkoutStation.baggingArea.remove(item1);
-					} catch (Exception e) {
-						fail();
-					}
-					
-
-					Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 0);
-				}
-	
-}
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
deleted file mode 100644
index bab59fb..0000000
--- a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
+++ /dev/null
@@ -1,146 +0,0 @@
-package org.lsmr.selfcheckout.customer.testing;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import java.util.HashMap;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.customer.BaggingAreaController;
-import org.lsmr.selfcheckout.customer.PaymentController;
-import org.lsmr.selfcheckout.customer.ReceiptPrinterController;
-import org.lsmr.selfcheckout.customer.ScanItemController;
-import org.lsmr.selfcheckout.devices.DisabledException;
-import org.lsmr.selfcheckout.devices.OverloadException;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.Numeral;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-import java.util.List;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-//Mohamed
-
-public class ReceiptPrinterControllerTest extends BaseTestClass{
-	
-	//declaring self checkout station
-	private SelfCheckoutStation cs;
-	
-	//declaring controllers 
-	private ReceiptPrinterController RPcontroller;
-	private PaymentController PAcontroller;
-	private ScanItemController SIcontroller;
-	private BaggingAreaController bAcontroller;
-	
-	//initializing prices of items
-	BigDecimal milkPrice = new BigDecimal(2.50);
-	BigDecimal eggPrice = new BigDecimal(4.00);
-	BigDecimal toastPrice = new BigDecimal(3.50);
-	
-	Numeral[] nMilk = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
-	Numeral[] nEggs = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
-	Numeral[] nToast = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
-	
-	
-	//initalizing barcodes of the items
-	Barcode barcodeMilk = new Barcode(nMilk);
-	Barcode barcodeEggs = new Barcode(nEggs);
-	Barcode barcodeToast = new Barcode(nToast);
-	
-	
-	//declaring hashmap barcodePrice hashmap and barcodeWeight hashmap
-	private final HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
-	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
-	private final HashMap<Barcode, String> barcodeDescription = new HashMap<Barcode, String>();
-	
-	
-	//Initialize checkoutStation
-	//Create a hasMap of bar code to price
-	@Before
-	public void setup() {
-		
-		
-		super.setup();
-		cs = checkoutStation;
-		
-		
-		//initalizing price hashmap		
-		barcodePrice.put(barcodeMilk, milkPrice);	//milk
-		barcodePrice.put(barcodeEggs, eggPrice);	//eggs
-		barcodePrice.put(barcodeToast, toastPrice);	//toast
-		
-		//initalizing weight hashmap
-		barcodeWeight.put(barcodeMilk, 3.0);	//milk
-		barcodeWeight.put(barcodeEggs, 2.0);	//eggs
-		barcodeWeight.put(barcodeToast, 5.0);	//toast
-		
-		//initializng barcode description 
-		barcodeDescription.put(barcodeMilk, "Milk");	//milk
-		barcodeDescription.put(barcodeEggs, "Eggs");	//eggs
-		barcodeDescription.put(barcodeToast, "Toast");	//toast
-		
-		
-		
-		//initalizing controllers
-		SIcontroller = new ScanItemController(cs, barcodePrice, barcodeWeight);
-		PAcontroller = new PaymentController(cs);
-		RPcontroller = new ReceiptPrinterController(cs,barcodePrice, barcodeDescription);
-		bAcontroller = new BaggingAreaController(cs);
-		
-		
-		//calling object methods
-		bAcontroller.setScanItemControl(SIcontroller);
-		SIcontroller.setBagAreaControl(bAcontroller);
-		RPcontroller.setControllers(SIcontroller, PAcontroller);
-		
-	}
-	
-	public void scanError(BarcodedItem item) {
-		while (true) {
-			cs.scanner.scan(item);
-			
-			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
-				cs.scale.add(item);
-				break;
-			}
-		}
-	}
-	
-	
-	//Test if controller expected receipt match the one from the printer
-	@Test
-	public void test1() throws DisabledException, OverloadException {
-		
-	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
-	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
-	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
-	
-	//Scanning Items
-	scanError(milk);
-	scanError(eggs);
-	scanError(toast);
-	
-	//Total Cost of Item is 10.00
-	PAcontroller.setValueOfCart(new BigDecimal(10));
-	
-	//Item has been paid for
-	cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
-	
-	//Print the receipt
-	RPcontroller.printReceipt();
-	
-	cs.printer.cutPaper();
-	
-	//Check if controller expected receipt match the one from the printer
-	Assert.assertEquals(RPcontroller.getReceipt(), cs.printer.removeReceipt());
-	}
-	
-}
\ No newline at end of file
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
deleted file mode 100644
index 746fb5f..0000000
--- a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
+++ /dev/null
@@ -1,229 +0,0 @@
-package org.lsmr.selfcheckout.customer.testing;
-
-
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import java.util.HashMap;
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.customer.BaggingAreaController;
-import org.lsmr.selfcheckout.customer.ScanItemController;
-import org.lsmr.selfcheckout.devices.DisabledException;
-import org.lsmr.selfcheckout.devices.OverloadException;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.Numeral;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-import java.util.List;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-
-public class ScanItemControllerTest extends BaseTestClass{
-	
-	//declaring self checkout station
-	private SelfCheckoutStation cs;
-	
-	//declaring controllers 
-	private ScanItemController SIcontroller;
-	private BaggingAreaController bAcontroller;
-	
-	//initializing prices of items
-	BigDecimal milkPrice = new BigDecimal(2.50);
-	BigDecimal eggPrice = new BigDecimal(4.05);
-	BigDecimal toastPrice = new BigDecimal(3.50);
-	
-	Numeral[] nMilk = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
-	Numeral[] nEggs = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
-	Numeral[] nToast = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
-	
-	
-	//initalizing barcodes of the items
-	Barcode barcodeMilk = new Barcode(nMilk);
-	Barcode barcodeEggs = new Barcode(nEggs);
-	Barcode barcodeToast = new Barcode(nToast);
-	
-	
-	//declaring hashmap barcodePrice hashmap and barcodeWeight hashmap
-	private HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
-	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
-	
-	//Initialize checkoutStation
-	//Create a hasMap of bar code to price
-	@Before
-	public void setup() {
-		
-		
-		super.setup();
-		cs = checkoutStation;
-		
-		
-		//initalizing price hashmap		
-		barcodePrice.put(barcodeMilk, milkPrice);	//milk
-		barcodePrice.put(barcodeEggs, eggPrice);	//eggs
-		barcodePrice.put(barcodeToast, toastPrice);	//toast
-		
-		//initalizing weight hashmap
-		barcodeWeight.put(barcodeMilk, 3.0);	//milk
-		barcodeWeight.put(barcodeEggs, 2.0);	//eggs
-		barcodeWeight.put(barcodeToast, 5.0);	//toast
-		
-		
-		//initalizing the BaggingAreaController and scanItemController
-		bAcontroller = new BaggingAreaController(cs);
-		SIcontroller = new ScanItemController(cs, barcodePrice, barcodeWeight);
-
-		//calling object methods
-		bAcontroller.setScanItemControl(SIcontroller);
-		SIcontroller.setBagAreaControl(bAcontroller);
-		
-	}
-	
-	public void scanError(BarcodedItem item) {
-		while (true) {
-			cs.scanner.scan(item);
-			
-			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
-				cs.scale.add(item);
-				break;
-			}
-		}
-	}
-	
-	
-	//Expected value of cart = 10.05
-	//Compare with the actual value of cart from the ScanItemController
-	//Initialize a scanItemController
-	@Test
-	public void test1() {
-		
-	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
-	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
-	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
-	
-	
-	scanError(milk);
-	scanError(eggs);
-	scanError(toast);
-	
-
-	BigDecimal expectedValueOfCart = new BigDecimal(0);
-	expectedValueOfCart = expectedValueOfCart.add(milkPrice);
-	expectedValueOfCart = expectedValueOfCart.add(eggPrice);
-	expectedValueOfCart = expectedValueOfCart.add(toastPrice);
-
-	Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
-	}
-	
-	
-	//Disable the scanner
-	//Expected result - disable exception
-	//Try and scan an item while disabled
-	@Test
-	public void test2() {
-		
-		BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
-		Double expectedWeightOfCart = 0.0;
-		BigDecimal expectedValueOfCart = new BigDecimal(0);
-		
-		cs.scanner.disable();
-		cs.scanner.scan(milk);
-		
-		
-		Assert.assertEquals(new BigDecimal(0), SIcontroller.getValueOfCart());
-		Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
-		
-	}
-		
-		
-	
-	//scan a valid item
-	@Test
-	public void test3() {
-		//initializing barcodedItems
-		BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
-		BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
-		BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
-	
-		
-		Double expectedWeightOfCart = 10.0;
-		BigDecimal expectedValueOfCart = new BigDecimal(0);
-		expectedValueOfCart = expectedValueOfCart.add(milkPrice);
-		expectedValueOfCart = expectedValueOfCart.add(eggPrice);
-		expectedValueOfCart = expectedValueOfCart.add(toastPrice);
-		
-		scanError(milk);
-		scanError(eggs);
-		scanError(toast);
-
-		Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
-		Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
-		
-	}
-	
-	//unscans a valid item
-		@Test
-		public void unScan1() {
-			//initializing barcodedItems
-			BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
-			BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
-			BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
-		
-			
-			Double expectedWeightOfCart = 10.0;
-			BigDecimal expectedValueOfCart = new BigDecimal(0);
-			expectedValueOfCart = expectedValueOfCart.add(milkPrice);
-			expectedValueOfCart = expectedValueOfCart.add(eggPrice);
-			expectedValueOfCart = expectedValueOfCart.add(toastPrice);
-			
-			scanError(milk);
-			scanError(eggs);
-			scanError(toast);
-			
-			SIcontroller.unScanItem(eggs.getBarcode());
-			
-			
-			expectedValueOfCart = expectedValueOfCart.subtract(eggPrice);
-			expectedWeightOfCart -= eggs.getWeight();
-			
-			Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
-			Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
-			
-		}
-		
-		//unscans a item not in the cart
-		@Test
-		public void unScan2() {
-			//initializing barcodedItems
-			BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
-			BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
-			BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
-					
-			Double expectedWeightOfCart = 5.0;
-			BigDecimal expectedValueOfCart = new BigDecimal(0);
-			expectedValueOfCart = expectedValueOfCart.add(milkPrice);
-			expectedValueOfCart = expectedValueOfCart.add(eggPrice);
-
-			scanError(milk);
-			scanError(eggs);
-
-					
-			SIcontroller.unScanItem(toast.getBarcode());
-					
-					
-
-			Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
-			Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
-					
-		}
-				
-		
-	
-}
\ No newline at end of file
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
deleted file mode 100644
index 6ff92bc..0000000
--- a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.lsmr.selfcheckout.customer.testing;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import org.lsmr.selfcheckout.customer.TouchScreenController;
-
-/**
- * Test cases for the touch screen
- */
-public class TouchScreenControllerTest extends BaseTestClass {	
-	
-	/**
-	 * System under test
-	 */
-	TouchScreenController touchScreenController;
-	
-	@Override
-	public void setup() {
-		super.setup();
-		touchScreenController = new TouchScreenController(checkoutStation);
-	}
-
-	//Test if scanner is enabled when the user starts using the checkout station
-	@Test
-	public void testInitStart() {
-		touchScreenController.initiateStart();
-		Assert.assertFalse(checkoutStation.scanner.isDisabled());
-	}
-	
-	
-	//Test if scanner is disable and coin/banknote slot is enabled
-	//When user wishes to checkout and make payment
-	@Test
-	public void testInitCheckout() {
-		touchScreenController.inititateCheckout();
-		Assert.assertTrue(checkoutStation.scanner.isDisabled());
-		Assert.assertFalse(checkoutStation.banknoteInput.isDisabled());
-		Assert.assertFalse(checkoutStation.coinSlot.isDisabled());
-	}
-	
-}

commit 7c2c1f91650b6def2755f334c4f968d7616de5b8
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sat Mar 26 16:50:15 2022 -0600

    added source folder

diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
new file mode 100644
index 0000000..534e709
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
@@ -0,0 +1,310 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+import java.util.HashMap;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.PaymentController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+public class BaggingAreaControllerTest extends BaseTestClass {
+	private BaggingAreaController BACController;
+	private ScanItemController SICController;
+	private HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
+	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
+	private SelfCheckoutStation cs;
+	
+	//initializing prices of items
+	BigDecimal item1Price = new BigDecimal(2.50);
+	BigDecimal item2Price = new BigDecimal(4.05);
+	BigDecimal item3Price = new BigDecimal(3.50);
+			
+	Numeral[] nItem1 = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+	Numeral[] nItem2 = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
+	Numeral[] nItem3 = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
+			
+			
+	//initalizing barcodes of the items
+	Barcode barcodeItem1 = new Barcode(nItem1);
+	Barcode barcodeItem2 = new Barcode(nItem2);
+	Barcode barcodeItem3 = new Barcode(nItem3);
+	
+	//Method to ensure that the item scanned is actually added
+	public void handheldScanError(BarcodedItem item) {
+		while (true) {
+			cs.handheldScanner.scan(item);
+			
+			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
+				cs.baggingArea.add(item);
+				break;
+			}
+		}
+	}
+	
+	public void mainScanError(BarcodedItem item) {
+		while (true) {
+			cs.mainScanner.scan(item);
+			
+			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
+				cs.baggingArea.add(item);
+				break;
+			}
+		}
+	}
+	
+	//Initialize selfcheckout station 
+	//Bagging area controller
+	//Scan item controller
+	@Before
+	public void setup()  {
+		
+		//Use checkout station from base test class
+		super.setup();
+		cs = checkoutStation;
+		
+		
+		
+		//initalizing price hashmap		
+		barcodePrice.put(barcodeItem1, item1Price);	//Item1
+		barcodePrice.put(barcodeItem2, item2Price);	//Item2
+		barcodePrice.put(barcodeItem3, item3Price);	//item3
+				
+		//initalizing expected weight hashmap
+		barcodeWeight.put(barcodeItem1, 300.0);
+		barcodeWeight.put(barcodeItem2, 100.0);
+		barcodeWeight.put(barcodeItem3, 1000.0);
+		
+		SICController = new ScanItemController(checkoutStation, barcodePrice, barcodeWeight);
+		BACController = new BaggingAreaController(checkoutStation);
+		
+		//Setting the Controllers of each Controller
+		BACController.setScanItemControl(SICController);
+		SICController.setBagAreaControl(BACController);
+
+	}
+	
+	//Test if scanner is disabled if scale is overload
+	//Enter overload by adding heavy item to scale
+	@Test
+	public void testScannerDisabledOverLoad1() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+		BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+		BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+		BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
+
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		
+		
+		try {
+			mainScanError(item3);
+
+			mainScanError(item1);
+
+			mainScanError(item2);
+	
+			mainScanError(item3Dup1);
+
+
+			
+		} catch(Exception e) {
+			//shouldn't each here
+			System.out.println("not supposed to occur");
+			e.printStackTrace();
+			fail();
+		}
+		
+		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+		
+	
+	}
+	
+	//Test if the scale goes out of overload, the scanner is enabled
+		@Test
+		public void testScannerDisabledOverLoad2() {
+			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+			BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
+
+			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+			
+			try {
+				mainScanError(item3);
+				mainScanError(item1);
+				mainScanError(item2);
+				mainScanError(item3Dup1);
+			} catch(Exception e) {
+				//shouldn't each here
+				System.out.println("not supposed to occur");
+				e.printStackTrace();
+				fail();
+			}
+			
+			
+			Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+			Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+			
+			try {
+				checkoutStation.baggingArea.remove(item3);
+			} catch(Exception e) {
+				//shouldn't each here
+				System.out.println("not supposed to occur");
+				e.printStackTrace();
+				fail();
+			}
+			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+			Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
+		}
+	
+	
+	//Test if scanner is disabled if there is a weight discrepancy
+	//test one item with a discrepancy in the weight that is larger
+
+	//double check to see if test logic is sound
+	@Test
+	public void testWeightChanged1() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 400.0);
+		
+		try {
+			mainScanError(item1);
+		} catch (Exception e) {
+			System.out.println("Shouldn't happen");
+			fail();
+		}
+		
+		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+	}
+	
+	//Test if scanner is disabled if there is a weight discrepancy
+	//test 1 item with a discrepancy in the weight that is less
+	
+	//double check to see if test logic is sound
+	@Test
+	public void testWeightChanged2() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 200.0);
+
+		try {
+			mainScanError(item1);
+		} catch (Exception e) {
+			System.out.println("Shouldn't happen");
+			fail();
+		}
+		
+		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+	}
+	
+	//Test if scanner is disabled if there is a weight discrepancy
+		//test 2 items with one having discrepancy in the weight that is correct weight and one that is greater than the expected
+		@Test
+		public void testWeightChanged3() {
+			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+			BarcodedItem item1Dup1 = new BarcodedItem(barcodeItem1, 400.0);
+
+			try {
+				mainScanError(item1);
+				mainScanError(item1Dup1);
+			} catch (Exception e) {
+				System.out.println("Shouldn't happen");
+				fail();
+			}
+			
+			Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+			Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+		}
+	
+		//Test to see that when an item is removed the controller knows and adjusts the number in the cart
+		@Test
+		public void testWeightChanged4() {
+			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+			BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
+
+			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+			
+			try {
+				mainScanError(item3);
+				mainScanError(item1);
+				mainScanError(item2);
+				mainScanError(item3Dup1);
+				
+			} catch(Exception e) {
+				//shouldn't each here
+				System.out.println("not supposed to occur");
+				e.printStackTrace();
+				fail();
+			}
+			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
+			
+			try {
+				checkoutStation.baggingArea.remove(item3Dup1);
+			} catch (Exception e) {
+				fail();
+			}
+			
+			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
+		}
+		
+		//Test to see that when all items are removed the controller knows and adjusts the number in the cart
+				@Test
+				public void testWeightChanged5() {
+					BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+					BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+					BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+
+
+					Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+					Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+					
+					try {
+						mainScanError(item3);
+						mainScanError(item1);
+						mainScanError(item2);
+
+						
+					} catch(Exception e) {
+						//shouldn't each here
+						System.out.println("not supposed to occur");
+						e.printStackTrace();
+						fail();
+					}
+					
+					Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
+					
+					try {
+						checkoutStation.baggingArea.remove(item2);
+						checkoutStation.baggingArea.remove(item3);
+						checkoutStation.baggingArea.remove(item1);
+					} catch (Exception e) {
+						fail();
+					}
+					
+
+					Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 0);
+				}
+	
+}
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
similarity index 100%
rename from SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
rename to SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
similarity index 100%
rename from SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
rename to SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
new file mode 100644
index 0000000..bab59fb
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
@@ -0,0 +1,146 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import java.util.HashMap;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.PaymentController;
+import org.lsmr.selfcheckout.customer.ReceiptPrinterController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.Numeral;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+import java.util.List;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+//Mohamed
+
+public class ReceiptPrinterControllerTest extends BaseTestClass{
+	
+	//declaring self checkout station
+	private SelfCheckoutStation cs;
+	
+	//declaring controllers 
+	private ReceiptPrinterController RPcontroller;
+	private PaymentController PAcontroller;
+	private ScanItemController SIcontroller;
+	private BaggingAreaController bAcontroller;
+	
+	//initializing prices of items
+	BigDecimal milkPrice = new BigDecimal(2.50);
+	BigDecimal eggPrice = new BigDecimal(4.00);
+	BigDecimal toastPrice = new BigDecimal(3.50);
+	
+	Numeral[] nMilk = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+	Numeral[] nEggs = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
+	Numeral[] nToast = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
+	
+	
+	//initalizing barcodes of the items
+	Barcode barcodeMilk = new Barcode(nMilk);
+	Barcode barcodeEggs = new Barcode(nEggs);
+	Barcode barcodeToast = new Barcode(nToast);
+	
+	
+	//declaring hashmap barcodePrice hashmap and barcodeWeight hashmap
+	private final HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
+	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
+	private final HashMap<Barcode, String> barcodeDescription = new HashMap<Barcode, String>();
+	
+	
+	//Initialize checkoutStation
+	//Create a hasMap of bar code to price
+	@Before
+	public void setup() {
+		
+		
+		super.setup();
+		cs = checkoutStation;
+		
+		
+		//initalizing price hashmap		
+		barcodePrice.put(barcodeMilk, milkPrice);	//milk
+		barcodePrice.put(barcodeEggs, eggPrice);	//eggs
+		barcodePrice.put(barcodeToast, toastPrice);	//toast
+		
+		//initalizing weight hashmap
+		barcodeWeight.put(barcodeMilk, 3.0);	//milk
+		barcodeWeight.put(barcodeEggs, 2.0);	//eggs
+		barcodeWeight.put(barcodeToast, 5.0);	//toast
+		
+		//initializng barcode description 
+		barcodeDescription.put(barcodeMilk, "Milk");	//milk
+		barcodeDescription.put(barcodeEggs, "Eggs");	//eggs
+		barcodeDescription.put(barcodeToast, "Toast");	//toast
+		
+		
+		
+		//initalizing controllers
+		SIcontroller = new ScanItemController(cs, barcodePrice, barcodeWeight);
+		PAcontroller = new PaymentController(cs);
+		RPcontroller = new ReceiptPrinterController(cs,barcodePrice, barcodeDescription);
+		bAcontroller = new BaggingAreaController(cs);
+		
+		
+		//calling object methods
+		bAcontroller.setScanItemControl(SIcontroller);
+		SIcontroller.setBagAreaControl(bAcontroller);
+		RPcontroller.setControllers(SIcontroller, PAcontroller);
+		
+	}
+	
+	public void scanError(BarcodedItem item) {
+		while (true) {
+			cs.scanner.scan(item);
+			
+			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
+				cs.scale.add(item);
+				break;
+			}
+		}
+	}
+	
+	
+	//Test if controller expected receipt match the one from the printer
+	@Test
+	public void test1() throws DisabledException, OverloadException {
+		
+	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+	
+	//Scanning Items
+	scanError(milk);
+	scanError(eggs);
+	scanError(toast);
+	
+	//Total Cost of Item is 10.00
+	PAcontroller.setValueOfCart(new BigDecimal(10));
+	
+	//Item has been paid for
+	cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+	
+	//Print the receipt
+	RPcontroller.printReceipt();
+	
+	cs.printer.cutPaper();
+	
+	//Check if controller expected receipt match the one from the printer
+	Assert.assertEquals(RPcontroller.getReceipt(), cs.printer.removeReceipt());
+	}
+	
+}
\ No newline at end of file
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
new file mode 100644
index 0000000..746fb5f
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
@@ -0,0 +1,229 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import java.util.HashMap;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.Numeral;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+import java.util.List;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+
+public class ScanItemControllerTest extends BaseTestClass{
+	
+	//declaring self checkout station
+	private SelfCheckoutStation cs;
+	
+	//declaring controllers 
+	private ScanItemController SIcontroller;
+	private BaggingAreaController bAcontroller;
+	
+	//initializing prices of items
+	BigDecimal milkPrice = new BigDecimal(2.50);
+	BigDecimal eggPrice = new BigDecimal(4.05);
+	BigDecimal toastPrice = new BigDecimal(3.50);
+	
+	Numeral[] nMilk = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+	Numeral[] nEggs = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
+	Numeral[] nToast = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
+	
+	
+	//initalizing barcodes of the items
+	Barcode barcodeMilk = new Barcode(nMilk);
+	Barcode barcodeEggs = new Barcode(nEggs);
+	Barcode barcodeToast = new Barcode(nToast);
+	
+	
+	//declaring hashmap barcodePrice hashmap and barcodeWeight hashmap
+	private HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
+	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
+	
+	//Initialize checkoutStation
+	//Create a hasMap of bar code to price
+	@Before
+	public void setup() {
+		
+		
+		super.setup();
+		cs = checkoutStation;
+		
+		
+		//initalizing price hashmap		
+		barcodePrice.put(barcodeMilk, milkPrice);	//milk
+		barcodePrice.put(barcodeEggs, eggPrice);	//eggs
+		barcodePrice.put(barcodeToast, toastPrice);	//toast
+		
+		//initalizing weight hashmap
+		barcodeWeight.put(barcodeMilk, 3.0);	//milk
+		barcodeWeight.put(barcodeEggs, 2.0);	//eggs
+		barcodeWeight.put(barcodeToast, 5.0);	//toast
+		
+		
+		//initalizing the BaggingAreaController and scanItemController
+		bAcontroller = new BaggingAreaController(cs);
+		SIcontroller = new ScanItemController(cs, barcodePrice, barcodeWeight);
+
+		//calling object methods
+		bAcontroller.setScanItemControl(SIcontroller);
+		SIcontroller.setBagAreaControl(bAcontroller);
+		
+	}
+	
+	public void scanError(BarcodedItem item) {
+		while (true) {
+			cs.scanner.scan(item);
+			
+			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
+				cs.scale.add(item);
+				break;
+			}
+		}
+	}
+	
+	
+	//Expected value of cart = 10.05
+	//Compare with the actual value of cart from the ScanItemController
+	//Initialize a scanItemController
+	@Test
+	public void test1() {
+		
+	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+	
+	
+	scanError(milk);
+	scanError(eggs);
+	scanError(toast);
+	
+
+	BigDecimal expectedValueOfCart = new BigDecimal(0);
+	expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+	expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+	expectedValueOfCart = expectedValueOfCart.add(toastPrice);
+
+	Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
+	}
+	
+	
+	//Disable the scanner
+	//Expected result - disable exception
+	//Try and scan an item while disabled
+	@Test
+	public void test2() {
+		
+		BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+		Double expectedWeightOfCart = 0.0;
+		BigDecimal expectedValueOfCart = new BigDecimal(0);
+		
+		cs.scanner.disable();
+		cs.scanner.scan(milk);
+		
+		
+		Assert.assertEquals(new BigDecimal(0), SIcontroller.getValueOfCart());
+		Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
+		
+	}
+		
+		
+	
+	//scan a valid item
+	@Test
+	public void test3() {
+		//initializing barcodedItems
+		BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+		BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+		BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+	
+		
+		Double expectedWeightOfCart = 10.0;
+		BigDecimal expectedValueOfCart = new BigDecimal(0);
+		expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+		expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+		expectedValueOfCart = expectedValueOfCart.add(toastPrice);
+		
+		scanError(milk);
+		scanError(eggs);
+		scanError(toast);
+
+		Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
+		Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
+		
+	}
+	
+	//unscans a valid item
+		@Test
+		public void unScan1() {
+			//initializing barcodedItems
+			BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+			BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+			BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+		
+			
+			Double expectedWeightOfCart = 10.0;
+			BigDecimal expectedValueOfCart = new BigDecimal(0);
+			expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+			expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+			expectedValueOfCart = expectedValueOfCart.add(toastPrice);
+			
+			scanError(milk);
+			scanError(eggs);
+			scanError(toast);
+			
+			SIcontroller.unScanItem(eggs.getBarcode());
+			
+			
+			expectedValueOfCart = expectedValueOfCart.subtract(eggPrice);
+			expectedWeightOfCart -= eggs.getWeight();
+			
+			Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
+			Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
+			
+		}
+		
+		//unscans a item not in the cart
+		@Test
+		public void unScan2() {
+			//initializing barcodedItems
+			BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+			BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+			BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+					
+			Double expectedWeightOfCart = 5.0;
+			BigDecimal expectedValueOfCart = new BigDecimal(0);
+			expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+			expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+
+			scanError(milk);
+			scanError(eggs);
+
+					
+			SIcontroller.unScanItem(toast.getBarcode());
+					
+					
+
+			Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
+			Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
+					
+		}
+				
+		
+	
+}
\ No newline at end of file
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
new file mode 100644
index 0000000..6ff92bc
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
@@ -0,0 +1,42 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import org.lsmr.selfcheckout.customer.TouchScreenController;
+
+/**
+ * Test cases for the touch screen
+ */
+public class TouchScreenControllerTest extends BaseTestClass {	
+	
+	/**
+	 * System under test
+	 */
+	TouchScreenController touchScreenController;
+	
+	@Override
+	public void setup() {
+		super.setup();
+		touchScreenController = new TouchScreenController(checkoutStation);
+	}
+
+	//Test if scanner is enabled when the user starts using the checkout station
+	@Test
+	public void testInitStart() {
+		touchScreenController.initiateStart();
+		Assert.assertFalse(checkoutStation.scanner.isDisabled());
+	}
+	
+	
+	//Test if scanner is disable and coin/banknote slot is enabled
+	//When user wishes to checkout and make payment
+	@Test
+	public void testInitCheckout() {
+		touchScreenController.inititateCheckout();
+		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+		Assert.assertFalse(checkoutStation.banknoteInput.isDisabled());
+		Assert.assertFalse(checkoutStation.coinSlot.isDisabled());
+	}
+	
+}

commit 79f1af88b85ce80b57faa65233ee3b4e9f8afc19
Merge: 6c3a9fd 4018f43
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sat Mar 26 16:42:36 2022 -0600

    Merge pull request #4 from adam-25/Ali-s-Branch
    
    My working version

commit 4018f43929a5937c7429cc2c0fd2b40a2997708a
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sat Mar 26 15:36:06 2022 -0600

    My working version
    
    No errors, replaced scanner with handheldScanner, replaced scale with, baggingArea

diff --git a/.classpath b/.classpath
index ca9b971..551aef3 100644
--- a/.classpath
+++ b/.classpath
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="SCS - Hardware - v2.0/src"/>
 	<classpathentry kind="src" path="SCS - Software - Test"/>
 	<classpathentry kind="src" path="SCS - Software"/>
diff --git a/SCS - Software - Test/.classpath b/SCS - Software - Test/.classpath
index 5c34c1e..2463441 100644
--- a/SCS - Software - Test/.classpath	
+++ b/SCS - Software - Test/.classpath	
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path=""/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
 		<attributes>
 			<attribute name="module" value="true"/>
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
index 534e709..0651259 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
@@ -307,4 +307,4 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 					Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 0);
 				}
 	
-}
+}
\ No newline at end of file
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
index bab59fb..a86832b 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
@@ -10,15 +10,13 @@ import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.customer.BaggingAreaController;
-import org.lsmr.selfcheckout.customer.PaymentController;
-import org.lsmr.selfcheckout.customer.ReceiptPrinterController;
-import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.customer.*;
+//import org.lsmr.selfcheckout.customer.PaymentController;
+//import org.lsmr.selfcheckout.customer.ReceiptPrinterController;
+//import org.lsmr.selfcheckout.customer.ScanItemController;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.Numeral;
-
 import java.math.BigDecimal;
 import java.util.Currency;
 import java.util.List;
@@ -105,10 +103,10 @@ public class ReceiptPrinterControllerTest extends BaseTestClass{
 	
 	public void scanError(BarcodedItem item) {
 		while (true) {
-			cs.scanner.scan(item);
+			cs.handheldScanner.scan(item);
 			
 			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
-				cs.scale.add(item);
+				cs.baggingArea.add(item);
 				break;
 			}
 		}
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
index 746fb5f..3757c58 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
@@ -10,8 +10,8 @@ import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.customer.BaggingAreaController;
-import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.customer.*;
+//import org.lsmr.selfcheckout.customer.ScanItemController;
 import org.lsmr.selfcheckout.devices.DisabledException;
 import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
@@ -88,10 +88,10 @@ public class ScanItemControllerTest extends BaseTestClass{
 	
 	public void scanError(BarcodedItem item) {
 		while (true) {
-			cs.scanner.scan(item);
+			cs.handheldScanner.scan(item);
 			
 			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
-				cs.scale.add(item);
+				cs.baggingArea.add(item);
 				break;
 			}
 		}
@@ -133,8 +133,8 @@ public class ScanItemControllerTest extends BaseTestClass{
 		Double expectedWeightOfCart = 0.0;
 		BigDecimal expectedValueOfCart = new BigDecimal(0);
 		
-		cs.scanner.disable();
-		cs.scanner.scan(milk);
+		cs.handheldScanner.disable();
+		cs.handheldScanner.scan(milk);
 		
 		
 		Assert.assertEquals(new BigDecimal(0), SIcontroller.getValueOfCart());
diff --git a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
index 6ff92bc..50d9cf4 100644
--- a/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
+++ b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
@@ -25,7 +25,7 @@ public class TouchScreenControllerTest extends BaseTestClass {
 	@Test
 	public void testInitStart() {
 		touchScreenController.initiateStart();
-		Assert.assertFalse(checkoutStation.scanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 	}
 	
 	
@@ -34,7 +34,7 @@ public class TouchScreenControllerTest extends BaseTestClass {
 	@Test
 	public void testInitCheckout() {
 		touchScreenController.inititateCheckout();
-		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
 		Assert.assertFalse(checkoutStation.banknoteInput.isDisabled());
 		Assert.assertFalse(checkoutStation.coinSlot.isDisabled());
 	}
diff --git a/SCS - Software/src/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
similarity index 99%
rename from SCS - Software/src/lsmr/selfcheckout/customer/BaggingAreaController.java
rename to SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index 9e592b5..825a95e 100644
--- a/SCS - Software/src/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -107,4 +107,4 @@ public class BaggingAreaController {
 	
 	
 
-}
+}
\ No newline at end of file
diff --git a/SCS - Software/src/lsmr/selfcheckout/customer/CardController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/CardController.java
similarity index 100%
rename from SCS - Software/src/lsmr/selfcheckout/customer/CardController.java
rename to SCS - Software/src/org/lsmr/selfcheckout/customer/CardController.java
diff --git a/SCS - Software/src/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
similarity index 99%
rename from SCS - Software/src/lsmr/selfcheckout/customer/PaymentController.java
rename to SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index 6f8757a..21ce61c 100644
--- a/SCS - Software/src/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -340,4 +340,4 @@ public class PaymentController{
 		
 	}
 	
-}
+}
\ No newline at end of file
diff --git a/SCS - Software/src/lsmr/selfcheckout/customer/ReceiptPrinterController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
similarity index 100%
rename from SCS - Software/src/lsmr/selfcheckout/customer/ReceiptPrinterController.java
rename to SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
diff --git a/SCS - Software/src/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
similarity index 99%
rename from SCS - Software/src/lsmr/selfcheckout/customer/ScanItemController.java
rename to SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
index 960f3e9..fe2b895 100644
--- a/SCS - Software/src/lsmr/selfcheckout/customer/ScanItemController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
@@ -129,4 +129,4 @@ public class ScanItemController  {
 		return weightOfCart;
 	}
 
-}
+}
\ No newline at end of file
diff --git a/SCS - Software/src/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
similarity index 99%
rename from SCS - Software/src/lsmr/selfcheckout/customer/TouchScreenController.java
rename to SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
index ef7fb23..8315092 100644
--- a/SCS - Software/src/lsmr/selfcheckout/customer/TouchScreenController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
@@ -32,4 +32,4 @@ public class TouchScreenController  {
 		checkoutStation.coinSlot.enable();
 		checkoutStation.banknoteInput.enable();
 	}
-}
+}
\ No newline at end of file

commit 6c3a9fd43575d10996ca2ecf23b8efeb99900946
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sat Mar 26 15:19:23 2022 -0600

    fixing folder issues

diff --git a/SCS - Software/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/lsmr/selfcheckout/customer/BaggingAreaController.java
similarity index 100%
rename from SCS - Software/org/lsmr/selfcheckout/customer/BaggingAreaController.java
rename to SCS - Software/src/lsmr/selfcheckout/customer/BaggingAreaController.java
diff --git a/SCS - Software/org/lsmr/selfcheckout/customer/CardController.java b/SCS - Software/src/lsmr/selfcheckout/customer/CardController.java
similarity index 100%
rename from SCS - Software/org/lsmr/selfcheckout/customer/CardController.java
rename to SCS - Software/src/lsmr/selfcheckout/customer/CardController.java
diff --git a/SCS - Software/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/lsmr/selfcheckout/customer/PaymentController.java
similarity index 100%
rename from SCS - Software/org/lsmr/selfcheckout/customer/PaymentController.java
rename to SCS - Software/src/lsmr/selfcheckout/customer/PaymentController.java
diff --git a/SCS - Software/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java b/SCS - Software/src/lsmr/selfcheckout/customer/ReceiptPrinterController.java
similarity index 100%
rename from SCS - Software/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
rename to SCS - Software/src/lsmr/selfcheckout/customer/ReceiptPrinterController.java
diff --git a/SCS - Software/org/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/src/lsmr/selfcheckout/customer/ScanItemController.java
similarity index 100%
rename from SCS - Software/org/lsmr/selfcheckout/customer/ScanItemController.java
rename to SCS - Software/src/lsmr/selfcheckout/customer/ScanItemController.java
diff --git a/SCS - Software/org/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/src/lsmr/selfcheckout/customer/TouchScreenController.java
similarity index 100%
rename from SCS - Software/org/lsmr/selfcheckout/customer/TouchScreenController.java
rename to SCS - Software/src/lsmr/selfcheckout/customer/TouchScreenController.java

commit ba572a0be80e30e71f9b43c3397dbbbde6d9f440
Merge: 3adc9c8 344b652
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Sat Mar 26 10:26:34 2022 -0600

    Accepting pull request

commit 344b65258116bd6584f7dd3453936b060e975ff9
Author: mohamedhefnawy1 <mohamedhefnawy10@gmail.com>
Date:   Fri Mar 25 20:38:32 2022 -0600

    implementing some things for debit, credit, membership cards

diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
index 4c49d87..6f8757a 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -1,14 +1,18 @@
 package org.lsmr.selfcheckout.customer;
 
+import java.io.IOException;
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Currency;
 import java.util.List;
 
+import org.lsmr.selfcheckout.BlockedCardException;
 import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.Card.CardData;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.BanknoteSlot;
 import org.lsmr.selfcheckout.devices.BanknoteValidator;
+import org.lsmr.selfcheckout.devices.CardReader;
 import org.lsmr.selfcheckout.devices.CoinSlot;
 import org.lsmr.selfcheckout.devices.CoinTray;
 import org.lsmr.selfcheckout.devices.CoinValidator;
@@ -16,6 +20,7 @@ import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
 import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
@@ -27,8 +32,15 @@ public class PaymentController{
 	private final SelfCheckoutStation checkoutStation; 
 	private PCC pcc;
 	private PCB pcb;
+	private CC cc;
 	private List<Coin> coinTrayList;
 	private BigDecimal initialValueOfCart;
+	private final String debit = "DEBIT";
+	private final String credit = "CREDIT";
+	private final String membership = "MEMBERSHIP";
+	public boolean verified = true;
+	private String membershipNo = null;
+	
 	
 	
 	//Customer checkout use case 
@@ -42,6 +54,7 @@ public class PaymentController{
 		//Initializing observers
 		pcc = new PCC();
 		pcb = new PCB();
+		cc = new CC();
 		
 		//Register observers in the coin related devices
 		checkoutStation.coinSlot.attach(pcc);
@@ -52,6 +65,9 @@ public class PaymentController{
 		checkoutStation.banknoteInput.attach(pcb);
 		checkoutStation.banknoteValidator.attach(pcb);
 		checkoutStation.banknoteInput.attach(pcb);
+		
+		//Registers observers in the Card related devices
+		 checkoutStation.cardReader.attach(cc);
 	}
 	
 	public BigDecimal getValueOfCart() {
@@ -67,6 +83,23 @@ public class PaymentController{
 		valueOfCart = cartValue;
 	}
 	
+	//this method is used when an invalid card is read, in the final implementation, an error would
+	//be displayed on the customer's screen and then would prompt him to select a payment option
+	public void displayError() 
+	{
+		System.out.println("an error has occured");
+		//go back to payment options
+	}
+	
+	public boolean hasMembership()
+	{
+		if(membershipNo == null)
+		{
+			return false;
+		}
+		
+		return true;
+	}
 	
 	//If all items have been paid for, return true
 	//And disable the coin and bank note slot
@@ -74,6 +107,7 @@ public class PaymentController{
 		if (valueOfCart.compareTo(new BigDecimal(0)) == -1 || valueOfCart.compareTo(new BigDecimal(0)) == 0 ) {
 			checkoutStation.coinSlot.disable();
 			checkoutStation.banknoteInput.disable();
+			checkoutStation.cardReader.disable();
 			return true;
 		}
 		return false;
@@ -171,4 +205,139 @@ public class PaymentController{
 		}
 	}
 	
+	private class CC implements CardReaderObserver {
+		
+		public boolean verifyCVV(String data)
+		{
+			return false;
+		}
+		public boolean verifyCardNumber(String data)
+		{
+			return false;
+		}
+		
+		public boolean verifyDebitCard(CardData data)
+		{
+			return verified;
+		}
+		
+		public boolean verifyCreditCard(CardData data)
+		{
+			return verified;
+		}
+		
+		public boolean verifyMembershipCard(CardData data)
+		{
+			return verified;
+		}
+	
+
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// ignore
+			
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// ignore
+			
+		}
+
+		@Override
+		public void cardInserted(CardReader reader) {
+			// ignore 
+			
+		}
+
+		@Override
+		public void cardRemoved(CardReader reader) {
+			// ignore - membership cards can only be swiped or have number manually entered.
+			
+		}
+
+		@Override
+		public void cardTapped(CardReader reader) {
+			// ignore - membership cards can only be swiped or have number manually entered.
+			
+		}
+
+		@Override
+		public void cardSwiped(CardReader reader) {
+			System.out.println("Reading card data. Please wait...");
+		
+			
+		}
+
+		@Override
+		public void cardDataRead(CardReader reader, CardData data){
+			String cardType = data.getType();
+			String cardNumber = data.getNumber();
+			String cardHolder = data.getCardholder();
+			String cardCVV = data.getCVV();
+			
+			if(cardType == null)
+			{
+					displayError();
+			}
+			
+			if(cardType == debit)
+			{
+				//review try catch logic
+				if(verifyCardNumber(cardNumber) == false || cardHolder == null || verifyCVV(cardCVV) == false)
+				{
+					displayError();
+				}
+				
+				if(verifyDebitCard(data) == true)
+				{
+					valueOfCart = new BigDecimal(0);
+					isAllItemPaid();
+				}
+				else {
+					displayError();
+				}
+				
+			}
+			
+			else if(cardType == credit)
+			{
+				//review try catch logic
+				if(verifyCardNumber(cardNumber) == false || cardHolder == null || verifyCVV(cardCVV) == false)
+				{
+					displayError();
+				}
+				
+				if(verifyCreditCard(data) == true)
+				{
+					valueOfCart = new BigDecimal(0);
+					isAllItemPaid();
+				}
+				else {
+					displayError();
+				}
+
+				
+			
+			}
+			
+			else if(cardType == membership)
+			{
+				if(cardHolder == null || verifyCardNumber(cardNumber) == false)
+				{
+					displayError();
+				}
+				if(verifyMembershipCard(data) == true)
+				{
+					membershipNo = cardNumber;
+				}
+				
+				
+			}
+			
+		}
+		
+		
+	}
+	
 }

commit c86e9b29daca30001a1812bf07039eda03a5c90a
Author: mohamedhefnawy1 <mohamedhefnawy10@gmail.com>
Date:   Fri Mar 25 19:18:42 2022 -0600

    fixing problems with controllers and baggingAreaControllerTest

diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
index 3b59cc8..534e709 100644
--- a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
@@ -46,12 +46,23 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 	Barcode barcodeItem3 = new Barcode(nItem3);
 	
 	//Method to ensure that the item scanned is actually added
-	public void scanError(BarcodedItem item) {
+	public void handheldScanError(BarcodedItem item) {
 		while (true) {
-			cs.scanner.scan(item);
+			cs.handheldScanner.scan(item);
 			
 			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
-				cs.scale.add(item);
+				cs.baggingArea.add(item);
+				break;
+			}
+		}
+	}
+	
+	public void mainScanError(BarcodedItem item) {
+		while (true) {
+			cs.mainScanner.scan(item);
+			
+			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
+				cs.baggingArea.add(item);
 				break;
 			}
 		}
@@ -97,16 +108,18 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 		BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
 		BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
 
-		Assert.assertFalse(checkoutStation.scanner.isDisabled());
+		Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+		Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
+		
 		
 		try {
-			scanError(item3);
+			mainScanError(item3);
 
-			scanError(item1);
+			mainScanError(item1);
 
-			scanError(item2);
+			mainScanError(item2);
 	
-			scanError(item3Dup1);
+			mainScanError(item3Dup1);
 
 
 			
@@ -117,7 +130,10 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 			fail();
 		}
 		
-		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
+		
+	
 	}
 	
 	//Test if the scale goes out of overload, the scanner is enabled
@@ -128,13 +144,14 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
 			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
 
-			Assert.assertFalse(checkoutStation.scanner.isDisabled());
+			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 			
 			try {
-				scanError(item3);
-				scanError(item1);
-				scanError(item2);
-				scanError(item3Dup1);
+				mainScanError(item3);
+				mainScanError(item1);
+				mainScanError(item2);
+				mainScanError(item3Dup1);
 			} catch(Exception e) {
 				//shouldn't each here
 				System.out.println("not supposed to occur");
@@ -143,17 +160,19 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 			}
 			
 			
-			Assert.assertTrue(checkoutStation.scanner.isDisabled());
+			Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+			Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
 			
 			try {
-				checkoutStation.scale.remove(item3);
+				checkoutStation.baggingArea.remove(item3);
 			} catch(Exception e) {
 				//shouldn't each here
 				System.out.println("not supposed to occur");
 				e.printStackTrace();
 				fail();
 			}
-			Assert.assertFalse(checkoutStation.scanner.isDisabled());
+			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 			Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
 		}
 	
@@ -161,34 +180,39 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 	//Test if scanner is disabled if there is a weight discrepancy
 	//test one item with a discrepancy in the weight that is larger
 
+	//double check to see if test logic is sound
 	@Test
 	public void testWeightChanged1() {
 		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 400.0);
 		
 		try {
-			scanError(item1);
+			mainScanError(item1);
 		} catch (Exception e) {
 			System.out.println("Shouldn't happen");
 			fail();
 		}
 		
-		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
 	}
 	
 	//Test if scanner is disabled if there is a weight discrepancy
 	//test 1 item with a discrepancy in the weight that is less
+	
+	//double check to see if test logic is sound
 	@Test
 	public void testWeightChanged2() {
 		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 200.0);
 
 		try {
-			scanError(item1);
+			mainScanError(item1);
 		} catch (Exception e) {
 			System.out.println("Shouldn't happen");
 			fail();
 		}
 		
-		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+		Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+		Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
 	}
 	
 	//Test if scanner is disabled if there is a weight discrepancy
@@ -199,14 +223,15 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 			BarcodedItem item1Dup1 = new BarcodedItem(barcodeItem1, 400.0);
 
 			try {
-				scanError(item1);
-				scanError(item1Dup1);
+				mainScanError(item1);
+				mainScanError(item1Dup1);
 			} catch (Exception e) {
 				System.out.println("Shouldn't happen");
 				fail();
 			}
 			
-			Assert.assertTrue(checkoutStation.scanner.isDisabled());
+			Assert.assertTrue(checkoutStation.mainScanner.isDisabled());
+			Assert.assertTrue(checkoutStation.handheldScanner.isDisabled());
 		}
 	
 		//Test to see that when an item is removed the controller knows and adjusts the number in the cart
@@ -217,13 +242,13 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
 			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
 
-			Assert.assertFalse(checkoutStation.scanner.isDisabled());
+			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
 			
 			try {
-				scanError(item3);
-				scanError(item1);
-				scanError(item2);
-				scanError(item3Dup1);
+				mainScanError(item3);
+				mainScanError(item1);
+				mainScanError(item2);
+				mainScanError(item3Dup1);
 				
 			} catch(Exception e) {
 				//shouldn't each here
@@ -234,12 +259,13 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
 			
 			try {
-				checkoutStation.scale.remove(item3Dup1);
+				checkoutStation.baggingArea.remove(item3Dup1);
 			} catch (Exception e) {
 				fail();
 			}
 			
-			Assert.assertFalse(checkoutStation.scanner.isDisabled());
+			Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+			Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
 		}
 		
@@ -251,12 +277,13 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 					BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
 
 
-					Assert.assertFalse(checkoutStation.scanner.isDisabled());
+					Assert.assertFalse(checkoutStation.mainScanner.isDisabled());
+					Assert.assertFalse(checkoutStation.handheldScanner.isDisabled());
 					
 					try {
-						scanError(item3);
-						scanError(item1);
-						scanError(item2);
+						mainScanError(item3);
+						mainScanError(item1);
+						mainScanError(item2);
 
 						
 					} catch(Exception e) {
@@ -269,9 +296,9 @@ public class BaggingAreaControllerTest extends BaseTestClass {
 					Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
 					
 					try {
-						checkoutStation.scale.remove(item2);
-						checkoutStation.scale.remove(item3);
-						checkoutStation.scale.remove(item1);
+						checkoutStation.baggingArea.remove(item2);
+						checkoutStation.baggingArea.remove(item3);
+						checkoutStation.baggingArea.remove(item1);
 					} catch (Exception e) {
 						fail();
 					}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
index cb9bc31..9e592b5 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -27,7 +27,7 @@ public class BaggingAreaController {
 		
 		
 		//Register observers to the scanner
-		checkoutStation.scale.attach(bac);
+		checkoutStation.baggingArea.attach(bac);
 		
 	}
 	
@@ -73,9 +73,11 @@ public class BaggingAreaController {
 			//If expected weight of cart (determined by scanner)
 			//Is the same of actual weigh of cart (determined by electronic scale)
 			if(scanItemControl.getWeightOfCart() == weightOfCart) {
-				checkoutStation.scanner.enable();
+				checkoutStation.mainScanner.enable();
+				checkoutStation.handheldScanner.enable();
 			}else {
-				checkoutStation.scanner.disable();
+				checkoutStation.mainScanner.disable();
+				checkoutStation.handheldScanner.disable();
 			}
 			
 		}
@@ -83,13 +85,15 @@ public class BaggingAreaController {
 		//Disable bar code scanner
 		@Override
 		public void overload(ElectronicScale scale) {
-			checkoutStation.scanner.disable();
+			checkoutStation.mainScanner.disable();
+			checkoutStation.handheldScanner.disable();
 		}
 
 		//Enable bar code scanner
 		@Override
 		public void outOfOverload(ElectronicScale scale) {
-			checkoutStation.scanner.enable();	
+			checkoutStation.mainScanner.enable();	
+			checkoutStation.handheldScanner.enable();
 		}
 		
 	}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/CardController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/CardController.java
new file mode 100644
index 0000000..f23b444
--- /dev/null
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/CardController.java	
@@ -0,0 +1,70 @@
+package org.lsmr.selfcheckout.customer;
+
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.CardReader;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+
+public class CardController {
+	private final SelfCheckoutStation checkoutStation;
+	private MCC mcc;
+	
+	//constructor
+	public CardController(SelfCheckoutStation cs) {
+	checkoutStation = cs;
+	mcc = new MCC();
+	
+	//Register observers to the scanner
+	checkoutStation.cardReader.attach(mcc);
+	}
+	
+	private class MCC implements CardReaderObserver {
+
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// TODO Auto-generated method stub
+			
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// TODO Auto-generated method stub
+			
+		}
+
+		@Override
+		public void cardInserted(CardReader reader) {
+			// ignore - membership cards can only be swiped or have number manually entered.
+			
+		}
+
+		@Override
+		public void cardRemoved(CardReader reader) {
+			// ignore - membership cards can only be swiped or have number manually entered.
+			
+		}
+
+		@Override
+		public void cardTapped(CardReader reader) {
+			// ignore - membership cards can only be swiped or have number manually entered.
+			
+		}
+
+		@Override
+		public void cardSwiped(CardReader reader) {
+			System.out.println("Reading card data. Please wait...");
+		
+			
+		}
+
+		@Override
+		public void cardDataRead(CardReader reader, CardData data) {
+			String cardType = data.getType();
+			String cardNumber = data.getNumber();
+		}
+		
+		
+	}
+}
\ No newline at end of file
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
index 4674b9d..960f3e9 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
@@ -41,7 +41,8 @@ public class ScanItemController  {
 		
 		
 		//Register observers in the scanner
-		checkoutStation.scanner.attach(sic);
+		checkoutStation.mainScanner.attach(sic);
+		checkoutStation.handheldScanner.attach(sic);
 		
 	}
 	
@@ -72,7 +73,8 @@ public class ScanItemController  {
 		valueOfCart = valueOfCart.subtract(barcodePrice.get(barcode));
 		
 		if(bagAreaControl.getWeightOfCart() == weightOfCart) {
-			checkoutStation.scanner.enable();
+			checkoutStation.mainScanner.enable();
+			checkoutStation.handheldScanner.enable();
 		}
 	}
 	
@@ -93,7 +95,7 @@ public class ScanItemController  {
 		//Update the value of the cart
 		@Override
 		public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
-			if(weightOfCart + barcodeWeight.get(barcode) <= checkoutStation.scale.getWeightLimit()) {
+			if(weightOfCart + barcodeWeight.get(barcode) <= checkoutStation.baggingArea.getWeightLimit()) {
 				weightOfCart = weightOfCart + barcodeWeight.get(barcode);	
 			}
 
@@ -105,9 +107,12 @@ public class ScanItemController  {
 			//If expected weight of cart (determined by scanner)
 			//Is not the same of actual weigh of cart (determined by electronic scale)
 			if(bagAreaControl.getWeightOfCart() != weightOfCart) {
-				checkoutStation.scanner.disable();
+				checkoutStation.mainScanner.disable();
+				checkoutStation.handheldScanner.disable();
+				
 			}else {
-				checkoutStation.scanner.enable();
+				checkoutStation.mainScanner.enable();
+				checkoutStation.handheldScanner.enable();
 			}
 			
 			
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
index 8af1db6..ef7fb23 100644
--- a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
@@ -19,14 +19,16 @@ public class TouchScreenController  {
 	 * Enables the scanner to allow the user to begin scanning items.
 	 */
 	public void initiateStart() {
-		checkoutStation.scanner.enable();
+		checkoutStation.mainScanner.enable();
+		checkoutStation.handheldScanner.enable();
 	}
 	
 	/**
 	 * To be triggered after all items are scanned. Disables scanner and allows the user to pay with cash.
 	 */
 	public void inititateCheckout() {
-		checkoutStation.scanner.disable();
+		checkoutStation.mainScanner.disable();
+		checkoutStation.handheldScanner.disable();
 		checkoutStation.coinSlot.enable();
 		checkoutStation.banknoteInput.enable();
 	}

commit 0a3e07662523a148558ea9fb1771032b1cc2d2d7
Author: Sean Grewal <seangwall1@gmail.com>
Date:   Fri Mar 25 18:30:27 2022 -0600

    First commit

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..e10e727
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+/.metadata/
diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/SCS - Hardware - v2.0/bin/.gitignore	
@@ -0,0 +1 @@
+/org/
diff --git a/SCS - Software - Test/.classpath b/SCS - Software - Test/.classpath
index 11f6e20..5c34c1e 100644
--- a/SCS - Software - Test/.classpath	
+++ b/SCS - Software - Test/.classpath	
@@ -7,7 +7,7 @@
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
 	<classpathentry kind="src" path="/SCS - Software"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/SCS - Hardware - v2.0"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/SCS - Software/.classpath b/SCS - Software/.classpath
index 79a8207..18d16d4 100644
--- a/SCS - Software/.classpath	
+++ b/SCS - Software/.classpath	
@@ -6,6 +6,6 @@
 			<attribute name="module" value="true"/>
 		</attributes>
 	</classpathentry>
-	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
+	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/SCS - Hardware - v2.0"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

commit 3adc9c8c2f4c0afdd328a45b27ded4cf0e21da59
Merge: d8946fc 47c4685
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Fri Mar 25 13:44:02 2022 -0600

    Merge pull request #1 from adam-25/adarsh
    
    Project SetUp with scanner problem

commit 47c4685c66118b0b186beee1678d7e08cb342e6a
Author: adam-25 <adarsh.dudhat11@gmail.com>
Date:   Fri Mar 25 11:42:57 2022 -0600

    Project SetUp with scanner problem

diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 0000000..763da7e
Binary files /dev/null and b/.DS_Store differ
diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..ca9b971
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="SCS - Hardware - v2.0/src"/>
+	<classpathentry kind="src" path="SCS - Software - Test"/>
+	<classpathentry kind="src" path="SCS - Software"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-17">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.project b/.project
index a5f71c3..112d158 100644
--- a/.project
+++ b/.project
@@ -1,11 +1,17 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>SENG-300-Project</name>
+	<name>SCS - Software - v2.0</name>
 	<comment></comment>
 	<projects>
 	</projects>
 	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 	</buildSpec>
 	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
 </projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..8c9943d
--- /dev/null
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,14 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=17
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=17
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
+org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.source=17
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..fbeedc4
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+# Demo
\ No newline at end of file
diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/SCS - Hardware - v2.0/bin/.gitignore	
@@ -0,0 +1 @@
+/org/
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
similarity index 100%
rename from SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
rename to SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
similarity index 100%
rename from SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
rename to SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
similarity index 100%
rename from SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
rename to SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
similarity index 100%
rename from SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
rename to SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
similarity index 100%
rename from SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
rename to SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java b/SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
similarity index 100%
rename from SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
rename to SCS - Software - Test/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/org/lsmr/selfcheckout/customer/BaggingAreaController.java
similarity index 100%
rename from SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
rename to SCS - Software/org/lsmr/selfcheckout/customer/BaggingAreaController.java
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/org/lsmr/selfcheckout/customer/PaymentController.java
similarity index 100%
rename from SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
rename to SCS - Software/org/lsmr/selfcheckout/customer/PaymentController.java
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java b/SCS - Software/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
similarity index 100%
rename from SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
rename to SCS - Software/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/org/lsmr/selfcheckout/customer/ScanItemController.java
similarity index 100%
rename from SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
rename to SCS - Software/org/lsmr/selfcheckout/customer/ScanItemController.java
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/org/lsmr/selfcheckout/customer/TouchScreenController.java
similarity index 100%
rename from SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
rename to SCS - Software/org/lsmr/selfcheckout/customer/TouchScreenController.java
diff --git a/bin/.classpath b/bin/.classpath
new file mode 100644
index 0000000..11f6e20
--- /dev/null
+++ b/bin/.classpath
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
+	<classpathentry kind="src" path="/SCS - Software"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/bin/.gitignore b/bin/.gitignore
new file mode 100644
index 0000000..ae3c172
--- /dev/null
+++ b/bin/.gitignore
@@ -0,0 +1 @@
+/bin/
diff --git a/bin/.project b/bin/.project
new file mode 100644
index 0000000..5fa7496
--- /dev/null
+++ b/bin/.project
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Software - Test</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1647387659432</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..0416eb6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..464a475
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..de7368f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..0342831
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..3a5a24b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..b1844b6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..38d5704
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..c51bac1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..7ca0563
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..f4aaf48
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..55e3cde
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..ecf0201
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..9a7fdaa
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..a3468c5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..f3ef20e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..fa00a27
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..eec7e69
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..22ee588
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..b22f856
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class b/bin/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class
new file mode 100644
index 0000000..75b8729
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/BaggingAreaController$BAC.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/BaggingAreaController.class b/bin/org/lsmr/selfcheckout/customer/BaggingAreaController.class
new file mode 100644
index 0000000..887b0bb
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/BaggingAreaController.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/PaymentController$PCB.class b/bin/org/lsmr/selfcheckout/customer/PaymentController$PCB.class
new file mode 100644
index 0000000..913c32f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/PaymentController$PCB.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/PaymentController$PCC.class b/bin/org/lsmr/selfcheckout/customer/PaymentController$PCC.class
new file mode 100644
index 0000000..6fdf95c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/PaymentController$PCC.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/PaymentController.class b/bin/org/lsmr/selfcheckout/customer/PaymentController.class
new file mode 100644
index 0000000..da1b4c5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/PaymentController.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class b/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class
new file mode 100644
index 0000000..bfee6c8
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController$RPC.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class b/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class
new file mode 100644
index 0000000..c6335cb
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/ReceiptPrinterController.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class b/bin/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class
new file mode 100644
index 0000000..91624d9
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/ScanItemController$SIC.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/ScanItemController.class b/bin/org/lsmr/selfcheckout/customer/ScanItemController.class
new file mode 100644
index 0000000..f68aaf8
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/ScanItemController.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/TouchScreenController.class b/bin/org/lsmr/selfcheckout/customer/TouchScreenController.class
new file mode 100644
index 0000000..ef0102b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/TouchScreenController.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class
new file mode 100644
index 0000000..f500f7c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/BaseTestClass.class b/bin/org/lsmr/selfcheckout/customer/testing/BaseTestClass.class
new file mode 100644
index 0000000..0542cbe
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/testing/BaseTestClass.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class
new file mode 100644
index 0000000..16c8ab8
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class
new file mode 100644
index 0000000..aeb5157
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class
new file mode 100644
index 0000000..6c0acb5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class b/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class
new file mode 100644
index 0000000..4dc002d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..f66cc1a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..7135fa4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..45c016e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..34485ac
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..79a1500
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..9af0ff3
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..c008572
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..1b0049f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..adfe35a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..bc75481
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..e949320
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..b06c85d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..4fa1b4f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..91f3706
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..efb117c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..160c02e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..bc15df2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..7a295ba
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..877ad17
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..c8cb670
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..962fb88
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..026d948
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..a3cbbad
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..253e7f6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..4f0bdb9
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..4dc61ad
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..185b861
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..dcb2f02
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..a89eead
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..2671b9f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..2f6bb87
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..7c4bb1e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..1718764
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..9283409
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..3b00362
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..da91d12
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..bf26991
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..817e5dc
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..cfcc4eb
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..f4d748e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..9e96845
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..674708f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..2c232ee
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..e0f34c2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/Product.class differ

commit d8946fcfd167979d99b3ac19872dbc52b8884664
Author: adam-25 <adarsh.dudhat11@gmail.com>
Date:   Thu Mar 24 18:51:27 2022 -0600

    Revert "demo"
    
    This reverts commit 9ac96290bcdf72b6a62b66e65d52be5a971225ff.

diff --git a/.DS_Store b/.DS_Store
deleted file mode 100644
index 4643f86..0000000
Binary files a/.DS_Store and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
deleted file mode 100644
index cf1db2e..0000000
--- a/SCS - Hardware - v2.0/bin/.gitignore	
+++ /dev/null
@@ -1 +0,0 @@
-/org/
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..fbc21cf
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..5cea197
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..2d68447
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..536dd3d
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..795e5b4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..a2d7141
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..a72d8a2
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..8efccff
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..262b944
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..fa389c2
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..67690f1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..be8be69
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..c08cda6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..69e38c1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..0f8b1e6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..ac8cc6e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..941940c
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..0884227
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..8d9b145
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..1dae3ed
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..aff6c5e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..9043506
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..a829b5d
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..f18b4a4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..21d4eff
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..a42c54f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..093246f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..8ae0603
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..1a090b0
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..d069691
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..db8f809
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..db1e2c4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6f49c78
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..1dee7ec
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..5c66261
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..867d7c6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..b23e858
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..dc98a0f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..7db53cc
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..bc15cfc
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..ce0e2cd
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..4db506b
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..d3f9e65
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..d616ae5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..964485e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..3b3f3af
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..ef277e1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..8fa6c54
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..dbec2ad
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..b779d7e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..3ef8e5f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..21606de
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..7910341
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..bd71242
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..b922285
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..1391af5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..b11003b
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..6bf0d70
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..9cd53cf
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..ef726bb
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..ffd7621
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..80746e5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..b3888c1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class differ

commit 9ac96290bcdf72b6a62b66e65d52be5a971225ff
Author: adam-25 <adarsh.dudhat11@gmail.com>
Date:   Thu Mar 24 18:48:51 2022 -0600

    demo

diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 0000000..4643f86
Binary files /dev/null and b/.DS_Store differ
diff --git a/SCS - Hardware - v2.0/bin/.gitignore b/SCS - Hardware - v2.0/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/SCS - Hardware - v2.0/bin/.gitignore	
@@ -0,0 +1 @@
+/org/
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class
deleted file mode 100644
index fbc21cf..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class
deleted file mode 100644
index 5cea197..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
deleted file mode 100644
index 2d68447..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
deleted file mode 100644
index 536dd3d..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class
deleted file mode 100644
index 795e5b4..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
deleted file mode 100644
index a2d7141..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
deleted file mode 100644
index a72d8a2..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
deleted file mode 100644
index 8efccff..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class
deleted file mode 100644
index 262b944..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
deleted file mode 100644
index fa389c2..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class
deleted file mode 100644
index 67690f1..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
deleted file mode 100644
index be8be69..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
deleted file mode 100644
index c08cda6..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class
deleted file mode 100644
index 69e38c1..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
deleted file mode 100644
index 0f8b1e6..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class
deleted file mode 100644
index ac8cc6e..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
deleted file mode 100644
index 941940c..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
deleted file mode 100644
index 0884227..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class
deleted file mode 100644
index 8d9b145..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
deleted file mode 100644
index 1dae3ed..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
deleted file mode 100644
index aff6c5e..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
deleted file mode 100644
index 9043506..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
deleted file mode 100644
index a829b5d..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
deleted file mode 100644
index f18b4a4..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
deleted file mode 100644
index 21d4eff..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
deleted file mode 100644
index a42c54f..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
deleted file mode 100644
index 093246f..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
deleted file mode 100644
index 8ae0603..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
deleted file mode 100644
index 1a090b0..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
deleted file mode 100644
index d069691..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
deleted file mode 100644
index db8f809..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
deleted file mode 100644
index db1e2c4..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
deleted file mode 100644
index 6f49c78..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
deleted file mode 100644
index 1dee7ec..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
deleted file mode 100644
index 5c66261..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
deleted file mode 100644
index 867d7c6..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
deleted file mode 100644
index b23e858..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
deleted file mode 100644
index dc98a0f..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
deleted file mode 100644
index 7db53cc..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
deleted file mode 100644
index bc15cfc..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
deleted file mode 100644
index ce0e2cd..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
deleted file mode 100644
index 4db506b..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
deleted file mode 100644
index d3f9e65..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
deleted file mode 100644
index d616ae5..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
deleted file mode 100644
index 964485e..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
deleted file mode 100644
index 3b3f3af..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
deleted file mode 100644
index ef277e1..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
deleted file mode 100644
index 8fa6c54..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
deleted file mode 100644
index dbec2ad..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
deleted file mode 100644
index b779d7e..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
deleted file mode 100644
index 3ef8e5f..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
deleted file mode 100644
index 21606de..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
deleted file mode 100644
index 7910341..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
deleted file mode 100644
index bd71242..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
deleted file mode 100644
index b922285..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
deleted file mode 100644
index 1391af5..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
deleted file mode 100644
index b11003b..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
deleted file mode 100644
index 6bf0d70..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
deleted file mode 100644
index 9cd53cf..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
deleted file mode 100644
index ef726bb..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
deleted file mode 100644
index ffd7621..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
deleted file mode 100644
index 80746e5..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class and /dev/null differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class
deleted file mode 100644
index b3888c1..0000000
Binary files a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class and /dev/null differ

commit 61f094733fe6e6e90ebe79c7851c88d193de8e6d
Merge: 89741bc fcc3d05
Author: Simon Vincent <47257674+SmonVincent@users.noreply.github.com>
Date:   Thu Mar 24 17:16:07 2022 -0600

    Merge branch 'main' of https://github.com/adam-25/SENG-300-Iteration--2

commit 89741bceaef8ac414efa567c7bfd5b27b95de0a9
Author: Simon Vincent <47257674+SmonVincent@users.noreply.github.com>
Date:   Thu Mar 24 17:15:47 2022 -0600

    updated codebase

diff --git a/Explaination_Page.pdf b/Explaination_Page.pdf
deleted file mode 100644
index 4d06b0e..0000000
--- a/Explaination_Page.pdf
+++ /dev/null
@@ -1,23 +0,0 @@
-Team 1:
-    ● Fu-Yin Lin
-    ● Ryan McHale
-    ● Karim Kassouri
-    ● Munhib Saad
-    ● Parker Wieck
-    ● Muhammad Ali
-    ● Ayomide Alabi
-
-Store.java contains functions that will likely be useful for later releases. However, given that it
-covers material irrelevant to iteration 1, only the relevant sections have been tested. The main
-section that is excluded has to do with PLU codes.
-
-The use case related to “Customer wishes to checkout” appears to rely on hardware simulations
-not yet implemented. We have given an example of what this may look like in the
-commented-out method “touchScreenButtonPressed()” within the
-SelfCheckoutStationLogic.java file. This function was Ayomide Alabi’s contribution, they did not
-push the change themselves due to technical difficulties.
-
-Finally, the test “scanPlaceMismatchWithinSensitivity” interacts with the underlying hardware
-simulation and includes a random chance of failure. If this test fails, please rerun the test a few
-times.
-
\ No newline at end of file
diff --git a/SCS - Hardware - v1.0/bin/.gitignore b/SCS - Hardware - v1.0/bin/.gitignore
deleted file mode 100644
index cf1db2e..0000000
--- a/SCS - Hardware - v1.0/bin/.gitignore	
+++ /dev/null
@@ -1 +0,0 @@
-/org/
diff --git a/SCS - Hardware - v1.0/.classpath b/SCS - Hardware - v2.0/.classpath
similarity index 100%
rename from SCS - Hardware - v1.0/.classpath
rename to SCS - Hardware - v2.0/.classpath
diff --git a/SCS - Hardware - v1.0/.project b/SCS - Hardware - v2.0/.project
similarity index 50%
rename from SCS - Hardware - v1.0/.project
rename to SCS - Hardware - v2.0/.project
index 1471a55..b29667f 100644
--- a/SCS - Hardware - v1.0/.project	
+++ b/SCS - Hardware - v2.0/.project	
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>SCS - Hardware - v1.0</name>
+	<name>SCS - Hardware - v2.0</name>
 	<comment></comment>
 	<projects>
 	</projects>
@@ -14,15 +14,4 @@
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
-	<filteredResources>
-		<filter>
-			<id>1647387659416</id>
-			<name></name>
-			<type>30</type>
-			<matcher>
-				<id>org.eclipse.core.resources.regexFilterMatcher</id>
-				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
-			</matcher>
-		</filter>
-	</filteredResources>
 </projectDescription>
diff --git a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs
similarity index 100%
rename from SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
rename to SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..fbc21cf
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..5cea197
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..2d68447
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..536dd3d
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..795e5b4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..a2d7141
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..a72d8a2
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..8efccff
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..262b944
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..fa389c2
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..67690f1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..be8be69
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..c08cda6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..69e38c1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..0f8b1e6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..ac8cc6e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..941940c
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..0884227
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..8d9b145
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..1dae3ed
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..aff6c5e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..9043506
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..a829b5d
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..f18b4a4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..21d4eff
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..a42c54f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..093246f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..8ae0603
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..1a090b0
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..d069691
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..db8f809
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..db1e2c4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6f49c78
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..1dee7ec
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..5c66261
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..867d7c6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..b23e858
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..dc98a0f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..7db53cc
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..bc15cfc
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..ce0e2cd
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..4db506b
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..d3f9e65
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..d616ae5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..964485e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..3b3f3af
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..ef277e1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..8fa6c54
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..dbec2ad
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..b779d7e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..3ef8e5f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..21606de
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..7910341
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..bd71242
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..b922285
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..1391af5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..b11003b
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..6bf0d70
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..9cd53cf
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..ef726bb
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..ffd7621
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..80746e5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..b3888c1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
similarity index 98%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
index fc32c76..56323a2 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
@@ -73,7 +73,7 @@ public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObs
 	}
 
 	/**
-	 * Connects input and output channels to the banknote validator. Causes no events.
+	 * Connects input and output channels to the banknote slot. Causes no events.
 	 * <p>
 	 * This operation is permissible only during the configuration phase.
 	 * 
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
similarity index 99%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
index f444162..47b43a8 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
@@ -221,7 +221,7 @@ public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> i
 			}
 			else {
 				try {
-					rejectionSink.deliver(coin);
+					overflowSink.deliver(coin);
 				}
 				catch(OverloadException e) {
 					// Should never happen
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
similarity index 61%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
index f6c0b47..844e0c8 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
@@ -1,6 +1,7 @@
 package org.lsmr.selfcheckout.devices;
 
 import java.util.ArrayList;
+import java.util.Random;
 
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
@@ -16,7 +17,8 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 
 	/**
 	 * Constructs an electronic scale with the indicated maximum weight that it can
-	 * handle before going into overload.
+	 * handle before going into overload. The constructed scale will initially be in
+	 * the configuration phase.
 	 * 
 	 * @param weightLimitInGrams
 	 *            The weight threshold beyond which the scale will overload.
@@ -28,19 +30,20 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	 */
 	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
 		if(weightLimitInGrams <= 0)
-			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
+			throw new SimulationException("The maximum weight cannot be zero or less.");
 
 		if(sensitivity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
+			throw new SimulationException("The sensitivity cannot be zero or less.");
 
 		this.weightLimitInGrams = weightLimitInGrams;
 		this.sensitivity = sensitivity;
 	}
 
 	/**
-	 * Gets the weight limit for the scale.
+	 * Gets the weight limit for the scale. Weights greater than this will not be
+	 * weighable by the scale, but will cause overload.
 	 * <p>
-	 * This operation is permissible during the configuration phase.
+	 * This operation is permissible during all phases.
 	 * 
 	 * @return The weight limit.
 	 */
@@ -51,22 +54,24 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	/**
 	 * Gets the current weight on the scale.
 	 * <p>
-	 * This operation is not permissible during the configuration phase.
+	 * This operation is not permissible during the configuration or error phases.
 	 * 
 	 * @return The current weight.
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
 	 * @throws OverloadException
 	 *             If the weight has overloaded the scale.
 	 */
 	public double getCurrentWeight() throws OverloadException {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
 			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
 
 		if(currentWeightInGrams <= weightLimitInGrams)
-			return currentWeightInGrams;
+			return currentWeightInGrams + new Random().nextDouble() / 10.0;
 
 		throw new OverloadException();
 	}
@@ -75,7 +80,7 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
 	 * noticed or announced.
 	 * <p>
-	 * This operation is permissible during the configuration phase.
+	 * This operation is permissible during all phases.
 	 * 
 	 * @return The sensitivity.
 	 */
@@ -84,53 +89,65 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	}
 
 	/**
-	 * Adds an item to the scale.
+	 * Adds an item to the scale. If the addition is successful, a weight changed
+	 * event is announced. If the weight is greater than the weight limit, an
+	 * overload event is announced.
 	 * <p>
-	 * This operation is not permissible during the configuration phase.
+	 * This operation is not permissible during the configuration or error phase.
 	 * 
 	 * @param item
 	 *            The item to add.
 	 * @throws SimulationException
-	 *             If the same item is added more than once.
+	 *             If the same item is added more than once or is null.
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
 	 */
 	public void add(Item item) {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
 			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
+
+		if(item == null)
+			throw new SimulationException("Null is not a valid item.");
 
 		if(items.contains(item))
 			throw new SimulationException("The same item cannot be added more than once to the scale.");
-
+		
 		currentWeightInGrams += item.getWeight();
 
 		items.add(item);
 
 		if(currentWeightInGrams > weightLimitInGrams)
 			notifyOverload();
-		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
+
+		if(Math.abs(currentWeightInGrams - weightAtLastEvent) > sensitivity)
 			notifyWeightChanged();
 	}
 
 	/**
-	 * Removes an item from the scale.
+	 * Removes an item from the scale. If the operation is successful, a weight
+	 * changed event is announced. If the scale was overloaded and this removal
+	 * causes it to no longer be overloaded, an out of overload event is announced.
 	 * <p>
-	 * This operation is not permissible during the configuration phase.
+	 * This operation is not permissible during the configuration or error phases.
 	 * 
 	 * @param item
 	 *            The item to remove.
 	 * @throws SimulationException
-	 *             If the item is not on the scale.
+	 *             If the item is not on the scale (including if it is null).
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
 	 */
 	public void remove(Item item) {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
 			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
 
 		if(!items.remove(item))
 			throw new SimulationException("The item was not found amongst those on the scale.");
@@ -146,7 +163,7 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
 			notifyOutOfOverload();
 
-		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
+		if(currentWeightInGrams <= weightLimitInGrams && Math.abs(original - currentWeightInGrams) > sensitivity)
 			notifyWeightChanged();
 	}
 
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
similarity index 91%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
index 0356dd2..ff66327 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
@@ -19,11 +19,11 @@ import org.lsmr.selfcheckout.Coin;
  * A self-checkout possesses the following units of hardware that the customer
  * can see and interact with:
  * <ul>
- * <li>one electronic scale, with a configurable maximum weight before it
- * overloads;</li>
+ * <li>two electronic scales, with a configurable maximum weight before it
+ * overloads, one for the bagging area and one for the scanning area;</li>
  * <li>one receipt printer;</li>
  * <li>one card reader;</li>
- * <li>one scanner;</li>
+ * <li>two scanners (the main one and the handheld one);</li>
  * <li>one input slot for banknotes;</li>
  * <li>one output slot for banknotes;</li>
  * <li>one input slot for coins;</li>
@@ -88,10 +88,11 @@ import org.lsmr.selfcheckout.Coin;
  * operations).
  */
 public class SelfCheckoutStation {
-	public final ElectronicScale scale;
+	public final ElectronicScale baggingArea, scanningArea;
 	public final ReceiptPrinter printer;
 	public final CardReader cardReader;
-	public final BarcodeScanner scanner;
+	public final BarcodeScanner mainScanner;
+	public final BarcodeScanner handheldScanner;
 
 	public final BanknoteSlot banknoteInput, banknoteOutput;
 	public final BanknoteValidator banknoteValidator;
@@ -151,10 +152,12 @@ public class SelfCheckoutStation {
 				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
 
 		// Create the devices.
-		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		baggingArea = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		scanningArea = new ElectronicScale(scaleMaximumWeight / 10 + 1, scaleSensitivity);
 		printer = new ReceiptPrinter();
 		cardReader = new CardReader();
-		scanner = new BarcodeScanner();
+		mainScanner = new BarcodeScanner();
+		handheldScanner = new BarcodeScanner();
 
 		this.banknoteDenominations = banknoteDenominations;
 		banknoteInput = new BanknoteSlot(false);
@@ -191,10 +194,12 @@ public class SelfCheckoutStation {
 		for(CoinDispenser coinDispenser : coinDispensers.values())
 			interconnect(coinDispenser, coinTray);
 
-		scale.endConfigurationPhase();
+		baggingArea.endConfigurationPhase();
+		scanningArea.endConfigurationPhase();
 		printer.endConfigurationPhase();
 		cardReader.endConfigurationPhase();
-		scanner.endConfigurationPhase();
+		mainScanner.endConfigurationPhase();
+		handheldScanner.endConfigurationPhase();
 
 		banknoteInput.endConfigurationPhase();
 		banknoteValidator.endConfigurationPhase();
@@ -206,6 +211,7 @@ public class SelfCheckoutStation {
 
 		coinSlot.endConfigurationPhase();
 		coinValidator.endConfigurationPhase();
+		// coinStorage.enable();
 		coinStorage.endConfigurationPhase();
 		coinTray.endConfigurationPhase();
 
@@ -215,6 +221,16 @@ public class SelfCheckoutStation {
 
 	private BidirectionalChannel<Banknote> validatorSource;
 
+	private boolean supervised = false;
+
+	boolean isSupervised() {
+		return supervised;
+	}
+
+	void setSupervised(boolean isSupervised) {
+		supervised = isSupervised;
+	}
+
 	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
 		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
 		slot.connect(validatorSource);
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
similarity index 69%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
index 794b53a..e8f166c 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
@@ -11,6 +11,7 @@ import org.lsmr.selfcheckout.devices.SimulationException;
 public class BarcodedProduct extends Product {
 	private final Barcode barcode;
 	private final String description;
+	private final double expectedWeightInGrams;
 
 	/**
 	 * Create a product.
@@ -21,12 +22,16 @@ public class BarcodedProduct extends Product {
 	 *            The description of the product.
 	 * @param price
 	 *            The price per-unit of the product.
+	 * @param expectedWeightInGrams
+	 *            The expected weight of each item of this product.
 	 * @throws SimulationException
 	 *             If any argument is null.
 	 * @throws SimulationException
 	 *             If the price is &le;0.
+	 * @throws IllegalArgumentException
+	 *             If the expected weight is &le;0.
 	 */
-	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price, double expectedWeightInGrams) {
 		super(price, true);
 
 		if(barcode == null)
@@ -35,8 +40,12 @@ public class BarcodedProduct extends Product {
 		if(description == null)
 			throw new SimulationException(new NullPointerException("description is null"));
 
+		if(expectedWeightInGrams <= 0.0)
+			throw new IllegalArgumentException("Products have to have a positive expected weight.");
+		
 		this.barcode = barcode;
 		this.description = description;
+		this.expectedWeightInGrams = expectedWeightInGrams;
 	}
 
 	/**
@@ -56,4 +65,13 @@ public class BarcodedProduct extends Product {
 	public String getDescription() {
 		return description;
 	}
+
+	/**
+	 * Get the expected weight.
+	 * 
+	 * @return The expected weight in grams.
+	 */
+	public double getExpectedWeight() {
+		return expectedWeightInGrams;
+	}
 }
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java

commit fcc3d058f213fd5bc5c4111e24cc4b2cb5cc7d5a
Author: mohamedhefnawy1 <mohamedhefnawy10@gmail.com>
Date:   Thu Mar 24 16:59:38 2022 -0600

    SCS-Hardware-v2.0 addition and deletion of v1.0

diff --git a/SCS - Hardware - v1.0/bin/.gitignore b/SCS - Hardware - v1.0/bin/.gitignore
deleted file mode 100644
index cf1db2e..0000000
--- a/SCS - Hardware - v1.0/bin/.gitignore	
+++ /dev/null
@@ -1 +0,0 @@
-/org/
diff --git a/SCS - Hardware - v1.0/.classpath b/SCS - Hardware - v2.0/.classpath
similarity index 100%
rename from SCS - Hardware - v1.0/.classpath
rename to SCS - Hardware - v2.0/.classpath
diff --git a/SCS - Hardware - v1.0/.project b/SCS - Hardware - v2.0/.project
similarity index 50%
rename from SCS - Hardware - v1.0/.project
rename to SCS - Hardware - v2.0/.project
index 1471a55..b29667f 100644
--- a/SCS - Hardware - v1.0/.project	
+++ b/SCS - Hardware - v2.0/.project	
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>SCS - Hardware - v1.0</name>
+	<name>SCS - Hardware - v2.0</name>
 	<comment></comment>
 	<projects>
 	</projects>
@@ -14,15 +14,4 @@
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
-	<filteredResources>
-		<filter>
-			<id>1647387659416</id>
-			<name></name>
-			<type>30</type>
-			<matcher>
-				<id>org.eclipse.core.resources.regexFilterMatcher</id>
-				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
-			</matcher>
-		</filter>
-	</filteredResources>
 </projectDescription>
diff --git a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs
similarity index 100%
rename from SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
rename to SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..fbc21cf
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..5cea197
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..2d68447
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..536dd3d
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..795e5b4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..a2d7141
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..a72d8a2
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..8efccff
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..262b944
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..fa389c2
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..67690f1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..be8be69
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..c08cda6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..69e38c1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..0f8b1e6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..ac8cc6e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..941940c
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..0884227
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..8d9b145
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..1dae3ed
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..aff6c5e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..9043506
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..a829b5d
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..f18b4a4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..21d4eff
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..a42c54f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..093246f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..8ae0603
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..1a090b0
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..d069691
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..db8f809
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..db1e2c4
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6f49c78
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..1dee7ec
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..5c66261
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..867d7c6
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..b23e858
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..dc98a0f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..7db53cc
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..bc15cfc
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..ce0e2cd
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..4db506b
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..d3f9e65
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..d616ae5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..964485e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..3b3f3af
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..ef277e1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..8fa6c54
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..dbec2ad
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..b779d7e
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..3ef8e5f
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..21606de
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..7910341
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..bd71242
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..b922285
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..1391af5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..b11003b
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..6bf0d70
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..9cd53cf
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..ef726bb
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..ffd7621
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..80746e5
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..b3888c1
Binary files /dev/null and b/SCS - Hardware - v2.0/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
similarity index 98%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
index fc32c76..56323a2 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
@@ -73,7 +73,7 @@ public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObs
 	}
 
 	/**
-	 * Connects input and output channels to the banknote validator. Causes no events.
+	 * Connects input and output channels to the banknote slot. Causes no events.
 	 * <p>
 	 * This operation is permissible only during the configuration phase.
 	 * 
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
similarity index 99%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
index f444162..47b43a8 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
@@ -221,7 +221,7 @@ public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> i
 			}
 			else {
 				try {
-					rejectionSink.deliver(coin);
+					overflowSink.deliver(coin);
 				}
 				catch(OverloadException e) {
 					// Should never happen
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
similarity index 61%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
index f6c0b47..844e0c8 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
@@ -1,6 +1,7 @@
 package org.lsmr.selfcheckout.devices;
 
 import java.util.ArrayList;
+import java.util.Random;
 
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
@@ -16,7 +17,8 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 
 	/**
 	 * Constructs an electronic scale with the indicated maximum weight that it can
-	 * handle before going into overload.
+	 * handle before going into overload. The constructed scale will initially be in
+	 * the configuration phase.
 	 * 
 	 * @param weightLimitInGrams
 	 *            The weight threshold beyond which the scale will overload.
@@ -28,19 +30,20 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	 */
 	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
 		if(weightLimitInGrams <= 0)
-			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
+			throw new SimulationException("The maximum weight cannot be zero or less.");
 
 		if(sensitivity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
+			throw new SimulationException("The sensitivity cannot be zero or less.");
 
 		this.weightLimitInGrams = weightLimitInGrams;
 		this.sensitivity = sensitivity;
 	}
 
 	/**
-	 * Gets the weight limit for the scale.
+	 * Gets the weight limit for the scale. Weights greater than this will not be
+	 * weighable by the scale, but will cause overload.
 	 * <p>
-	 * This operation is permissible during the configuration phase.
+	 * This operation is permissible during all phases.
 	 * 
 	 * @return The weight limit.
 	 */
@@ -51,22 +54,24 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	/**
 	 * Gets the current weight on the scale.
 	 * <p>
-	 * This operation is not permissible during the configuration phase.
+	 * This operation is not permissible during the configuration or error phases.
 	 * 
 	 * @return The current weight.
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
 	 * @throws OverloadException
 	 *             If the weight has overloaded the scale.
 	 */
 	public double getCurrentWeight() throws OverloadException {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
 			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
 
 		if(currentWeightInGrams <= weightLimitInGrams)
-			return currentWeightInGrams;
+			return currentWeightInGrams + new Random().nextDouble() / 10.0;
 
 		throw new OverloadException();
 	}
@@ -75,7 +80,7 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
 	 * noticed or announced.
 	 * <p>
-	 * This operation is permissible during the configuration phase.
+	 * This operation is permissible during all phases.
 	 * 
 	 * @return The sensitivity.
 	 */
@@ -84,53 +89,65 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	}
 
 	/**
-	 * Adds an item to the scale.
+	 * Adds an item to the scale. If the addition is successful, a weight changed
+	 * event is announced. If the weight is greater than the weight limit, an
+	 * overload event is announced.
 	 * <p>
-	 * This operation is not permissible during the configuration phase.
+	 * This operation is not permissible during the configuration or error phase.
 	 * 
 	 * @param item
 	 *            The item to add.
 	 * @throws SimulationException
-	 *             If the same item is added more than once.
+	 *             If the same item is added more than once or is null.
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
 	 */
 	public void add(Item item) {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
 			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
+
+		if(item == null)
+			throw new SimulationException("Null is not a valid item.");
 
 		if(items.contains(item))
 			throw new SimulationException("The same item cannot be added more than once to the scale.");
-
+		
 		currentWeightInGrams += item.getWeight();
 
 		items.add(item);
 
 		if(currentWeightInGrams > weightLimitInGrams)
 			notifyOverload();
-		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
+
+		if(Math.abs(currentWeightInGrams - weightAtLastEvent) > sensitivity)
 			notifyWeightChanged();
 	}
 
 	/**
-	 * Removes an item from the scale.
+	 * Removes an item from the scale. If the operation is successful, a weight
+	 * changed event is announced. If the scale was overloaded and this removal
+	 * causes it to no longer be overloaded, an out of overload event is announced.
 	 * <p>
-	 * This operation is not permissible during the configuration phase.
+	 * This operation is not permissible during the configuration or error phases.
 	 * 
 	 * @param item
 	 *            The item to remove.
 	 * @throws SimulationException
-	 *             If the item is not on the scale.
+	 *             If the item is not on the scale (including if it is null).
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
 	 */
 	public void remove(Item item) {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
 			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
 
 		if(!items.remove(item))
 			throw new SimulationException("The item was not found amongst those on the scale.");
@@ -146,7 +163,7 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
 			notifyOutOfOverload();
 
-		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
+		if(currentWeightInGrams <= weightLimitInGrams && Math.abs(original - currentWeightInGrams) > sensitivity)
 			notifyWeightChanged();
 	}
 
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
similarity index 91%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
index 0356dd2..ff66327 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
@@ -19,11 +19,11 @@ import org.lsmr.selfcheckout.Coin;
  * A self-checkout possesses the following units of hardware that the customer
  * can see and interact with:
  * <ul>
- * <li>one electronic scale, with a configurable maximum weight before it
- * overloads;</li>
+ * <li>two electronic scales, with a configurable maximum weight before it
+ * overloads, one for the bagging area and one for the scanning area;</li>
  * <li>one receipt printer;</li>
  * <li>one card reader;</li>
- * <li>one scanner;</li>
+ * <li>two scanners (the main one and the handheld one);</li>
  * <li>one input slot for banknotes;</li>
  * <li>one output slot for banknotes;</li>
  * <li>one input slot for coins;</li>
@@ -88,10 +88,11 @@ import org.lsmr.selfcheckout.Coin;
  * operations).
  */
 public class SelfCheckoutStation {
-	public final ElectronicScale scale;
+	public final ElectronicScale baggingArea, scanningArea;
 	public final ReceiptPrinter printer;
 	public final CardReader cardReader;
-	public final BarcodeScanner scanner;
+	public final BarcodeScanner mainScanner;
+	public final BarcodeScanner handheldScanner;
 
 	public final BanknoteSlot banknoteInput, banknoteOutput;
 	public final BanknoteValidator banknoteValidator;
@@ -151,10 +152,12 @@ public class SelfCheckoutStation {
 				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
 
 		// Create the devices.
-		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		baggingArea = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		scanningArea = new ElectronicScale(scaleMaximumWeight / 10 + 1, scaleSensitivity);
 		printer = new ReceiptPrinter();
 		cardReader = new CardReader();
-		scanner = new BarcodeScanner();
+		mainScanner = new BarcodeScanner();
+		handheldScanner = new BarcodeScanner();
 
 		this.banknoteDenominations = banknoteDenominations;
 		banknoteInput = new BanknoteSlot(false);
@@ -191,10 +194,12 @@ public class SelfCheckoutStation {
 		for(CoinDispenser coinDispenser : coinDispensers.values())
 			interconnect(coinDispenser, coinTray);
 
-		scale.endConfigurationPhase();
+		baggingArea.endConfigurationPhase();
+		scanningArea.endConfigurationPhase();
 		printer.endConfigurationPhase();
 		cardReader.endConfigurationPhase();
-		scanner.endConfigurationPhase();
+		mainScanner.endConfigurationPhase();
+		handheldScanner.endConfigurationPhase();
 
 		banknoteInput.endConfigurationPhase();
 		banknoteValidator.endConfigurationPhase();
@@ -206,6 +211,7 @@ public class SelfCheckoutStation {
 
 		coinSlot.endConfigurationPhase();
 		coinValidator.endConfigurationPhase();
+		// coinStorage.enable();
 		coinStorage.endConfigurationPhase();
 		coinTray.endConfigurationPhase();
 
@@ -215,6 +221,16 @@ public class SelfCheckoutStation {
 
 	private BidirectionalChannel<Banknote> validatorSource;
 
+	private boolean supervised = false;
+
+	boolean isSupervised() {
+		return supervised;
+	}
+
+	void setSupervised(boolean isSupervised) {
+		supervised = isSupervised;
+	}
+
 	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
 		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
 		slot.connect(validatorSource);
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
similarity index 69%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
index 794b53a..e8f166c 100644
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
@@ -11,6 +11,7 @@ import org.lsmr.selfcheckout.devices.SimulationException;
 public class BarcodedProduct extends Product {
 	private final Barcode barcode;
 	private final String description;
+	private final double expectedWeightInGrams;
 
 	/**
 	 * Create a product.
@@ -21,12 +22,16 @@ public class BarcodedProduct extends Product {
 	 *            The description of the product.
 	 * @param price
 	 *            The price per-unit of the product.
+	 * @param expectedWeightInGrams
+	 *            The expected weight of each item of this product.
 	 * @throws SimulationException
 	 *             If any argument is null.
 	 * @throws SimulationException
 	 *             If the price is &le;0.
+	 * @throws IllegalArgumentException
+	 *             If the expected weight is &le;0.
 	 */
-	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price, double expectedWeightInGrams) {
 		super(price, true);
 
 		if(barcode == null)
@@ -35,8 +40,12 @@ public class BarcodedProduct extends Product {
 		if(description == null)
 			throw new SimulationException(new NullPointerException("description is null"));
 
+		if(expectedWeightInGrams <= 0.0)
+			throw new IllegalArgumentException("Products have to have a positive expected weight.");
+		
 		this.barcode = barcode;
 		this.description = description;
+		this.expectedWeightInGrams = expectedWeightInGrams;
 	}
 
 	/**
@@ -56,4 +65,13 @@ public class BarcodedProduct extends Product {
 	public String getDescription() {
 		return description;
 	}
+
+	/**
+	 * Get the expected weight.
+	 * 
+	 * @return The expected weight in grams.
+	 */
+	public double getExpectedWeight() {
+		return expectedWeightInGrams;
+	}
 }
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java
similarity index 100%
rename from SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
rename to SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java

commit 7040350748d920d7118b11fe2852f30e7f3f1c6c
Merge: c5da154 c294272
Author: mohamedhefnawy1 <mohamedhefnawy10@gmail.com>
Date:   Thu Mar 24 16:57:33 2022 -0600

    Merge branch 'main' of https://github.com/adam-25/SENG-300-Iteration--2

commit c5da1541f8a0a06beba8fccbf7f7f3d8415cab14
Author: mohamedhefnawy1 <mohamedhefnawy10@gmail.com>
Date:   Thu Mar 24 16:57:28 2022 -0600

    codebase

diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index a1c2a23..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,23 +0,0 @@
-# Compiled class file
-*.class
-
-# Log file
-*.log
-
-# BlueJ files
-*.ctxt
-
-# Mobile Tools for Java (J2ME)
-.mtj.tmp/
-
-# Package Files #
-*.jar
-*.war
-*.nar
-*.ear
-*.zip
-*.tar.gz
-*.rar
-
-# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
-hs_err_pid*
diff --git a/.project b/.project
new file mode 100644
index 0000000..a5f71c3
--- /dev/null
+++ b/.project
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SENG-300-Project</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+	</buildSpec>
+	<natures>
+	</natures>
+</projectDescription>
diff --git a/Hello.txt b/Hello.txt
new file mode 100644
index 0000000..d2fa803
--- /dev/null
+++ b/Hello.txt
@@ -0,0 +1,6 @@
+Ayodeji
+Mohamed Elhefnawy
+Andrew Barnett
+Kevin Thai
+Mellisa Phongsa
+MAahmood Rafae Ghumman
\ No newline at end of file
diff --git a/README.md b/README.md
deleted file mode 100644
index 5007727..0000000
--- a/README.md
+++ /dev/null
@@ -1 +0,0 @@
-# SENG-300-Iteration--2
\ No newline at end of file
diff --git a/SCS - Hardware - v2.0/.classpath b/SCS - Hardware - v1.0/.classpath
similarity index 100%
rename from SCS - Hardware - v2.0/.classpath
rename to SCS - Hardware - v1.0/.classpath
diff --git a/SCS - Hardware - v2.0/.project b/SCS - Hardware - v1.0/.project
similarity index 50%
rename from SCS - Hardware - v2.0/.project
rename to SCS - Hardware - v1.0/.project
index b29667f..1471a55 100644
--- a/SCS - Hardware - v2.0/.project	
+++ b/SCS - Hardware - v1.0/.project	
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>SCS - Hardware - v2.0</name>
+	<name>SCS - Hardware - v1.0</name>
 	<comment></comment>
 	<projects>
 	</projects>
@@ -14,4 +14,15 @@
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
+	<filteredResources>
+		<filter>
+			<id>1647387659416</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
 </projectDescription>
diff --git a/SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
similarity index 100%
rename from SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs
rename to SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
diff --git a/SCS - Hardware - v1.0/bin/.gitignore b/SCS - Hardware - v1.0/bin/.gitignore
new file mode 100644
index 0000000..cf1db2e
--- /dev/null
+++ b/SCS - Hardware - v1.0/bin/.gitignore	
@@ -0,0 +1 @@
+/org/
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
similarity index 98%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
index 56323a2..fc32c76 100644
--- a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
@@ -73,7 +73,7 @@ public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObs
 	}
 
 	/**
-	 * Connects input and output channels to the banknote slot. Causes no events.
+	 * Connects input and output channels to the banknote validator. Causes no events.
 	 * <p>
 	 * This operation is permissible only during the configuration phase.
 	 * 
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
similarity index 99%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
index 47b43a8..f444162 100644
--- a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
@@ -221,7 +221,7 @@ public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> i
 			}
 			else {
 				try {
-					overflowSink.deliver(coin);
+					rejectionSink.deliver(coin);
 				}
 				catch(OverloadException e) {
 					// Should never happen
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
similarity index 61%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
index 844e0c8..f6c0b47 100644
--- a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
@@ -1,7 +1,6 @@
 package org.lsmr.selfcheckout.devices;
 
 import java.util.ArrayList;
-import java.util.Random;
 
 import org.lsmr.selfcheckout.Item;
 import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
@@ -17,8 +16,7 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 
 	/**
 	 * Constructs an electronic scale with the indicated maximum weight that it can
-	 * handle before going into overload. The constructed scale will initially be in
-	 * the configuration phase.
+	 * handle before going into overload.
 	 * 
 	 * @param weightLimitInGrams
 	 *            The weight threshold beyond which the scale will overload.
@@ -30,20 +28,19 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	 */
 	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
 		if(weightLimitInGrams <= 0)
-			throw new SimulationException("The maximum weight cannot be zero or less.");
+			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
 
 		if(sensitivity <= 0)
-			throw new SimulationException("The sensitivity cannot be zero or less.");
+			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
 
 		this.weightLimitInGrams = weightLimitInGrams;
 		this.sensitivity = sensitivity;
 	}
 
 	/**
-	 * Gets the weight limit for the scale. Weights greater than this will not be
-	 * weighable by the scale, but will cause overload.
+	 * Gets the weight limit for the scale.
 	 * <p>
-	 * This operation is permissible during all phases.
+	 * This operation is permissible during the configuration phase.
 	 * 
 	 * @return The weight limit.
 	 */
@@ -54,24 +51,22 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	/**
 	 * Gets the current weight on the scale.
 	 * <p>
-	 * This operation is not permissible during the configuration or error phases.
+	 * This operation is not permissible during the configuration phase.
 	 * 
 	 * @return The current weight.
-	 * @throws SimulationException
-	 *             If this operation is called during the configuration or error
-	 *             phases.
 	 * @throws OverloadException
 	 *             If the weight has overloaded the scale.
 	 */
 	public double getCurrentWeight() throws OverloadException {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(
-				"This method may not be used when the device is in an erroneous operation phase.");
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
 		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException("This method may not be called during the configuration phase.");
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
 
 		if(currentWeightInGrams <= weightLimitInGrams)
-			return currentWeightInGrams + new Random().nextDouble() / 10.0;
+			return currentWeightInGrams;
 
 		throw new OverloadException();
 	}
@@ -80,7 +75,7 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
 	 * noticed or announced.
 	 * <p>
-	 * This operation is permissible during all phases.
+	 * This operation is permissible during the configuration phase.
 	 * 
 	 * @return The sensitivity.
 	 */
@@ -89,65 +84,53 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 	}
 
 	/**
-	 * Adds an item to the scale. If the addition is successful, a weight changed
-	 * event is announced. If the weight is greater than the weight limit, an
-	 * overload event is announced.
+	 * Adds an item to the scale.
 	 * <p>
-	 * This operation is not permissible during the configuration or error phase.
+	 * This operation is not permissible during the configuration phase.
 	 * 
 	 * @param item
 	 *            The item to add.
 	 * @throws SimulationException
-	 *             If the same item is added more than once or is null.
-	 * @throws SimulationException
-	 *             If this operation is called during the configuration or error
-	 *             phases.
+	 *             If the same item is added more than once.
 	 */
 	public void add(Item item) {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(
-				"This method may not be used when the device is in an erroneous operation phase.");
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
 		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException("This method may not be called during the configuration phase.");
-
-		if(item == null)
-			throw new SimulationException("Null is not a valid item.");
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
 
 		if(items.contains(item))
 			throw new SimulationException("The same item cannot be added more than once to the scale.");
-		
+
 		currentWeightInGrams += item.getWeight();
 
 		items.add(item);
 
 		if(currentWeightInGrams > weightLimitInGrams)
 			notifyOverload();
-
-		if(Math.abs(currentWeightInGrams - weightAtLastEvent) > sensitivity)
+		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
 			notifyWeightChanged();
 	}
 
 	/**
-	 * Removes an item from the scale. If the operation is successful, a weight
-	 * changed event is announced. If the scale was overloaded and this removal
-	 * causes it to no longer be overloaded, an out of overload event is announced.
+	 * Removes an item from the scale.
 	 * <p>
-	 * This operation is not permissible during the configuration or error phases.
+	 * This operation is not permissible during the configuration phase.
 	 * 
 	 * @param item
 	 *            The item to remove.
 	 * @throws SimulationException
-	 *             If the item is not on the scale (including if it is null).
-	 * @throws SimulationException
-	 *             If this operation is called during the configuration or error
-	 *             phases.
+	 *             If the item is not on the scale.
 	 */
 	public void remove(Item item) {
 		if(phase == Phase.ERROR)
-			throw new SimulationException(
-				"This method may not be used when the device is in an erroneous operation phase.");
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
 		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException("This method may not be called during the configuration phase.");
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
 
 		if(!items.remove(item))
 			throw new SimulationException("The item was not found amongst those on the scale.");
@@ -163,7 +146,7 @@ public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
 		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
 			notifyOutOfOverload();
 
-		if(currentWeightInGrams <= weightLimitInGrams && Math.abs(original - currentWeightInGrams) > sensitivity)
+		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
 			notifyWeightChanged();
 	}
 
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
similarity index 91%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
index ff66327..0356dd2 100644
--- a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
@@ -19,11 +19,11 @@ import org.lsmr.selfcheckout.Coin;
  * A self-checkout possesses the following units of hardware that the customer
  * can see and interact with:
  * <ul>
- * <li>two electronic scales, with a configurable maximum weight before it
- * overloads, one for the bagging area and one for the scanning area;</li>
+ * <li>one electronic scale, with a configurable maximum weight before it
+ * overloads;</li>
  * <li>one receipt printer;</li>
  * <li>one card reader;</li>
- * <li>two scanners (the main one and the handheld one);</li>
+ * <li>one scanner;</li>
  * <li>one input slot for banknotes;</li>
  * <li>one output slot for banknotes;</li>
  * <li>one input slot for coins;</li>
@@ -88,11 +88,10 @@ import org.lsmr.selfcheckout.Coin;
  * operations).
  */
 public class SelfCheckoutStation {
-	public final ElectronicScale baggingArea, scanningArea;
+	public final ElectronicScale scale;
 	public final ReceiptPrinter printer;
 	public final CardReader cardReader;
-	public final BarcodeScanner mainScanner;
-	public final BarcodeScanner handheldScanner;
+	public final BarcodeScanner scanner;
 
 	public final BanknoteSlot banknoteInput, banknoteOutput;
 	public final BanknoteValidator banknoteValidator;
@@ -152,12 +151,10 @@ public class SelfCheckoutStation {
 				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
 
 		// Create the devices.
-		baggingArea = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
-		scanningArea = new ElectronicScale(scaleMaximumWeight / 10 + 1, scaleSensitivity);
+		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
 		printer = new ReceiptPrinter();
 		cardReader = new CardReader();
-		mainScanner = new BarcodeScanner();
-		handheldScanner = new BarcodeScanner();
+		scanner = new BarcodeScanner();
 
 		this.banknoteDenominations = banknoteDenominations;
 		banknoteInput = new BanknoteSlot(false);
@@ -194,12 +191,10 @@ public class SelfCheckoutStation {
 		for(CoinDispenser coinDispenser : coinDispensers.values())
 			interconnect(coinDispenser, coinTray);
 
-		baggingArea.endConfigurationPhase();
-		scanningArea.endConfigurationPhase();
+		scale.endConfigurationPhase();
 		printer.endConfigurationPhase();
 		cardReader.endConfigurationPhase();
-		mainScanner.endConfigurationPhase();
-		handheldScanner.endConfigurationPhase();
+		scanner.endConfigurationPhase();
 
 		banknoteInput.endConfigurationPhase();
 		banknoteValidator.endConfigurationPhase();
@@ -211,7 +206,6 @@ public class SelfCheckoutStation {
 
 		coinSlot.endConfigurationPhase();
 		coinValidator.endConfigurationPhase();
-		// coinStorage.enable();
 		coinStorage.endConfigurationPhase();
 		coinTray.endConfigurationPhase();
 
@@ -221,16 +215,6 @@ public class SelfCheckoutStation {
 
 	private BidirectionalChannel<Banknote> validatorSource;
 
-	private boolean supervised = false;
-
-	boolean isSupervised() {
-		return supervised;
-	}
-
-	void setSupervised(boolean isSupervised) {
-		supervised = isSupervised;
-	}
-
 	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
 		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
 		slot.connect(validatorSource);
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
similarity index 69%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
index e8f166c..794b53a 100644
--- a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
@@ -11,7 +11,6 @@ import org.lsmr.selfcheckout.devices.SimulationException;
 public class BarcodedProduct extends Product {
 	private final Barcode barcode;
 	private final String description;
-	private final double expectedWeightInGrams;
 
 	/**
 	 * Create a product.
@@ -22,16 +21,12 @@ public class BarcodedProduct extends Product {
 	 *            The description of the product.
 	 * @param price
 	 *            The price per-unit of the product.
-	 * @param expectedWeightInGrams
-	 *            The expected weight of each item of this product.
 	 * @throws SimulationException
 	 *             If any argument is null.
 	 * @throws SimulationException
 	 *             If the price is &le;0.
-	 * @throws IllegalArgumentException
-	 *             If the expected weight is &le;0.
 	 */
-	public BarcodedProduct(Barcode barcode, String description, BigDecimal price, double expectedWeightInGrams) {
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
 		super(price, true);
 
 		if(barcode == null)
@@ -40,12 +35,8 @@ public class BarcodedProduct extends Product {
 		if(description == null)
 			throw new SimulationException(new NullPointerException("description is null"));
 
-		if(expectedWeightInGrams <= 0.0)
-			throw new IllegalArgumentException("Products have to have a positive expected weight.");
-		
 		this.barcode = barcode;
 		this.description = description;
-		this.expectedWeightInGrams = expectedWeightInGrams;
 	}
 
 	/**
@@ -65,13 +56,4 @@ public class BarcodedProduct extends Product {
 	public String getDescription() {
 		return description;
 	}
-
-	/**
-	 * Get the expected weight.
-	 * 
-	 * @return The expected weight in grams.
-	 */
-	public double getExpectedWeight() {
-		return expectedWeightInGrams;
-	}
 }
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
similarity index 100%
rename from SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java
rename to SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
diff --git a/SCS - Software - Test/.classpath b/SCS - Software - Test/.classpath
index 7dc8995..11f6e20 100644
--- a/SCS - Software - Test/.classpath	
+++ b/SCS - Software - Test/.classpath	
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-16">
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
 		<attributes>
 			<attribute name="module" value="true"/>
 		</attributes>
 	</classpathentry>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
 	<classpathentry kind="src" path="/SCS - Software"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/SCS - Software - Test/.project b/SCS - Software - Test/.project
index 14704e1..5fa7496 100644
--- a/SCS - Software - Test/.project	
+++ b/SCS - Software - Test/.project	
@@ -3,8 +3,6 @@
 	<name>SCS - Software - Test</name>
 	<comment></comment>
 	<projects>
-		<project>SCS - Hardware - v1.0</project>
-		<project>SCS - Software</project>
 	</projects>
 	<buildSpec>
 		<buildCommand>
@@ -16,4 +14,15 @@
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
+	<filteredResources>
+		<filter>
+			<id>1647387659432</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
 </projectDescription>
diff --git a/SCS - Software - Test/.settings/org.eclipse.jdt.core.prefs b/SCS - Software - Test/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index 8aabe8d..0000000
--- a/SCS - Software - Test/.settings/org.eclipse.jdt.core.prefs	
+++ /dev/null
@@ -1,14 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=16
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=16
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
-org.eclipse.jdt.core.compiler.release=enabled
-org.eclipse.jdt.core.compiler.source=16
diff --git a/SCS - Software - Test/src/SelfCheckoutStationLogicTests.java b/SCS - Software - Test/src/SelfCheckoutStationLogicTests.java
deleted file mode 100644
index 334b585..0000000
--- a/SCS - Software - Test/src/SelfCheckoutStationLogicTests.java	
+++ /dev/null
@@ -1,296 +0,0 @@
-import static org.junit.Assert.*;
-
-import java.math.BigDecimal;
-import java.util.ArrayList;
-import java.util.Currency;
-import java.util.Locale;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.Numeral;
-
-import org.lsmr.selfcheckout.devices.BarcodeScanner;
-import org.lsmr.selfcheckout.devices.DisabledException;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-import org.lsmr.selfcheckout.devices.OverloadException;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.BarcodedProduct;
-
-import Control.SelfCheckoutStationLogic;
-import Control.Store;
-
-/**
- * Test Suite for Self-Checkout Station Logic.
- * 
- * @author Fu-Yin Lin
- * @author Ryan McHale
- * @author Karim Kassouri
- * @author Munhib Saad
- * @author Parker Wieck
- * @author Muhammad Ali
- * @author Ayomide Alabi
- *
- */
-public class SelfCheckoutStationLogicTests {
-
-	private Currency validCurrency;
-	private Currency invalidCurrency;
-	private int banknoteDenominations[] = { 5, 10, 20, 50, 100 };
-	private BigDecimal coinDenominations[] = { BigDecimal.valueOf(0.05), BigDecimal.valueOf(0.10),
-			BigDecimal.valueOf(0.25), BigDecimal.valueOf(1.00), BigDecimal.valueOf(2.00) };
-	private SelfCheckoutStation selfCheckoutStation;
-	private SelfCheckoutStationLogic selfCheckoutStationLogic;
-	private Store store;
-
-	private ElectronicScale testES;
-	private Item heavyItem;
-	private Item normalItem;
-	private Item lightItem;
-
-	BarcodedItem barcodedLightItem;
-	BarcodedItem barcodedNormalItem;
-	BarcodedItem barcodedHeavyItem;
-
-	private class ItemStub extends Item {
-
-		protected ItemStub(double weightInGrams) {
-			super(weightInGrams);
-		}
-
-	}
-
-	@Before
-	public void setUp() {
-		validCurrency = Currency.getInstance("CAD");
-		invalidCurrency = Currency.getInstance("USD");
-		selfCheckoutStation = new SelfCheckoutStation(validCurrency, banknoteDenominations, coinDenominations, 100, 1);
-		store = new Store(3, 3);
-
-		Numeral numerals1[] = { Numeral.valueOf((byte) 1) };
-		Numeral numerals2[] = { Numeral.valueOf((byte) 2) };
-		Numeral numerals3[] = { Numeral.valueOf((byte) 3) };
-
-		Barcode barcode1 = new Barcode(numerals1);
-		Barcode barcode2 = new Barcode(numerals2);
-		Barcode barcode3 = new Barcode(numerals3);
-
-		barcodedLightItem = new BarcodedItem(barcode1, 1);
-		barcodedNormalItem = new BarcodedItem(barcode2, 1);
-		barcodedHeavyItem = new BarcodedItem(barcode3, 1);
-
-		BarcodedItem barcodedItems[] = { barcodedLightItem, barcodedNormalItem, barcodedHeavyItem };
-
-		BarcodedProduct barcodedProducts[] = { new BarcodedProduct(barcode1, "foo", BigDecimal.ONE),
-				new BarcodedProduct(barcode1, "bar", BigDecimal.ONE),
-				new BarcodedProduct(barcode1, "foobar", BigDecimal.ONE) };
-
-		store.barcodeConfigure(barcodedItems, barcodedProducts);
-
-		selfCheckoutStationLogic = new SelfCheckoutStationLogic(selfCheckoutStation, store);
-
-		testES = new ElectronicScale(5, 2);
-		heavyItem = new ItemStub(10);
-		normalItem = new ItemStub(2);
-		lightItem = new ItemStub(1);
-	}
-
-	///////////////////////////////////////////////////////
-	// GENERAL TESTS
-	///////////////////////////////////////////////////////
-
-	@Test(expected = SimulationException.class)
-	public void constructor_error_test() {
-		SelfCheckoutStationLogic scsl = new SelfCheckoutStationLogic(null, null);
-	}
-
-	@Test(expected = SimulationException.class)
-	public void constructor_error_test_2() {
-		SelfCheckoutStationLogic scsl = new SelfCheckoutStationLogic(selfCheckoutStation, null);
-	}
-
-	@Test
-	public void enabled_disabled_test() throws DisabledException {
-		selfCheckoutStation.banknoteValidator.enable();
-		selfCheckoutStation.banknoteValidator.disable();
-		// success
-	}
-
-	///////////////////////////////////////////////////////
-	// PAYMENT TESTS
-	///////////////////////////////////////////////////////
-
-	@Test
-	public void validBanknoteDetected_test() throws DisabledException, OverloadException {
-		Banknote banknote = new Banknote(validCurrency, 5);
-		selfCheckoutStation.banknoteInput.accept(banknote);
-		assertTrue(selfCheckoutStationLogic.getTotalPayment() == 5);
-	}
-
-	@Test
-	public void invalidBanknoteDetected_test() throws DisabledException, OverloadException {
-		Banknote banknote = new Banknote(invalidCurrency, 5);
-		selfCheckoutStation.banknoteInput.accept(banknote);
-		assertTrue(selfCheckoutStationLogic.getTotalPayment() == 0);
-
-	}
-
-	@Test
-	public void validCoinDetected_test() throws DisabledException, OverloadException {
-		Coin coin = new Coin(validCurrency, BigDecimal.valueOf(0.05));
-		selfCheckoutStation.coinSlot.accept(coin);
-		assertTrue(selfCheckoutStationLogic.getTotalPayment() == 0.05);
-
-	}
-
-	@Test
-	public void invalidCoinDetected_test() throws DisabledException, OverloadException {
-		Coin coin = new Coin(invalidCurrency, BigDecimal.valueOf(0.05));
-		selfCheckoutStation.coinSlot.accept(coin);
-		assertTrue(selfCheckoutStationLogic.getTotalPayment() == 0);
-
-	}
-
-	@Test
-	public void printRecipt_test() throws DisabledException, OverloadException {
-		selfCheckoutStationLogic.printReceipt();
-	}
-
-	////////////////
-	// BAGGING TESTS
-	///////////////
-
-	@Test(expected = OverloadException.class)
-	public void overload_test() throws OverloadException {
-		heavyItem = new ItemStub(999);
-		selfCheckoutStation.scale.add(heavyItem);
-
-		selfCheckoutStation.scale.getCurrentWeight();
-
-	}
-
-	@Test
-	public void outOfOverload_test() throws OverloadException {
-		heavyItem = new ItemStub(999);
-		selfCheckoutStation.scale.add(heavyItem);
-
-		selfCheckoutStation.scale.remove(heavyItem);
-
-		assertTrue(selfCheckoutStation.scale.getCurrentWeight() == 0);
-	}
-
-	@Test
-	public void normalItemAdded_noItemExpected() throws OverloadException {
-		selfCheckoutStation.scale.add(normalItem);
-
-		assertTrue(selfCheckoutStation.scale.getCurrentWeight() == normalItem.getWeight());
-	}
-
-	@Test
-	public void scanPlaceMismatchWithinSensitivity() throws OverloadException {
-
-		selfCheckoutStation.scanner.scan(barcodedLightItem);
-
-		selfCheckoutStation.scale.add(normalItem);
-
-		assertFalse(selfCheckoutStationLogic.getWaitForAttendant());
-	}
-
-	@Test
-	public void printRecipt() {
-		selfCheckoutStation.scanner.scan(barcodedLightItem);
-
-		selfCheckoutStation.scale.add(lightItem);
-
-		selfCheckoutStation.printer.addPaper(100);
-		selfCheckoutStation.printer.addInk(100);
-
-		selfCheckoutStationLogic.printReceipt();
-
-		// success
-	}
-
-	@Test
-	public void removingItem() throws OverloadException {
-
-		selfCheckoutStation.scale.add(normalItem);
-
-		selfCheckoutStation.scanner.scan(barcodedLightItem);
-
-		selfCheckoutStation.scale.remove(normalItem);
-
-		assertTrue(selfCheckoutStationLogic.getWaitForAttendant());
-
-	}
-
-	@Test(expected = SimulationException.class)
-	public void barcodeScannedBarcodeNull() {
-		Currency Banknote = Currency.getInstance(Locale.US);
-		int[] validBanknoteDenomination = { 5 };
-		BigDecimal[] ValidCoinDenomination = { BigDecimal.valueOf(0.05) };
-		SelfCheckoutStation SCSTest = new SelfCheckoutStation(Banknote, validBanknoteDenomination,
-				ValidCoinDenomination, 5, 2);
-		Store s = new Store(1, 1);
-		SelfCheckoutStationLogic TestSM = new SelfCheckoutStationLogic(SCSTest, s);
-
-		Barcode testBarcode = null;
-		BarcodeScanner testBS = null;
-
-		TestSM.barcodeScanned(testBS, testBarcode);
-
-	}
-
-	@Test
-	public void barcodeScannedContainsBarcode() {
-
-		BarcodedItem[] barcodedItems = new BarcodedItem[1];
-
-		Numeral[] numerals = new Numeral[1];
-		numerals[0] = Numeral.valueOf((byte) 1);
-		Barcode testBarcode = new Barcode(numerals);
-		barcodedItems[0] = new BarcodedItem(testBarcode, 10.0);
-
-		BarcodedProduct[] barcodedProducts = new BarcodedProduct[1];
-		barcodedProducts[0] = new BarcodedProduct(testBarcode, "foo", BigDecimal.ONE);
-
-		Currency Banknote = Currency.getInstance(Locale.US);
-		int[] validBanknoteDenomination = { 5 };
-		BigDecimal[] ValidCoinDenomination = { BigDecimal.valueOf(0.05) };
-		SelfCheckoutStation SCSTest = new SelfCheckoutStation(Banknote, validBanknoteDenomination,
-				ValidCoinDenomination, 5, 2);
-
-		Store s = new Store(1, 1);
-
-		s.barcodeConfigure(barcodedItems, barcodedProducts);
-
-		SelfCheckoutStationLogic TestSM = new SelfCheckoutStationLogic(SCSTest, s);
-
-		BarcodeScanner testBS = null;
-
-		double originalTotalCost = Double.parseDouble((TestSM).getBarcodeList().get(testBarcode).get("price"));
-
-		double originalExpectedWeight = Double.parseDouble(TestSM.getBarcodeList().get(testBarcode).get("weight"));
-
-		// Causes scannedItemList to put testBarcode in
-		TestSM.barcodeScanned(testBS, testBarcode);
-
-		double afterTotalCost = Double.parseDouble(TestSM.getBarcodeList().get(testBarcode).get("price"));
-
-		double afterExpectedWeight = Double.parseDouble(TestSM.getBarcodeList().get(testBarcode).get("weight"));
-
-		System.out.println(originalExpectedWeight + " " + afterExpectedWeight);
-		System.out.println(originalTotalCost + " " + afterTotalCost);
-		// scannedItemList already has testBarcode
-		// forcing scannedItemList to contain testBarcode
-		TestSM.barcodeScanned(testBS, testBarcode);
-
-		assertEquals(TestSM.getTotalCost(), afterTotalCost + originalTotalCost, 0.01);
-		assertEquals(TestSM.getTotalExpectedWeight(), afterExpectedWeight, 0.01);
-
-	}
-}
diff --git a/SCS - Software - Test/src/StoreTests.java b/SCS - Software - Test/src/StoreTests.java
deleted file mode 100644
index 6ed44d3..0000000
--- a/SCS - Software - Test/src/StoreTests.java	
+++ /dev/null
@@ -1,165 +0,0 @@
-
-/**
- * Test Suite for Store class.
- * 
- * @author Fu-Yin Lin
- * @author Ryan McHale
- * @author Karim Kassouri
- * @author Munhib Saad
- * @author Parker Wieck
- * @author Muhammad Ali
- * @author Ayomide Alabi
- *
- */
-
-import static org.junit.Assert.*;
-
-import java.math.BigDecimal;
-import java.util.Map;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.Numeral;
-import org.lsmr.selfcheckout.PriceLookupCode;
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.BarcodedProduct;
-import org.lsmr.selfcheckout.products.PLUCodedProduct;
-
-import Control.Store;
-
-public class StoreTests {
-
-	@Before
-	public void setUp() throws Exception {
-
-	}
-
-	@Test(expected = SimulationException.class)
-	public void item_count_must_be_non_negative() {
-		int barcodeItemCount = -1;
-		int pluItemCount = 5;
-		new Store(barcodeItemCount, pluItemCount);
-	}
-
-	@Test(expected = SimulationException.class)
-	public void plu_item_count_must_be_non_negative() {
-		int barcodeItemCount = 1;
-		int pluItemCount = -1;
-		new Store(barcodeItemCount, pluItemCount);
-	}
-
-	@Test
-	public void store_construction() {
-		new Store(4, 4);
-	}
-
-	@Test(expected = SimulationException.class)
-	public void improper_length_of_barcodedItems() {
-		BarcodedItem[] barcodedItems = new BarcodedItem[0];
-		BarcodedProduct[] barcodedProducts = new BarcodedProduct[1];
-		Store s = new Store(1, 1);
-		s.barcodeConfigure(barcodedItems, barcodedProducts);
-	}
-
-	@Test(expected = SimulationException.class)
-	public void improper_length_of_barcodedProducts() {
-		BarcodedItem[] barcodedItems = new BarcodedItem[1];
-		BarcodedProduct[] barcodedProducts = new BarcodedProduct[0];
-		Store s = new Store(1, 1);
-		s.barcodeConfigure(barcodedItems, barcodedProducts);
-	}
-
-	@Test
-	public void basic_passing_config_call() {
-		BarcodedItem[] barcodedItems = new BarcodedItem[1];
-
-		Numeral[] numerals = new Numeral[1];
-		numerals[0] = Numeral.valueOf((byte) 1);
-		barcodedItems[0] = new BarcodedItem(new Barcode(numerals), 10.0);
-
-		BarcodedProduct[] barcodedProducts = new BarcodedProduct[1];
-		barcodedProducts[0] = new BarcodedProduct(new Barcode(numerals), "foo", BigDecimal.ONE);
-
-		Store s = new Store(1, 1);
-		s.barcodeConfigure(barcodedItems, barcodedProducts);
-	}
-
-	@Test
-	public void duplicated_barcode() {
-		BarcodedItem[] barcodedItems = new BarcodedItem[2];
-
-		Numeral[] numerals = new Numeral[1];
-		numerals[0] = Numeral.valueOf((byte) 1);
-		barcodedItems[0] = new BarcodedItem(new Barcode(numerals), 10.0);
-		barcodedItems[1] = new BarcodedItem(new Barcode(numerals), 6.0);
-
-		BarcodedProduct[] barcodedProducts = new BarcodedProduct[2];
-		barcodedProducts[0] = new BarcodedProduct(new Barcode(numerals), "foo", BigDecimal.ONE);
-		barcodedProducts[1] = new BarcodedProduct(new Barcode(numerals), "foo", BigDecimal.TEN);
-
-		Store s = new Store(2, 2);
-		s.barcodeConfigure(barcodedItems, barcodedProducts);
-	}
-
-	@Test(expected = SimulationException.class)
-	public void product_with_barcode_not_in_items() {
-		Numeral[] item_numerals = new Numeral[1];
-		item_numerals[0] = Numeral.valueOf((byte) 1);
-
-		Numeral[] product_numerals = new Numeral[2];
-		product_numerals[0] = Numeral.valueOf((byte) 1);
-		product_numerals[1] = Numeral.valueOf((byte) 1);
-
-		BarcodedItem[] barcodedItems = new BarcodedItem[1];
-		barcodedItems[0] = new BarcodedItem(new Barcode(item_numerals), 10.0);
-
-		BarcodedProduct[] barcodedProducts = new BarcodedProduct[1];
-		barcodedProducts[0] = new BarcodedProduct(new Barcode(product_numerals), "foo", BigDecimal.ONE);
-
-		Store s = new Store(1, 1);
-		s.barcodeConfigure(barcodedItems, barcodedProducts);
-	}
-
-	@Test
-	public void get_barcode_list() {
-		BarcodedItem[] barcodedItems = new BarcodedItem[2];
-
-		Numeral[] foo_numerals = new Numeral[1];
-		foo_numerals[0] = Numeral.valueOf((byte) 1);
-
-		Numeral[] bar_numerals = new Numeral[1];
-		bar_numerals[0] = Numeral.valueOf((byte) 2);
-
-		barcodedItems[0] = new BarcodedItem(new Barcode(foo_numerals), 50.0);
-		barcodedItems[1] = new BarcodedItem(new Barcode(bar_numerals), 2.0);
-
-		BarcodedProduct[] barcodedProducts = new BarcodedProduct[2];
-		barcodedProducts[0] = new BarcodedProduct(new Barcode(foo_numerals), "foo", BigDecimal.ONE);
-		barcodedProducts[1] = new BarcodedProduct(new Barcode(bar_numerals), "bar", BigDecimal.TEN);
-
-		Store s = new Store(2, 2);
-		s.barcodeConfigure(barcodedItems, barcodedProducts);
-
-		assertEquals(s.getBarcodeItemCount(), 2);
-		Map<Barcode, Map<String, String>> test_result = s.getBarcodeList();
-
-		if (test_result == null) {
-			fail("barcode list is null");
-		}
-
-		double returned_price = Double.parseDouble((test_result.get(new Barcode(foo_numerals)).get("price")));
-		double original_price = barcodedProducts[0].getPrice().doubleValue();
-		assertEquals(returned_price, original_price, 0.01);
-		assertEquals(Double.parseDouble(test_result.get(new Barcode(foo_numerals)).get("weight")),
-				barcodedItems[0].getWeight(), 0.01);
-
-		returned_price = Double.parseDouble((test_result.get(new Barcode(bar_numerals)).get("price")));
-		original_price = barcodedProducts[1].getPrice().doubleValue();
-		assertEquals(returned_price, original_price, 0.01);
-		assertEquals(Double.parseDouble(test_result.get(new Barcode(bar_numerals)).get("weight")),
-				barcodedItems[1].getWeight(), 0.01);
-	}
-}
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java
new file mode 100644
index 0000000..3b59cc8
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaggingAreaControllerTest.java	
@@ -0,0 +1,283 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+import java.util.HashMap;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.PaymentController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+public class BaggingAreaControllerTest extends BaseTestClass {
+	private BaggingAreaController BACController;
+	private ScanItemController SICController;
+	private HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
+	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
+	private SelfCheckoutStation cs;
+	
+	//initializing prices of items
+	BigDecimal item1Price = new BigDecimal(2.50);
+	BigDecimal item2Price = new BigDecimal(4.05);
+	BigDecimal item3Price = new BigDecimal(3.50);
+			
+	Numeral[] nItem1 = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+	Numeral[] nItem2 = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
+	Numeral[] nItem3 = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
+			
+			
+	//initalizing barcodes of the items
+	Barcode barcodeItem1 = new Barcode(nItem1);
+	Barcode barcodeItem2 = new Barcode(nItem2);
+	Barcode barcodeItem3 = new Barcode(nItem3);
+	
+	//Method to ensure that the item scanned is actually added
+	public void scanError(BarcodedItem item) {
+		while (true) {
+			cs.scanner.scan(item);
+			
+			if(SICController.numOfScannedItems() == (1+BACController.getNumOfItemsInBaggingArea())) {
+				cs.scale.add(item);
+				break;
+			}
+		}
+	}
+	
+	//Initialize selfcheckout station 
+	//Bagging area controller
+	//Scan item controller
+	@Before
+	public void setup()  {
+		
+		//Use checkout station from base test class
+		super.setup();
+		cs = checkoutStation;
+		
+		
+		
+		//initalizing price hashmap		
+		barcodePrice.put(barcodeItem1, item1Price);	//Item1
+		barcodePrice.put(barcodeItem2, item2Price);	//Item2
+		barcodePrice.put(barcodeItem3, item3Price);	//item3
+				
+		//initalizing expected weight hashmap
+		barcodeWeight.put(barcodeItem1, 300.0);
+		barcodeWeight.put(barcodeItem2, 100.0);
+		barcodeWeight.put(barcodeItem3, 1000.0);
+		
+		SICController = new ScanItemController(checkoutStation, barcodePrice, barcodeWeight);
+		BACController = new BaggingAreaController(checkoutStation);
+		
+		//Setting the Controllers of each Controller
+		BACController.setScanItemControl(SICController);
+		SICController.setBagAreaControl(BACController);
+
+	}
+	
+	//Test if scanner is disabled if scale is overload
+	//Enter overload by adding heavy item to scale
+	@Test
+	public void testScannerDisabledOverLoad1() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+		BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+		BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+		BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
+
+		Assert.assertFalse(checkoutStation.scanner.isDisabled());
+		
+		try {
+			scanError(item3);
+
+			scanError(item1);
+
+			scanError(item2);
+	
+			scanError(item3Dup1);
+
+
+			
+		} catch(Exception e) {
+			//shouldn't each here
+			System.out.println("not supposed to occur");
+			e.printStackTrace();
+			fail();
+		}
+		
+		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+	}
+	
+	//Test if the scale goes out of overload, the scanner is enabled
+		@Test
+		public void testScannerDisabledOverLoad2() {
+			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+			BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
+
+			Assert.assertFalse(checkoutStation.scanner.isDisabled());
+			
+			try {
+				scanError(item3);
+				scanError(item1);
+				scanError(item2);
+				scanError(item3Dup1);
+			} catch(Exception e) {
+				//shouldn't each here
+				System.out.println("not supposed to occur");
+				e.printStackTrace();
+				fail();
+			}
+			
+			
+			Assert.assertTrue(checkoutStation.scanner.isDisabled());
+			
+			try {
+				checkoutStation.scale.remove(item3);
+			} catch(Exception e) {
+				//shouldn't each here
+				System.out.println("not supposed to occur");
+				e.printStackTrace();
+				fail();
+			}
+			Assert.assertFalse(checkoutStation.scanner.isDisabled());
+			Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
+		}
+	
+	
+	//Test if scanner is disabled if there is a weight discrepancy
+	//test one item with a discrepancy in the weight that is larger
+
+	@Test
+	public void testWeightChanged1() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 400.0);
+		
+		try {
+			scanError(item1);
+		} catch (Exception e) {
+			System.out.println("Shouldn't happen");
+			fail();
+		}
+		
+		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+	}
+	
+	//Test if scanner is disabled if there is a weight discrepancy
+	//test 1 item with a discrepancy in the weight that is less
+	@Test
+	public void testWeightChanged2() {
+		BarcodedItem item1 = new BarcodedItem(barcodeItem1, 200.0);
+
+		try {
+			scanError(item1);
+		} catch (Exception e) {
+			System.out.println("Shouldn't happen");
+			fail();
+		}
+		
+		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+	}
+	
+	//Test if scanner is disabled if there is a weight discrepancy
+		//test 2 items with one having discrepancy in the weight that is correct weight and one that is greater than the expected
+		@Test
+		public void testWeightChanged3() {
+			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+			BarcodedItem item1Dup1 = new BarcodedItem(barcodeItem1, 400.0);
+
+			try {
+				scanError(item1);
+				scanError(item1Dup1);
+			} catch (Exception e) {
+				System.out.println("Shouldn't happen");
+				fail();
+			}
+			
+			Assert.assertTrue(checkoutStation.scanner.isDisabled());
+		}
+	
+		//Test to see that when an item is removed the controller knows and adjusts the number in the cart
+		@Test
+		public void testWeightChanged4() {
+			BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+			BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+			BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+			BarcodedItem item3Dup1 = new BarcodedItem(barcodeItem3, 1000.0);
+
+			Assert.assertFalse(checkoutStation.scanner.isDisabled());
+			
+			try {
+				scanError(item3);
+				scanError(item1);
+				scanError(item2);
+				scanError(item3Dup1);
+				
+			} catch(Exception e) {
+				//shouldn't each here
+				System.out.println("not supposed to occur");
+				e.printStackTrace();
+				fail();
+			}
+			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
+			
+			try {
+				checkoutStation.scale.remove(item3Dup1);
+			} catch (Exception e) {
+				fail();
+			}
+			
+			Assert.assertFalse(checkoutStation.scanner.isDisabled());
+			Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 3);
+		}
+		
+		//Test to see that when all items are removed the controller knows and adjusts the number in the cart
+				@Test
+				public void testWeightChanged5() {
+					BarcodedItem item1 = new BarcodedItem(barcodeItem1, 300.0);
+					BarcodedItem item2 = new BarcodedItem(barcodeItem2, 100.0);
+					BarcodedItem item3 = new BarcodedItem(barcodeItem3, 1000.0);
+
+
+					Assert.assertFalse(checkoutStation.scanner.isDisabled());
+					
+					try {
+						scanError(item3);
+						scanError(item1);
+						scanError(item2);
+
+						
+					} catch(Exception e) {
+						//shouldn't each here
+						System.out.println("not supposed to occur");
+						e.printStackTrace();
+						fail();
+					}
+					
+					Assert.assertEquals(3, BACController.getNumOfItemsInBaggingArea());
+					
+					try {
+						checkoutStation.scale.remove(item2);
+						checkoutStation.scale.remove(item3);
+						checkoutStation.scale.remove(item1);
+					} catch (Exception e) {
+						fail();
+					}
+					
+
+					Assert.assertEquals(BACController.getNumOfItemsInBaggingArea(), 0);
+				}
+	
+}
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java
new file mode 100644
index 0000000..dd78822
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/BaseTestClass.java	
@@ -0,0 +1,50 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+
+/**
+ * A parent unit test class which has a self checkout station initialized already.
+ */
+public class BaseTestClass {
+	
+	BigDecimal dec1 = new BigDecimal(0.50);
+	BigDecimal dec2 = new BigDecimal(1);
+	BigDecimal dec3 = new BigDecimal(2);
+	
+	//declaring parameters for self checkout station
+	private Currency c1 = null;
+	private final int[] banknoteDenominations = {5, 10 , 15, 20};
+	public final BigDecimal[] coinDenominations = {dec1, dec2, dec3};
+	private int scaleMaxWeight;
+	private int scaleSensitivity;
+	
+	/**
+	 * Attach observers to this to test the observers.
+	 */
+	SelfCheckoutStation checkoutStation;
+	
+	/**
+	 * Initializes SelfCheckoutStation with dummy data.
+	 */
+	@Before
+	public void setup() {
+		//initializing parameters for SCS
+		c1 = Currency.getInstance("CAD");
+		scaleMaxWeight = 2000;
+		scaleSensitivity = 1;
+
+		//initializing SCS
+		checkoutStation = new SelfCheckoutStation(c1, banknoteDenominations, coinDenominations, scaleMaxWeight, scaleSensitivity);
+
+	}
+	
+	@Test
+	public void testCase() {
+		
+	}
+}
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java
new file mode 100644
index 0000000..bee549b
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/PaymentControllerTest.java	
@@ -0,0 +1,212 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.math.BigDecimal;
+
+import java.util.Currency;
+import java.util.List;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.customer.PaymentController;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+
+
+public class PaymentControllerTest extends BaseTestClass {
+
+
+	//declaring self checkout station
+	private SelfCheckoutStation cs;
+	
+	//declaring controller
+	private PaymentController pController;
+
+	
+	//Payment Controller
+	@Before
+	public void setup() {
+		
+		super.setup();
+
+		//Initialize self checkout station
+		cs = checkoutStation;
+
+		//initializing parameters for PaymentController
+		BigDecimal totalCost = new BigDecimal(20);
+
+		//initializing payment controller
+		pController = new PaymentController(cs);
+	}
+	
+	//Test if payment can be made with all coins
+	@Test
+	public void test1() {
+		//initialize a new total cost
+		BigDecimal totalCost = new BigDecimal(2);
+		
+		//initialize payment controller
+		pController.setValueOfCart(totalCost);
+
+		Coin coin = new Coin(Currency.getInstance("CAD"), dec3);
+		
+		try {
+			//accept valid coin
+			cs.coinSlot.accept(coin);
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		}
+		
+		//See if cost was paid
+		//Value of cart at the start of test is $2
+		//After coin slot accepts and validates, it should be $0
+		Assert.assertEquals(new BigDecimal(0), pController.getValueOfCart());
+	}
+	
+	
+	//Test if payment can be made in all bank notes
+	@Test
+	public void test2() {
+		//initialize a new total cost
+		BigDecimal totalCost = new BigDecimal(20);
+
+		//Change the value of cart 
+		pController.setValueOfCart(totalCost);
+
+		Banknote banknote = new Banknote(Currency.getInstance("CAD"), 20);
+		try {
+			//accept valid banknote
+			cs.banknoteInput.accept(banknote);
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		} catch (OverloadException e) {
+			e.printStackTrace();
+		}
+		
+		//See if cost was paid
+		//Value of cart at the start of test is $20
+		//After banknote slot accepts and validates, it should be $0
+		assertEquals(new BigDecimal(0), pController.getValueOfCart());
+
+	}
+	
+	//Test if payment can be made with mix of bank note and coins 
+	@Test
+	public void test3() {
+		//initialize a new total cost
+		BigDecimal totalCost = new BigDecimal(17);
+	
+		//Change the value of cart 
+		pController.setValueOfCart(totalCost);
+		
+		Banknote banknote = new Banknote(Currency.getInstance("CAD"), 15);
+		Coin coin = new Coin(Currency.getInstance("CAD"), dec3);
+		try{
+			//accept payment
+			cs.banknoteInput.accept(banknote);
+			cs.coinSlot.accept(coin);
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		} catch (OverloadException e) {
+			e.printStackTrace();
+		}
+		
+		//See if cost was paid
+		Assert.assertEquals(new BigDecimal(0), pController.getValueOfCart());
+	}
+	
+	//Test if the coin/banknote slot throw disable exception 
+	//After valueOfCart is paid for and you want to make another payment
+	@Test
+	public void test4() {
+		//Initialize a new total cost
+		BigDecimal totalCost = new BigDecimal(15);
+		
+		//Change the value of cart 
+		pController.setValueOfCart(totalCost);
+		
+		//This banknote covers the payment of the cart
+		Banknote banknote = new Banknote(Currency.getInstance("CAD"), 15);
+		
+		//Extra payment you want to make
+		Coin coin = new Coin(Currency.getInstance("CAD"), dec3);
+		
+		try{
+			//accept payment
+			cs.banknoteInput.accept(banknote);
+			//Causes DisabledException
+			cs.coinSlot.accept(coin);
+		} catch (DisabledException e) {
+			Assert.assertTrue(true);
+		} catch (OverloadException e) {
+			e.printStackTrace();
+		}
+	}
+	
+	//Test if invalid coin does not reduce the valueOfCart
+	//But instead goes to coin tray
+	@Test
+	public void test5() {
+		//Initialize a new total cost
+		BigDecimal totalCost = new BigDecimal(15);
+		
+		//Change the value of cart 
+		pController.setValueOfCart(totalCost);
+		
+		Coin coin = new Coin(Currency.getInstance("USD"), dec2);
+		try {
+			pController.setValueOfCart(totalCost);
+			//try to accept invalid coin
+			cs.coinSlot.accept(coin);
+		} catch (DisabledException e) {
+			e.printStackTrace();
+		}
+		
+		//Value of Cart stays the same
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		//Since invalid coin are placed in coin tray
+		//The coin inserted is identical to the invalid coin in the coin tray 
+		Assert.assertEquals(coin, pController.getCoinTrayList().get(0));
+	}
+	
+	//Test if invalid banknote does not reduce the valueOfCart
+	//But instead is a dangling banknote
+	@Test
+	public void test6() {
+		
+		//Initialize a new total cost
+		BigDecimal totalCost = new BigDecimal(15);
+		
+		//Change the value of cart 
+		pController.setValueOfCart(totalCost);
+		
+		Banknote banknote = new Banknote(Currency.getInstance("CAD"), 25);
+		Banknote banknote2 = new Banknote(Currency.getInstance("CAD"), 10);
+		try {
+			//try to accept invalid note
+			cs.banknoteInput.accept(banknote);
+		} catch (DisabledException | OverloadException e) {
+			e.printStackTrace();
+		}
+		
+		//Value of Cart stays the same
+		Assert.assertEquals(totalCost, pController.getValueOfCart());
+		
+		//Dangling banknote leads to an overload exception due to accepting another banknote
+		try {
+			cs.banknoteInput.accept(banknote2);
+		}catch(OverloadException e){
+			Assert.assertTrue(true);
+		}catch(DisabledException e) {
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java
new file mode 100644
index 0000000..bab59fb
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ReceiptPrinterControllerTest.java	
@@ -0,0 +1,146 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import java.util.HashMap;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.PaymentController;
+import org.lsmr.selfcheckout.customer.ReceiptPrinterController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.Numeral;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+import java.util.List;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+//Mohamed
+
+public class ReceiptPrinterControllerTest extends BaseTestClass{
+	
+	//declaring self checkout station
+	private SelfCheckoutStation cs;
+	
+	//declaring controllers 
+	private ReceiptPrinterController RPcontroller;
+	private PaymentController PAcontroller;
+	private ScanItemController SIcontroller;
+	private BaggingAreaController bAcontroller;
+	
+	//initializing prices of items
+	BigDecimal milkPrice = new BigDecimal(2.50);
+	BigDecimal eggPrice = new BigDecimal(4.00);
+	BigDecimal toastPrice = new BigDecimal(3.50);
+	
+	Numeral[] nMilk = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+	Numeral[] nEggs = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
+	Numeral[] nToast = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
+	
+	
+	//initalizing barcodes of the items
+	Barcode barcodeMilk = new Barcode(nMilk);
+	Barcode barcodeEggs = new Barcode(nEggs);
+	Barcode barcodeToast = new Barcode(nToast);
+	
+	
+	//declaring hashmap barcodePrice hashmap and barcodeWeight hashmap
+	private final HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
+	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
+	private final HashMap<Barcode, String> barcodeDescription = new HashMap<Barcode, String>();
+	
+	
+	//Initialize checkoutStation
+	//Create a hasMap of bar code to price
+	@Before
+	public void setup() {
+		
+		
+		super.setup();
+		cs = checkoutStation;
+		
+		
+		//initalizing price hashmap		
+		barcodePrice.put(barcodeMilk, milkPrice);	//milk
+		barcodePrice.put(barcodeEggs, eggPrice);	//eggs
+		barcodePrice.put(barcodeToast, toastPrice);	//toast
+		
+		//initalizing weight hashmap
+		barcodeWeight.put(barcodeMilk, 3.0);	//milk
+		barcodeWeight.put(barcodeEggs, 2.0);	//eggs
+		barcodeWeight.put(barcodeToast, 5.0);	//toast
+		
+		//initializng barcode description 
+		barcodeDescription.put(barcodeMilk, "Milk");	//milk
+		barcodeDescription.put(barcodeEggs, "Eggs");	//eggs
+		barcodeDescription.put(barcodeToast, "Toast");	//toast
+		
+		
+		
+		//initalizing controllers
+		SIcontroller = new ScanItemController(cs, barcodePrice, barcodeWeight);
+		PAcontroller = new PaymentController(cs);
+		RPcontroller = new ReceiptPrinterController(cs,barcodePrice, barcodeDescription);
+		bAcontroller = new BaggingAreaController(cs);
+		
+		
+		//calling object methods
+		bAcontroller.setScanItemControl(SIcontroller);
+		SIcontroller.setBagAreaControl(bAcontroller);
+		RPcontroller.setControllers(SIcontroller, PAcontroller);
+		
+	}
+	
+	public void scanError(BarcodedItem item) {
+		while (true) {
+			cs.scanner.scan(item);
+			
+			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
+				cs.scale.add(item);
+				break;
+			}
+		}
+	}
+	
+	
+	//Test if controller expected receipt match the one from the printer
+	@Test
+	public void test1() throws DisabledException, OverloadException {
+		
+	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+	
+	//Scanning Items
+	scanError(milk);
+	scanError(eggs);
+	scanError(toast);
+	
+	//Total Cost of Item is 10.00
+	PAcontroller.setValueOfCart(new BigDecimal(10));
+	
+	//Item has been paid for
+	cs.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"), 10));
+	
+	//Print the receipt
+	RPcontroller.printReceipt();
+	
+	cs.printer.cutPaper();
+	
+	//Check if controller expected receipt match the one from the printer
+	Assert.assertEquals(RPcontroller.getReceipt(), cs.printer.removeReceipt());
+	}
+	
+}
\ No newline at end of file
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java
new file mode 100644
index 0000000..746fb5f
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/ScanItemControllerTest.java	
@@ -0,0 +1,229 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import java.util.HashMap;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.customer.BaggingAreaController;
+import org.lsmr.selfcheckout.customer.ScanItemController;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.Numeral;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+import java.util.List;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+
+public class ScanItemControllerTest extends BaseTestClass{
+	
+	//declaring self checkout station
+	private SelfCheckoutStation cs;
+	
+	//declaring controllers 
+	private ScanItemController SIcontroller;
+	private BaggingAreaController bAcontroller;
+	
+	//initializing prices of items
+	BigDecimal milkPrice = new BigDecimal(2.50);
+	BigDecimal eggPrice = new BigDecimal(4.05);
+	BigDecimal toastPrice = new BigDecimal(3.50);
+	
+	Numeral[] nMilk = {Numeral.one, Numeral.two, Numeral.three, Numeral.four};
+	Numeral[] nEggs = {Numeral.two, Numeral.three, Numeral.four, Numeral.one};
+	Numeral[] nToast = {Numeral.three, Numeral.two, Numeral.four, Numeral.one};
+	
+	
+	//initalizing barcodes of the items
+	Barcode barcodeMilk = new Barcode(nMilk);
+	Barcode barcodeEggs = new Barcode(nEggs);
+	Barcode barcodeToast = new Barcode(nToast);
+	
+	
+	//declaring hashmap barcodePrice hashmap and barcodeWeight hashmap
+	private HashMap<Barcode, BigDecimal> barcodePrice = new HashMap<Barcode, BigDecimal>();
+	private final HashMap<Barcode, Double> barcodeWeight = new HashMap<Barcode, Double>();
+	
+	//Initialize checkoutStation
+	//Create a hasMap of bar code to price
+	@Before
+	public void setup() {
+		
+		
+		super.setup();
+		cs = checkoutStation;
+		
+		
+		//initalizing price hashmap		
+		barcodePrice.put(barcodeMilk, milkPrice);	//milk
+		barcodePrice.put(barcodeEggs, eggPrice);	//eggs
+		barcodePrice.put(barcodeToast, toastPrice);	//toast
+		
+		//initalizing weight hashmap
+		barcodeWeight.put(barcodeMilk, 3.0);	//milk
+		barcodeWeight.put(barcodeEggs, 2.0);	//eggs
+		barcodeWeight.put(barcodeToast, 5.0);	//toast
+		
+		
+		//initalizing the BaggingAreaController and scanItemController
+		bAcontroller = new BaggingAreaController(cs);
+		SIcontroller = new ScanItemController(cs, barcodePrice, barcodeWeight);
+
+		//calling object methods
+		bAcontroller.setScanItemControl(SIcontroller);
+		SIcontroller.setBagAreaControl(bAcontroller);
+		
+	}
+	
+	public void scanError(BarcodedItem item) {
+		while (true) {
+			cs.scanner.scan(item);
+			
+			if(SIcontroller.numOfScannedItems() == 1 + bAcontroller.getNumOfItemsInBaggingArea()) {
+				cs.scale.add(item);
+				break;
+			}
+		}
+	}
+	
+	
+	//Expected value of cart = 10.05
+	//Compare with the actual value of cart from the ScanItemController
+	//Initialize a scanItemController
+	@Test
+	public void test1() {
+		
+	BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+	BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+	BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+	
+	
+	scanError(milk);
+	scanError(eggs);
+	scanError(toast);
+	
+
+	BigDecimal expectedValueOfCart = new BigDecimal(0);
+	expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+	expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+	expectedValueOfCart = expectedValueOfCart.add(toastPrice);
+
+	Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
+	}
+	
+	
+	//Disable the scanner
+	//Expected result - disable exception
+	//Try and scan an item while disabled
+	@Test
+	public void test2() {
+		
+		BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+		Double expectedWeightOfCart = 0.0;
+		BigDecimal expectedValueOfCart = new BigDecimal(0);
+		
+		cs.scanner.disable();
+		cs.scanner.scan(milk);
+		
+		
+		Assert.assertEquals(new BigDecimal(0), SIcontroller.getValueOfCart());
+		Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
+		
+	}
+		
+		
+	
+	//scan a valid item
+	@Test
+	public void test3() {
+		//initializing barcodedItems
+		BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+		BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+		BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+	
+		
+		Double expectedWeightOfCart = 10.0;
+		BigDecimal expectedValueOfCart = new BigDecimal(0);
+		expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+		expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+		expectedValueOfCart = expectedValueOfCart.add(toastPrice);
+		
+		scanError(milk);
+		scanError(eggs);
+		scanError(toast);
+
+		Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
+		Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
+		
+	}
+	
+	//unscans a valid item
+		@Test
+		public void unScan1() {
+			//initializing barcodedItems
+			BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+			BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+			BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+		
+			
+			Double expectedWeightOfCart = 10.0;
+			BigDecimal expectedValueOfCart = new BigDecimal(0);
+			expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+			expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+			expectedValueOfCart = expectedValueOfCart.add(toastPrice);
+			
+			scanError(milk);
+			scanError(eggs);
+			scanError(toast);
+			
+			SIcontroller.unScanItem(eggs.getBarcode());
+			
+			
+			expectedValueOfCart = expectedValueOfCart.subtract(eggPrice);
+			expectedWeightOfCart -= eggs.getWeight();
+			
+			Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
+			Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
+			
+		}
+		
+		//unscans a item not in the cart
+		@Test
+		public void unScan2() {
+			//initializing barcodedItems
+			BarcodedItem milk = new BarcodedItem(barcodeMilk, 3.0);
+			BarcodedItem eggs = new BarcodedItem(barcodeEggs, 2.0);
+			BarcodedItem toast = new BarcodedItem(barcodeToast, 5.0);
+					
+			Double expectedWeightOfCart = 5.0;
+			BigDecimal expectedValueOfCart = new BigDecimal(0);
+			expectedValueOfCart = expectedValueOfCart.add(milkPrice);
+			expectedValueOfCart = expectedValueOfCart.add(eggPrice);
+
+			scanError(milk);
+			scanError(eggs);
+
+					
+			SIcontroller.unScanItem(toast.getBarcode());
+					
+					
+
+			Assert.assertEquals(expectedWeightOfCart, SIcontroller.getWeightOfCart());
+			Assert.assertEquals(expectedValueOfCart, SIcontroller.getValueOfCart());
+					
+		}
+				
+		
+	
+}
\ No newline at end of file
diff --git a/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java
new file mode 100644
index 0000000..6ff92bc
--- /dev/null
+++ b/SCS - Software - Test/src/org/lsmr/selfcheckout/customer/testing/TouchScreenControllerTest.java	
@@ -0,0 +1,42 @@
+package org.lsmr.selfcheckout.customer.testing;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import org.lsmr.selfcheckout.customer.TouchScreenController;
+
+/**
+ * Test cases for the touch screen
+ */
+public class TouchScreenControllerTest extends BaseTestClass {	
+	
+	/**
+	 * System under test
+	 */
+	TouchScreenController touchScreenController;
+	
+	@Override
+	public void setup() {
+		super.setup();
+		touchScreenController = new TouchScreenController(checkoutStation);
+	}
+
+	//Test if scanner is enabled when the user starts using the checkout station
+	@Test
+	public void testInitStart() {
+		touchScreenController.initiateStart();
+		Assert.assertFalse(checkoutStation.scanner.isDisabled());
+	}
+	
+	
+	//Test if scanner is disable and coin/banknote slot is enabled
+	//When user wishes to checkout and make payment
+	@Test
+	public void testInitCheckout() {
+		touchScreenController.inititateCheckout();
+		Assert.assertTrue(checkoutStation.scanner.isDisabled());
+		Assert.assertFalse(checkoutStation.banknoteInput.isDisabled());
+		Assert.assertFalse(checkoutStation.coinSlot.isDisabled());
+	}
+	
+}
diff --git a/SCS - Software/.classpath b/SCS - Software/.classpath
index bc49437..79a8207 100644
--- a/SCS - Software/.classpath	
+++ b/SCS - Software/.classpath	
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-16">
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
 		<attributes>
 			<attribute name="module" value="true"/>
 		</attributes>
 	</classpathentry>
-	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/SCS - Software/.gitignore b/SCS - Software/.gitignore
new file mode 100644
index 0000000..ae3c172
--- /dev/null
+++ b/SCS - Software/.gitignore	
@@ -0,0 +1 @@
+/bin/
diff --git a/SCS - Software/.project b/SCS - Software/.project
index 711bba8..07b7ac9 100644
--- a/SCS - Software/.project	
+++ b/SCS - Software/.project	
@@ -14,4 +14,15 @@
 	<natures>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
+	<filteredResources>
+		<filter>
+			<id>1647387659426</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
 </projectDescription>
diff --git a/SCS - Software/.settings/org.eclipse.jdt.core.prefs b/SCS - Software/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index 8aabe8d..0000000
--- a/SCS - Software/.settings/org.eclipse.jdt.core.prefs	
+++ /dev/null
@@ -1,14 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=16
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=16
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
-org.eclipse.jdt.core.compiler.release=enabled
-org.eclipse.jdt.core.compiler.source=16
diff --git a/SCS - Software/bin/.gitignore b/SCS - Software/bin/.gitignore
deleted file mode 100644
index 02c1ff6..0000000
--- a/SCS - Software/bin/.gitignore	
+++ /dev/null
@@ -1 +0,0 @@
-/Control/
diff --git a/SCS - Software/src/Control/SelfCheckoutStationLogic.java b/SCS - Software/src/Control/SelfCheckoutStationLogic.java
deleted file mode 100644
index bcdb7e1..0000000
--- a/SCS - Software/src/Control/SelfCheckoutStationLogic.java	
+++ /dev/null
@@ -1,292 +0,0 @@
-package Control;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.BanknoteValidator;
-import org.lsmr.selfcheckout.devices.BarcodeScanner;
-import org.lsmr.selfcheckout.devices.CoinValidator;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
-import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
-import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
-import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
-import org.lsmr.selfcheckout.devices.observers.TouchScreenObserver;
-
-/**
- * Represents the logic of a Self-Checkout Station.
- * 
- * @author Fu-Yin Lin
- * @author Ryan McHale
- * @author Karim Kassouri
- * @author Munhib Saad
- * @author Parker Wieck
- * @author Muhammad Ali
- * @author Ayomide Alabi
- *
- */
-public class SelfCheckoutStationLogic implements BarcodeScannerObserver, ElectronicScaleObserver, TouchScreenObserver,
-		CoinValidatorObserver, BanknoteValidatorObserver {
-	private SelfCheckoutStation selfCheckoutStation;
-	private Map<Barcode, Map<String, String>> barcodeList;
-	private Map<Barcode, Integer> scannedItemList = new HashMap<>();
-	private double totalCost;
-	private double totalPayment;
-	private double currentExpectedWeight;
-	private boolean waitForAttendant = false;
-	private boolean checkingOut = false;
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param scs   The self-checkout station to install the logic. Cannot be null.
-	 * @param store The store to provide store product information. Cannot be null.
-	 */
-	public SelfCheckoutStationLogic(SelfCheckoutStation scs, Store store) {
-		if (scs == null || store == null) {
-			throw new SimulationException(new NullPointerException());
-		}
-		selfCheckoutStation = scs;
-		scs.scanner.attach(this);
-		scs.scale.attach(this);
-		scs.coinValidator.attach(this);
-		scs.banknoteValidator.attach(this);
-		barcodeList = store.getBarcodeList();
-		totalCost = 0.0;
-		totalPayment = 0.0;
-		currentExpectedWeight = 0.0;
-	}
-
-
-	
-	
-	
-	@Override
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// not used
-	}
-
-	@Override
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// not used
-	}
-
-	@Override
-	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
-		if (barcode == null) {
-			throw new SimulationException("undefined barcode");
-		}
-
-		if (scannedItemList.containsKey(barcode)) {
-			scannedItemList.replace(barcode, scannedItemList.get(barcode) + 1);
-		} else {
-			scannedItemList.put(barcode, 1);
-		}
-
-		totalCost += Double.parseDouble(barcodeList.get(barcode).get("price"));
-		currentExpectedWeight = Double.parseDouble(barcodeList.get(barcode).get("weight"));
-	}
-
-	@Override
-	public void overload(ElectronicScale scale) {
-		waitForAttendant = true;
-	}
-
-	@Override
-	public void outOfOverload(ElectronicScale scale) {
-		waitForAttendant = false;
-	}
-
-	@Override
-	public void weightChanged(ElectronicScale scale, double weightInGrams) {
-		if (weightInGrams > 0) {
-			double difference = Math.abs(currentExpectedWeight - weightInGrams);
-			if (difference <= selfCheckoutStation.scale.getSensitivity()) {
-				// Good to proceed further actions
-				waitForAttendant = false;
-			} else {
-				// Call attendant for further investigation
-				waitForAttendant = true;
-			}
-		} else {
-			// Call attendant to figure out what gets removed
-			waitForAttendant = true;
-		}
-	}
-
-	/**
-	 * Method deals with button pressed on the touch screen (simulation only)
-	 */
-	/*
-	 * 
-	 
-	 Would be implemented with the appropriate hardware.
-	 We are missing hardware to accept crypto, credit, and any interface with the touchscreen.
-	 
-	public void touchScreenButtonPressed(TouchScreenObserver touchscreen, String buttonPressed) {
-		// button = 'payment'
-		// buttons = 'cash', 'card', 'crypto'
-		// if 'cash', coin slot and banknote slot should be enabled
-		// if 'card', card reader should be enabled
-		// if 'crypto', not sure which hardware to use
-		// if button = 'pay' (in cash case) is enabled (default disabled), that means
-		// payment >= cost
-		// if payment == cost, call printReceipt()
-		// else payment > cost, call returnChange() and printReceipt()
-				
-		if (buttonPressed == "payment") {
-			checkingOut = true;
-		}
-		
-		if (buttonPressed == "cash") {
-			// coin and banknote slots enabled
-		}
-		
-		if (buttonPressed == "card") {
-			// card reader enabled
-		}
-		
-		if (buttonPressed == "crypto") {
-			// cryto payment machine enabled
-		}
-		
-		if (buttonPressed == "cancel") {
-			checkingOut = false;
-		}
-		
-		if (buttonPressed == "pay") {
-			if (totalPayment > totalCost) {
-				//returnChange(); not yet implemented
-			} 
-			printReceipt();
-			checkingOut = false;
-		}
-	}
-	*/
-
-
-	@Override
-	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
-		totalPayment += value.doubleValue();
-		if (totalPayment >= totalCost) {
-			// 'pay' button enabled
-		}
-	}
-
-	@Override
-	public void invalidCoinDetected(CoinValidator validator) {
-		// System block and attendant notified
-		System.out.println("INVALID COIN DETECTED");
-		waitForAttendant = true;
-	}
-
-	@Override
-	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
-		totalPayment += value;
-		if (totalPayment >= totalCost) {
-			// 'pay' button enabled
-		}
-	}
-
-	@Override
-	public void invalidBanknoteDetected(BanknoteValidator validator) {
-		// System block and attendant notified
-		System.out.println("INVALID BANKNOTE DETECTED");
-		waitForAttendant = true;
-	}
-
-	/**
-	 * Method to calculate and return change to customer
-	 
-	public void returnChange() {
-		// to be implemented in future iteration
-	}
-	*/
-
-	/**
-	 * Method to generate and print receipt
-	 */
-	public void printReceipt() {
-		StringBuilder str = new StringBuilder();
-		for (Barcode barcode : scannedItemList.keySet()) {
-			int quantity = scannedItemList.get(barcode);
-			double price = Double.parseDouble(barcodeList.get(barcode).get("price"));
-			str.append(barcode);
-			str.append(" ");
-			str.append(barcodeList.get(barcode).get("name"));
-			str.append(" ");
-			str.append(quantity);
-			str.append(" ");
-			str.append(price);
-			str.append(" ");
-			str.append(quantity * price);
-		}
-
-		for (int i = 0; i < str.length(); i++) {
-			char c = str.charAt(i);
-			selfCheckoutStation.printer.print(c);
-		}
-	}
-
-	/**
-	 * Accesses the list of scanned items.
-	 * 
-	 * @return A Map with current scanned barcode and corresponding quantity.
-	 
-	public Map<Barcode, Integer> getScannedItemList() {
-		return scannedItemList;
-	}
-	 */
-	
-	/**
-	 * Accesses the current total cost.
-	 * 
-	 * @return The current total cost of all scanned items.
-	 */
-	public double getTotalCost() {
-		return totalCost;
-	}
-	/**
-	 * Accesses the current total payment.
-	 * 
-	 * @return The current total ammount paid.
-	 */
-	public double getTotalPayment() {
-		return totalPayment;
-	}
-	/**
-	 * Accesses whether or not we should wait for attendant.
-	 * 
-	 * @return Whether or not we should wait for attendant.
-	 */
-	public boolean getWaitForAttendant() {
-		return waitForAttendant;
-	}
-	
-	/**
-	 * Accesses the current expected weight.
-	 * 
-	 * @return The current expected weight of recently scanned items.
-	 */
-	public double getTotalExpectedWeight() {
-		return currentExpectedWeight;
-	}
-
-	/**
-	 * Accesses the current list information of barcoded items.
-	 * 
-	 * @return A Map with all barcoded items in store and their corresponding info.
-	 */
-	public Map<Barcode, Map<String, String>> getBarcodeList() {
-		return barcodeList;
-	}
-	
-	
-}
diff --git a/SCS - Software/src/Control/Store.java b/SCS - Software/src/Control/Store.java
deleted file mode 100644
index 26c1a37..0000000
--- a/SCS - Software/src/Control/Store.java	
+++ /dev/null
@@ -1,296 +0,0 @@
-package Control;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.PLUCodedItem;
-import org.lsmr.selfcheckout.PriceLookupCode;
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.BarcodedProduct;
-import org.lsmr.selfcheckout.products.PLUCodedProduct;
-import org.lsmr.selfcheckout.products.Product;
-
-/**
- * Simulate a store database that allows user to configure, add, update, remove
- * product information (weight, price, name).
- * 
- * @author Fu-Yin Lin
- * @author Ryan McHale
- * @author Karim Kassouri
- * @author Munhib Saad
- * @author Parker Wieck
- * @author Muhammad Ali
- * @author Ayomide Alabi
- *
- */
-public class Store {
-	private int barcodeItemCount;
-	private int pluItemCount;
-	private Map<Barcode, Map<String, String>> barcodeList = new HashMap<>();
-	private Map<PriceLookupCode, Map<String, String>> PLUList = new HashMap<>();
-
-	/**
-	 * Creates a product database for the self-checkout station.
-	 * 
-	 * @param barcodeItemCount The number of the barcoded items to be configured.
-	 *                         Can be changed with item addition or removal. Must be
-	 *                         positive. Zero count allowed.
-	 * @param pluItemCount     The number of the PLU coded items to be configured.
-	 *                         Can be changed with item addition or removal. Must be
-	 *                         positive. Zero count allowed.
-	 */
-	public Store(int barcodeItemCount, int pluItemCount) {
-		if (barcodeItemCount < 0 || pluItemCount < 0)
-			throw new SimulationException("Counts must be non-negative");
-		this.barcodeItemCount = barcodeItemCount;
-		this.pluItemCount = pluItemCount;
-	}
-
-	/**
-	 * Initial configuration of the store database to record barcoded products.
-	 * 
-	 * @param barcodedItems    A list of barcoded items to be recorded. No item
-	 *                         barcode can be null or weight is not positive.
-	 * @param barcodedProducts A list of barcoded products to be recorded. No
-	 *                         product barcode can be null or price is not positive.
-	 */
-	public void barcodeConfigure(BarcodedItem[] barcodedItems, BarcodedProduct[] barcodedProducts) {
-		if (barcodedItems.length != barcodeItemCount || barcodedProducts.length != barcodeItemCount) {
-			throw new SimulationException(
-					"The number of barcoded items and products must be identical to the barcode item count in the store");
-		}
-
-		for (BarcodedItem item : barcodedItems) {
-			Map<String, String> itemDetails = new HashMap<>();
-			itemDetails.put("weight", String.valueOf(item.getWeight()));
-			if (barcodeList.containsKey(item.getBarcode())) {
-				// Should not happen in initial configuration (barcode should be unique for each
-				// input item)
-				throw new SimulationException("duplicate barcoded item");
-			} else {
-				barcodeList.put(item.getBarcode(), itemDetails);
-			}
-		}
-
-		for (BarcodedProduct product : barcodedProducts) {
-			if (barcodeList.containsKey(product.getBarcode())) {
-				Map<String, String> productDetails = barcodeList.get(product.getBarcode());
-				productDetails.put("price", String.valueOf(product.getPrice()));
-				productDetails.put("name", product.getDescription());
-				barcodeList.replace(product.getBarcode(), productDetails);
-			} else {
-				throw new SimulationException("this barcode product does not match any of the barcode items on list");
-			}
-		}
-	}
-
-	/**
-	 * Initial configuration of the store database to record PLU coded products.
-	 * 
-	 * @param PLUItems A list of PLU coded items to be recorded. No item PLU code
-	 *                 can be null or weight is not positive.
-	 * @param PLUItems A list of PLU coded products to be recorded. No product PLU
-	 *                 code can be null or price is not positive.
-	 */
-	public void pluConfigure(PLUCodedItem[] PLUItems, PLUCodedProduct[] PLUProducts) {
-		if (PLUItems.length != pluItemCount || PLUProducts.length != pluItemCount) {
-			throw new SimulationException(
-					"The number of PLU coded items and products must be identical to the PLU coded item count in the store");
-		}
-
-		for (PLUCodedItem item : PLUItems) {
-			Map<String, String> itemDetails = new HashMap<>();
-			itemDetails.put("weight", String.valueOf(item.getWeight()));
-			if (PLUList.containsKey(item.getPLUCode())) {
-				// Should not happen in initial configuration (PLU code should be unique for
-				// each input item)
-				throw new SimulationException("duplicate PLU coded item");
-			} else {
-				PLUList.put(item.getPLUCode(), itemDetails);
-			}
-		}
-
-		for (PLUCodedProduct product : PLUProducts) {
-			if (PLUList.containsKey(product.getPLUCode())) {
-				Map<String, String> productDetails = PLUList.get(product.getPLUCode());
-				productDetails.put("price", String.valueOf(product.getPrice()));
-				productDetails.put("name", product.getDescription());
-				PLUList.replace(product.getPLUCode(), productDetails);
-			} else {
-				throw new SimulationException(
-						"this PLU code product does not match any of the PLU coded items on list");
-			}
-		}
-	}
-
-	/**
-	 * Add product to the store database. Input item and product must be of the same
-	 * type (barcode / PLU code).
-	 * 
-	 * @param item    Item to be added to the database.
-	 * @param product Product to be added to the database.
-	 */
-	public void addProduct(Item item, Product product) {
-		if (item == null || product == null) {
-			throw new SimulationException(new NullPointerException());
-		}
-		if (item instanceof BarcodedItem && product instanceof BarcodedProduct) {
-			Barcode barcode = ((BarcodedItem) item).getBarcode();
-			Map<String, String> details = new HashMap<>();
-			details.put("weight", String.valueOf(item.getWeight()));
-			details.put("price", String.valueOf(product.getPrice()));
-			details.put("name", ((BarcodedProduct) product).getDescription());
-			if (barcodeList.containsKey(barcode)) {
-				barcodeList.replace(barcode, details);
-			} else {
-				barcodeList.put(barcode, details);
-				barcodeItemCount++;
-			}
-		} else if (item instanceof PLUCodedItem && product instanceof PLUCodedProduct) {
-			PriceLookupCode PLUcode = ((PLUCodedItem) item).getPLUCode();
-			Map<String, String> details = new HashMap<>();
-			details.put("weight", String.valueOf(item.getWeight()));
-			details.put("price", String.valueOf(product.getPrice()));
-			details.put("name", ((PLUCodedProduct) product).getDescription());
-			if (PLUList.containsKey(PLUcode)) {
-				PLUList.replace(PLUcode, details);
-			} else {
-				PLUList.put(PLUcode, details);
-				pluItemCount++;
-			}
-		} else {
-			throw new SimulationException("invalid item/product input");
-		}
-	}
-
-	/**
-	 * Update product information in the database. Input item and product must be of
-	 * the same type (barcode / PLU code).
-	 * 
-	 * @param item    Item to be updated in the database.
-	 * @param product Product to be updated in the database.
-	 */
-	public void updateProduct(Item item, Product product) {
-		if (item == null && product == null) {
-			throw new SimulationException("invalid item/product input");
-		}
-
-		if (item != null && product == null) {
-			if (item instanceof BarcodedItem) {
-				Barcode barcode = ((BarcodedItem) item).getBarcode();
-				Map<String, String> itemDetails = barcodeList.get(barcode);
-				itemDetails.replace("weight", String.valueOf(item.getWeight()));
-			} else if (item instanceof PLUCodedItem) {
-				PriceLookupCode PLUcode = ((PLUCodedItem) item).getPLUCode();
-				Map<String, String> itemDetails = PLUList.get(PLUcode);
-				itemDetails.replace("weight", String.valueOf(item.getWeight()));
-			} else {
-				throw new SimulationException("unknown item");
-			}
-		} else if (item == null && product != null) {
-			if (product instanceof BarcodedProduct) {
-				Barcode barcode = ((BarcodedProduct) product).getBarcode();
-				Map<String, String> productDetails = barcodeList.get(barcode);
-				productDetails.replace("price", String.valueOf(product.getPrice()));
-				productDetails.replace("name", ((BarcodedProduct) product).getDescription());
-			} else if (product instanceof PLUCodedProduct) {
-				PriceLookupCode PLUcode = ((PLUCodedProduct) product).getPLUCode();
-				Map<String, String> productDetails = PLUList.get(PLUcode);
-				productDetails.replace("price", String.valueOf(product.getPrice()));
-				productDetails.replace("name", ((PLUCodedProduct) product).getDescription());
-			} else {
-				throw new SimulationException("unknown product");
-			}
-		} else if (item != null && product != null) {
-			if (item instanceof BarcodedItem) {
-				Barcode barcode = ((BarcodedItem) item).getBarcode();
-				Map<String, String> details = barcodeList.get(barcode);
-				details.replace("weight", String.valueOf(item.getWeight()));
-				details.replace("price", String.valueOf(product.getPrice()));
-				details.replace("name", ((BarcodedProduct) product).getDescription());
-			} else if (item instanceof PLUCodedItem) {
-				PriceLookupCode PLUcode = ((PLUCodedItem) item).getPLUCode();
-				Map<String, String> details = PLUList.get(PLUcode);
-				details.replace("weight", String.valueOf(item.getWeight()));
-				details.replace("price", String.valueOf(product.getPrice()));
-				details.replace("name", ((PLUCodedProduct) product).getDescription());
-			} else {
-				throw new SimulationException("unknown item");
-			}
-		}
-	}
-
-	/**
-	 * Remove product from the database. Input item and product must be of the same
-	 * type (barcode / PLU code).
-	 * 
-	 * @param item    Item to be removed from the database.
-	 * @param product Product to be removed from the database.
-	 */
-	public void removeProduct(Item item, Product product) {
-		if (item == null && product == null) {
-			throw new SimulationException("invalid item/product input");
-		}
-
-		if (item instanceof BarcodedItem || product instanceof BarcodedProduct) {
-			Barcode barcode;
-			if (item != null) {
-				barcode = ((BarcodedItem) item).getBarcode();
-			} else {
-				barcode = ((BarcodedProduct) product).getBarcode();
-			}
-			barcodeList.remove(barcode);
-			barcodeItemCount--;
-		} else if (item instanceof PLUCodedItem || product instanceof PLUCodedProduct) {
-			PriceLookupCode PLUcode;
-			if (item != null) {
-				PLUcode = ((PLUCodedItem) item).getPLUCode();
-			} else {
-				PLUcode = ((PLUCodedProduct) product).getPLUCode();
-			}
-			PLUList.remove(PLUcode);
-			pluItemCount--;
-		} else {
-			throw new SimulationException("unknown item");
-		}
-	}
-
-	/**
-	 * Accesses the number of barcoded items.
-	 * 
-	 * @return The number of barcoded items in the database.
-	 */
-	public int getBarcodeItemCount() {
-		return barcodeItemCount;
-	}
-
-	/**
-	 * Accesses the number of PLU coded items.
-	 * 
-	 * @return The number of PLU coded items in the database.
-	 */
-	public int getPluItemCount() {
-		return pluItemCount;
-	}
-
-	/**
-	 * Accesses the current barcode item list.
-	 * 
-	 * @return The current barcode item list in the store.
-	 */
-	public Map<Barcode, Map<String, String>> getBarcodeList() {
-		return barcodeList;
-	}
-
-	/**
-	 * Accesses the current PLU code item list.
-	 * 
-	 * @return The current PLU code item list in the store.
-	 */
-	public Map<PriceLookupCode, Map<String, String>> getPLUList() {
-		return PLUList;
-	}
-}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java
new file mode 100644
index 0000000..cb9bc31
--- /dev/null
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/BaggingAreaController.java	
@@ -0,0 +1,106 @@
+package org.lsmr.selfcheckout.customer;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class BaggingAreaController {
+
+	private final SelfCheckoutStation checkoutStation;
+	private BAC bac;
+	private double weightOfCart;
+	private ScanItemController scanItemControl;
+	private int numOfItemsInBaggingArea;
+	private double previousWeightOfCart;
+	
+	
+	//Constructor
+	public BaggingAreaController(SelfCheckoutStation cs) {
+		
+		checkoutStation = cs;
+		bac = new BAC();
+		weightOfCart = 0;
+		this.scanItemControl = null;
+		numOfItemsInBaggingArea =0;
+		
+		
+		//Register observers to the scanner
+		checkoutStation.scale.attach(bac);
+		
+	}
+	
+	//Connect bagging area control to scan item control
+	public void setScanItemControl(ScanItemController sIController)
+	{
+		this.scanItemControl = sIController;
+	}
+	
+	public int getNumOfItemsInBaggingArea() {
+		return numOfItemsInBaggingArea;
+	}
+	
+	
+	
+	private class BAC implements ElectronicScaleObserver{
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// Ignore
+		
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// Ignore
+			
+		}
+
+		
+		@Override
+		public void weightChanged(ElectronicScale scale, double weightInGrams) {
+			previousWeightOfCart = weightOfCart;
+			weightOfCart = weightInGrams;
+			 
+			//Alter number of items in bagging area based on weight changed
+			if(weightOfCart > previousWeightOfCart) {
+				numOfItemsInBaggingArea++;
+			}else {
+				numOfItemsInBaggingArea--;
+			}
+			
+			//Once item has been placed in bagging area, enable the scanner
+			//If expected weight of cart (determined by scanner)
+			//Is the same of actual weigh of cart (determined by electronic scale)
+			if(scanItemControl.getWeightOfCart() == weightOfCart) {
+				checkoutStation.scanner.enable();
+			}else {
+				checkoutStation.scanner.disable();
+			}
+			
+		}
+
+		//Disable bar code scanner
+		@Override
+		public void overload(ElectronicScale scale) {
+			checkoutStation.scanner.disable();
+		}
+
+		//Enable bar code scanner
+		@Override
+		public void outOfOverload(ElectronicScale scale) {
+			checkoutStation.scanner.enable();	
+		}
+		
+	}
+	
+	
+	
+	public double getWeightOfCart() {
+		return weightOfCart;
+	}
+	
+	
+	
+
+}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java
new file mode 100644
index 0000000..4c49d87
--- /dev/null
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/PaymentController.java	
@@ -0,0 +1,174 @@
+package org.lsmr.selfcheckout.customer;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Currency;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+import org.lsmr.selfcheckout.devices.CoinTray;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+
+public class PaymentController{
+
+	private BigDecimal valueOfCart;
+	private final SelfCheckoutStation checkoutStation; 
+	private PCC pcc;
+	private PCB pcb;
+	private List<Coin> coinTrayList;
+	private BigDecimal initialValueOfCart;
+	
+	
+	//Customer checkout use case 
+	public PaymentController(SelfCheckoutStation cs){
+		checkoutStation = cs;
+		initialValueOfCart = new BigDecimal(0);
+		valueOfCart = new BigDecimal(0);
+		coinTrayList = new ArrayList<Coin>();
+		
+		
+		//Initializing observers
+		pcc = new PCC();
+		pcb = new PCB();
+		
+		//Register observers in the coin related devices
+		checkoutStation.coinSlot.attach(pcc);
+		checkoutStation.coinValidator.attach(pcc);
+		checkoutStation.coinTray.attach(pcc);
+		
+		//Registers observers in the bank note related devices
+		checkoutStation.banknoteInput.attach(pcb);
+		checkoutStation.banknoteValidator.attach(pcb);
+		checkoutStation.banknoteInput.attach(pcb);
+	}
+	
+	public BigDecimal getValueOfCart() {
+		return valueOfCart;
+	}
+	
+	public BigDecimal getInitialValueOfCart() {
+		return initialValueOfCart;
+	}
+	
+	public void setValueOfCart(BigDecimal cartValue) {
+		initialValueOfCart = cartValue;
+		valueOfCart = cartValue;
+	}
+	
+	
+	//If all items have been paid for, return true
+	//And disable the coin and bank note slot
+	public boolean isAllItemPaid() {
+		if (valueOfCart.compareTo(new BigDecimal(0)) == -1 || valueOfCart.compareTo(new BigDecimal(0)) == 0 ) {
+			checkoutStation.coinSlot.disable();
+			checkoutStation.banknoteInput.disable();
+			return true;
+		}
+		return false;
+	}
+	
+
+	public List<Coin> getCoinTrayList() {
+		return coinTrayList;
+	}
+	
+	//COIN PAYMENT - Implementation of Coin observers
+	private class PCC implements CoinSlotObserver, CoinValidatorObserver, CoinTrayObserver{
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// Ignore	
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// Ignore
+		}
+
+		
+		@Override
+		public void coinInserted(CoinSlot slot) {
+			// Ignore
+		}
+
+		
+		@Override
+		public void validCoinDetected(CoinValidator validator, BigDecimal value) {
+			valueOfCart = valueOfCart.subtract(value);
+			isAllItemPaid();
+		}
+
+		@Override
+		public void invalidCoinDetected(CoinValidator validator) {
+			//Ignore 
+		}
+		
+		@Override
+		public void coinAdded(CoinTray tray) {
+			
+			//Simulates removal of coin from the coin tray
+			for(Coin theCoin :tray.collectCoins() ) {
+				coinTrayList.add(theCoin);
+			}
+			
+		}
+	}
+	
+	
+	
+	
+	//BANKNOTE PAYMENT - Implementation of Bank note observers
+	private class PCB implements BanknoteSlotObserver, BanknoteValidatorObserver{
+		
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {			
+			//Ignore
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			//Ignore
+		}
+		
+		@Override
+		public void banknoteInserted(BanknoteSlot slot) {
+			//Ignore 
+		}
+
+		
+		@Override
+		public void banknoteEjected(BanknoteSlot slot) {
+			//Ignore
+		}
+
+		@Override
+		public void banknoteRemoved(BanknoteSlot slot) {
+			//Ignore
+		}
+
+		@Override
+		public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
+			//Subtract the value of cart from the customer bank note value
+			BigDecimal bigDecimalVal = new BigDecimal(value);
+			valueOfCart = valueOfCart.subtract(bigDecimalVal);
+			isAllItemPaid();
+		}
+
+		@Override
+		public void invalidBanknoteDetected(BanknoteValidator validator) {
+			// Ignore
+		}
+	}
+	
+}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java
new file mode 100644
index 0000000..4918cbd
--- /dev/null
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ReceiptPrinterController.java	
@@ -0,0 +1,108 @@
+package org.lsmr.selfcheckout.customer;
+
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+public class ReceiptPrinterController {
+
+	private final SelfCheckoutStation checkoutStation;
+	private RPC rpc;
+	private ScanItemController scanControl;
+	private PaymentController payControl;
+	private HashMap<Barcode, BigDecimal> barcodePrice;
+	private HashMap<Barcode, String> barcodeDescription;
+	private String receiptMessage;
+	
+	public ReceiptPrinterController(SelfCheckoutStation cs, HashMap<Barcode, BigDecimal> barcodePrice,
+			HashMap<Barcode, String> barcodeDescription) {
+		
+		checkoutStation = cs;
+		rpc = new RPC();
+		this.scanControl = null;
+		this.payControl = null;
+		this.barcodePrice = barcodePrice;
+		this.barcodeDescription = barcodeDescription;
+		receiptMessage = "";
+		
+		//Add ink and paper to the printer
+		checkoutStation.printer.addPaper(8);
+		checkoutStation.printer.addInk(15);
+	
+		//Register observers to the scanner
+		checkoutStation.printer.attach(rpc);
+		
+	}
+	
+	//Calls the printer to print item description and price
+	public void printReceipt() {
+		receiptMessage = "";
+		for(Barcode barcode: scanControl.getScannedItemList()) {
+			receiptMessage = receiptMessage +
+					barcodeDescription.get(barcode) + " " 
+					+ barcodePrice.get(barcode) + "\n";
+		}
+		receiptMessage = receiptMessage + "Total Price: " + payControl.getInitialValueOfCart();
+	
+		for(int i =0; i < receiptMessage.length(); i++) {
+			checkoutStation.printer.print(receiptMessage.charAt(i));		
+		}
+	}
+	
+	//Returns the receipts message
+	public String getReceipt() {
+		return receiptMessage;
+	}
+	
+	//Connect Receipt Printer controller with other controllers
+	public void setControllers(ScanItemController scanControl,PaymentController payControl ) {
+		this.scanControl = scanControl;
+		this.payControl = payControl;
+	}
+	
+	
+	public class RPC implements ReceiptPrinterObserver {
+
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// Ignore
+			
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// Ignore
+			
+		}
+
+		@Override
+		public void outOfPaper(ReceiptPrinter printer) {
+			checkoutStation.printer.addPaper(8);
+		}
+
+		@Override
+		public void outOfInk(ReceiptPrinter printer) {
+			checkoutStation.printer.addInk(15);
+		}
+
+		@Override
+		public void paperAdded(ReceiptPrinter printer) {
+			// Ignore
+			
+		}
+
+		@Override
+		public void inkAdded(ReceiptPrinter printer) {
+			// Ignore
+			
+		}
+			
+	}
+}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java
new file mode 100644
index 0000000..4674b9d
--- /dev/null
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/ScanItemController.java	
@@ -0,0 +1,127 @@
+package org.lsmr.selfcheckout.customer;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+
+public class ScanItemController  {
+	 
+
+	private final SelfCheckoutStation checkoutStation; 
+	private BigDecimal valueOfCart; //total cost of item field
+	private Double weightOfCart;
+	private HashMap<Barcode, BigDecimal> barcodePrice; //Map barcode to price
+	private HashMap<Barcode, Double> barcodeWeight;
+	private SIC sic;
+	private List<Barcode> scannedItemList;  
+	private BaggingAreaController bagAreaControl;	
+	
+
+	//Constructor
+	public ScanItemController(SelfCheckoutStation cs, HashMap<Barcode, BigDecimal> barcodePrice, 
+		HashMap<Barcode, Double> barcodeWeight) {
+		checkoutStation = cs;
+		valueOfCart = new BigDecimal(0);
+		weightOfCart = 0.0;
+		sic = new SIC();
+		this.barcodePrice = barcodePrice;
+		this.barcodeWeight = barcodeWeight;
+		this.bagAreaControl = null;
+		scannedItemList = new ArrayList<Barcode>();
+		
+		
+		
+		//Register observers in the scanner
+		checkoutStation.scanner.attach(sic);
+		
+	}
+	
+	//Gives ScanItemController access to BaggingAreaController
+	public void setBagAreaControl(BaggingAreaController bAController)
+	{
+		this.bagAreaControl = bAController;
+	}
+	
+	//Returns the number of item scanned
+	public int numOfScannedItems() {
+		return scannedItemList.size();
+	}
+	
+	public List<Barcode> getScannedItemList(){
+		return scannedItemList;
+	}
+	
+	//Remove item from scan
+	//Decrease the scanner expected weight of cart
+	//Enable the scanner if expected weight of cart and actual weight of cart matches
+	public void unScanItem(Barcode barcode) {
+		int index = scannedItemList.indexOf(barcode);
+		if(index == -1)
+			return;
+		scannedItemList.remove(index);
+		weightOfCart = weightOfCart - barcodeWeight.get(barcode);
+		valueOfCart = valueOfCart.subtract(barcodePrice.get(barcode));
+		
+		if(bagAreaControl.getWeightOfCart() == weightOfCart) {
+			checkoutStation.scanner.enable();
+		}
+	}
+	
+	//Barcode Scanner Observer Implementation
+	public class SIC implements BarcodeScannerObserver {
+		
+		@Override
+		public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+			// Ignore
+		}
+
+		@Override
+		public void disabled(AbstractDevice<? extends AbstractDeviceObserver> devicenop) {
+			// Ignore	
+		}
+
+		//Retrieve the bar code and use hash map to retrieve price
+		//Update the value of the cart
+		@Override
+		public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
+			if(weightOfCart + barcodeWeight.get(barcode) <= checkoutStation.scale.getWeightLimit()) {
+				weightOfCart = weightOfCart + barcodeWeight.get(barcode);	
+			}
+
+			valueOfCart = valueOfCart.add(barcodePrice.get(barcode));
+			scannedItemList.add(barcode);
+			
+			
+			//Once an item is scanned, disable the scanner
+			//If expected weight of cart (determined by scanner)
+			//Is not the same of actual weigh of cart (determined by electronic scale)
+			if(bagAreaControl.getWeightOfCart() != weightOfCart) {
+				checkoutStation.scanner.disable();
+			}else {
+				checkoutStation.scanner.enable();
+			}
+			
+			
+		}
+	}
+	
+	
+	
+	public BigDecimal getValueOfCart() {
+		return valueOfCart;
+	}
+	
+	public Double getWeightOfCart() {
+		return weightOfCart;
+	}
+
+}
diff --git a/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java
new file mode 100644
index 0000000..8af1db6
--- /dev/null
+++ b/SCS - Software/src/org/lsmr/selfcheckout/customer/TouchScreenController.java	
@@ -0,0 +1,33 @@
+package org.lsmr.selfcheckout.customer;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+
+
+public class TouchScreenController  {
+		
+	private final SelfCheckoutStation checkoutStation;
+	
+	//Constructor - Initialize SelfCheckoutStation
+	
+	/**
+	 * Creates a new touch screen controller for the specified checkout station.
+	 */
+	public TouchScreenController(SelfCheckoutStation cs) {
+		checkoutStation = cs;
+	}
+	
+	/**
+	 * Enables the scanner to allow the user to begin scanning items.
+	 */
+	public void initiateStart() {
+		checkoutStation.scanner.enable();
+	}
+	
+	/**
+	 * To be triggered after all items are scanned. Disables scanner and allows the user to pay with cash.
+	 */
+	public void inititateCheckout() {
+		checkoutStation.scanner.disable();
+		checkoutStation.coinSlot.enable();
+		checkoutStation.banknoteInput.enable();
+	}
+}

commit c2942727d930bbb0ec57819a70edf7cc421747b7
Author: NuclearTea <muhammad.ali4@ucalgary.ca>
Date:   Thu Mar 24 15:25:58 2022 -0600

    Ali's group explanation page

diff --git a/Explaination_Page.pdf b/Explaination_Page.pdf
new file mode 100644
index 0000000..4d06b0e
--- /dev/null
+++ b/Explaination_Page.pdf
@@ -0,0 +1,23 @@
+Team 1:
+    ● Fu-Yin Lin
+    ● Ryan McHale
+    ● Karim Kassouri
+    ● Munhib Saad
+    ● Parker Wieck
+    ● Muhammad Ali
+    ● Ayomide Alabi
+
+Store.java contains functions that will likely be useful for later releases. However, given that it
+covers material irrelevant to iteration 1, only the relevant sections have been tested. The main
+section that is excluded has to do with PLU codes.
+
+The use case related to “Customer wishes to checkout” appears to rely on hardware simulations
+not yet implemented. We have given an example of what this may look like in the
+commented-out method “touchScreenButtonPressed()” within the
+SelfCheckoutStationLogic.java file. This function was Ayomide Alabi’s contribution, they did not
+push the change themselves due to technical difficulties.
+
+Finally, the test “scanPlaceMismatchWithinSensitivity” interacts with the underlying hardware
+simulation and includes a random chance of failure. If this test fails, please rerun the test a few
+times.
+
\ No newline at end of file

commit 3c4a65f4abbb0dc3899f95f322c0afbaf48d9795
Author: NuclearTea <muhammad.ali4@ucalgary.ca>
Date:   Thu Mar 24 14:56:47 2022 -0600

    Ali's group version

diff --git a/SCS - Software - Test/.classpath b/SCS - Software - Test/.classpath
new file mode 100644
index 0000000..7dc8995
--- /dev/null
+++ b/SCS - Software - Test/.classpath	
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-16">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="src" path="/SCS - Software"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/SCS - Software - Test/.gitignore b/SCS - Software - Test/.gitignore
new file mode 100644
index 0000000..ae3c172
--- /dev/null
+++ b/SCS - Software - Test/.gitignore	
@@ -0,0 +1 @@
+/bin/
diff --git a/SCS - Software - Test/.project b/SCS - Software - Test/.project
new file mode 100644
index 0000000..14704e1
--- /dev/null
+++ b/SCS - Software - Test/.project	
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Software - Test</name>
+	<comment></comment>
+	<projects>
+		<project>SCS - Hardware - v1.0</project>
+		<project>SCS - Software</project>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/SCS - Software - Test/.settings/org.eclipse.jdt.core.prefs b/SCS - Software - Test/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..8aabe8d
--- /dev/null
+++ b/SCS - Software - Test/.settings/org.eclipse.jdt.core.prefs	
@@ -0,0 +1,14 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=16
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=16
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
+org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.source=16
diff --git a/SCS - Software - Test/src/SelfCheckoutStationLogicTests.java b/SCS - Software - Test/src/SelfCheckoutStationLogicTests.java
new file mode 100644
index 0000000..334b585
--- /dev/null
+++ b/SCS - Software - Test/src/SelfCheckoutStationLogicTests.java	
@@ -0,0 +1,296 @@
+import static org.junit.Assert.*;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Currency;
+import java.util.Locale;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
+
+import Control.SelfCheckoutStationLogic;
+import Control.Store;
+
+/**
+ * Test Suite for Self-Checkout Station Logic.
+ * 
+ * @author Fu-Yin Lin
+ * @author Ryan McHale
+ * @author Karim Kassouri
+ * @author Munhib Saad
+ * @author Parker Wieck
+ * @author Muhammad Ali
+ * @author Ayomide Alabi
+ *
+ */
+public class SelfCheckoutStationLogicTests {
+
+	private Currency validCurrency;
+	private Currency invalidCurrency;
+	private int banknoteDenominations[] = { 5, 10, 20, 50, 100 };
+	private BigDecimal coinDenominations[] = { BigDecimal.valueOf(0.05), BigDecimal.valueOf(0.10),
+			BigDecimal.valueOf(0.25), BigDecimal.valueOf(1.00), BigDecimal.valueOf(2.00) };
+	private SelfCheckoutStation selfCheckoutStation;
+	private SelfCheckoutStationLogic selfCheckoutStationLogic;
+	private Store store;
+
+	private ElectronicScale testES;
+	private Item heavyItem;
+	private Item normalItem;
+	private Item lightItem;
+
+	BarcodedItem barcodedLightItem;
+	BarcodedItem barcodedNormalItem;
+	BarcodedItem barcodedHeavyItem;
+
+	private class ItemStub extends Item {
+
+		protected ItemStub(double weightInGrams) {
+			super(weightInGrams);
+		}
+
+	}
+
+	@Before
+	public void setUp() {
+		validCurrency = Currency.getInstance("CAD");
+		invalidCurrency = Currency.getInstance("USD");
+		selfCheckoutStation = new SelfCheckoutStation(validCurrency, banknoteDenominations, coinDenominations, 100, 1);
+		store = new Store(3, 3);
+
+		Numeral numerals1[] = { Numeral.valueOf((byte) 1) };
+		Numeral numerals2[] = { Numeral.valueOf((byte) 2) };
+		Numeral numerals3[] = { Numeral.valueOf((byte) 3) };
+
+		Barcode barcode1 = new Barcode(numerals1);
+		Barcode barcode2 = new Barcode(numerals2);
+		Barcode barcode3 = new Barcode(numerals3);
+
+		barcodedLightItem = new BarcodedItem(barcode1, 1);
+		barcodedNormalItem = new BarcodedItem(barcode2, 1);
+		barcodedHeavyItem = new BarcodedItem(barcode3, 1);
+
+		BarcodedItem barcodedItems[] = { barcodedLightItem, barcodedNormalItem, barcodedHeavyItem };
+
+		BarcodedProduct barcodedProducts[] = { new BarcodedProduct(barcode1, "foo", BigDecimal.ONE),
+				new BarcodedProduct(barcode1, "bar", BigDecimal.ONE),
+				new BarcodedProduct(barcode1, "foobar", BigDecimal.ONE) };
+
+		store.barcodeConfigure(barcodedItems, barcodedProducts);
+
+		selfCheckoutStationLogic = new SelfCheckoutStationLogic(selfCheckoutStation, store);
+
+		testES = new ElectronicScale(5, 2);
+		heavyItem = new ItemStub(10);
+		normalItem = new ItemStub(2);
+		lightItem = new ItemStub(1);
+	}
+
+	///////////////////////////////////////////////////////
+	// GENERAL TESTS
+	///////////////////////////////////////////////////////
+
+	@Test(expected = SimulationException.class)
+	public void constructor_error_test() {
+		SelfCheckoutStationLogic scsl = new SelfCheckoutStationLogic(null, null);
+	}
+
+	@Test(expected = SimulationException.class)
+	public void constructor_error_test_2() {
+		SelfCheckoutStationLogic scsl = new SelfCheckoutStationLogic(selfCheckoutStation, null);
+	}
+
+	@Test
+	public void enabled_disabled_test() throws DisabledException {
+		selfCheckoutStation.banknoteValidator.enable();
+		selfCheckoutStation.banknoteValidator.disable();
+		// success
+	}
+
+	///////////////////////////////////////////////////////
+	// PAYMENT TESTS
+	///////////////////////////////////////////////////////
+
+	@Test
+	public void validBanknoteDetected_test() throws DisabledException, OverloadException {
+		Banknote banknote = new Banknote(validCurrency, 5);
+		selfCheckoutStation.banknoteInput.accept(banknote);
+		assertTrue(selfCheckoutStationLogic.getTotalPayment() == 5);
+	}
+
+	@Test
+	public void invalidBanknoteDetected_test() throws DisabledException, OverloadException {
+		Banknote banknote = new Banknote(invalidCurrency, 5);
+		selfCheckoutStation.banknoteInput.accept(banknote);
+		assertTrue(selfCheckoutStationLogic.getTotalPayment() == 0);
+
+	}
+
+	@Test
+	public void validCoinDetected_test() throws DisabledException, OverloadException {
+		Coin coin = new Coin(validCurrency, BigDecimal.valueOf(0.05));
+		selfCheckoutStation.coinSlot.accept(coin);
+		assertTrue(selfCheckoutStationLogic.getTotalPayment() == 0.05);
+
+	}
+
+	@Test
+	public void invalidCoinDetected_test() throws DisabledException, OverloadException {
+		Coin coin = new Coin(invalidCurrency, BigDecimal.valueOf(0.05));
+		selfCheckoutStation.coinSlot.accept(coin);
+		assertTrue(selfCheckoutStationLogic.getTotalPayment() == 0);
+
+	}
+
+	@Test
+	public void printRecipt_test() throws DisabledException, OverloadException {
+		selfCheckoutStationLogic.printReceipt();
+	}
+
+	////////////////
+	// BAGGING TESTS
+	///////////////
+
+	@Test(expected = OverloadException.class)
+	public void overload_test() throws OverloadException {
+		heavyItem = new ItemStub(999);
+		selfCheckoutStation.scale.add(heavyItem);
+
+		selfCheckoutStation.scale.getCurrentWeight();
+
+	}
+
+	@Test
+	public void outOfOverload_test() throws OverloadException {
+		heavyItem = new ItemStub(999);
+		selfCheckoutStation.scale.add(heavyItem);
+
+		selfCheckoutStation.scale.remove(heavyItem);
+
+		assertTrue(selfCheckoutStation.scale.getCurrentWeight() == 0);
+	}
+
+	@Test
+	public void normalItemAdded_noItemExpected() throws OverloadException {
+		selfCheckoutStation.scale.add(normalItem);
+
+		assertTrue(selfCheckoutStation.scale.getCurrentWeight() == normalItem.getWeight());
+	}
+
+	@Test
+	public void scanPlaceMismatchWithinSensitivity() throws OverloadException {
+
+		selfCheckoutStation.scanner.scan(barcodedLightItem);
+
+		selfCheckoutStation.scale.add(normalItem);
+
+		assertFalse(selfCheckoutStationLogic.getWaitForAttendant());
+	}
+
+	@Test
+	public void printRecipt() {
+		selfCheckoutStation.scanner.scan(barcodedLightItem);
+
+		selfCheckoutStation.scale.add(lightItem);
+
+		selfCheckoutStation.printer.addPaper(100);
+		selfCheckoutStation.printer.addInk(100);
+
+		selfCheckoutStationLogic.printReceipt();
+
+		// success
+	}
+
+	@Test
+	public void removingItem() throws OverloadException {
+
+		selfCheckoutStation.scale.add(normalItem);
+
+		selfCheckoutStation.scanner.scan(barcodedLightItem);
+
+		selfCheckoutStation.scale.remove(normalItem);
+
+		assertTrue(selfCheckoutStationLogic.getWaitForAttendant());
+
+	}
+
+	@Test(expected = SimulationException.class)
+	public void barcodeScannedBarcodeNull() {
+		Currency Banknote = Currency.getInstance(Locale.US);
+		int[] validBanknoteDenomination = { 5 };
+		BigDecimal[] ValidCoinDenomination = { BigDecimal.valueOf(0.05) };
+		SelfCheckoutStation SCSTest = new SelfCheckoutStation(Banknote, validBanknoteDenomination,
+				ValidCoinDenomination, 5, 2);
+		Store s = new Store(1, 1);
+		SelfCheckoutStationLogic TestSM = new SelfCheckoutStationLogic(SCSTest, s);
+
+		Barcode testBarcode = null;
+		BarcodeScanner testBS = null;
+
+		TestSM.barcodeScanned(testBS, testBarcode);
+
+	}
+
+	@Test
+	public void barcodeScannedContainsBarcode() {
+
+		BarcodedItem[] barcodedItems = new BarcodedItem[1];
+
+		Numeral[] numerals = new Numeral[1];
+		numerals[0] = Numeral.valueOf((byte) 1);
+		Barcode testBarcode = new Barcode(numerals);
+		barcodedItems[0] = new BarcodedItem(testBarcode, 10.0);
+
+		BarcodedProduct[] barcodedProducts = new BarcodedProduct[1];
+		barcodedProducts[0] = new BarcodedProduct(testBarcode, "foo", BigDecimal.ONE);
+
+		Currency Banknote = Currency.getInstance(Locale.US);
+		int[] validBanknoteDenomination = { 5 };
+		BigDecimal[] ValidCoinDenomination = { BigDecimal.valueOf(0.05) };
+		SelfCheckoutStation SCSTest = new SelfCheckoutStation(Banknote, validBanknoteDenomination,
+				ValidCoinDenomination, 5, 2);
+
+		Store s = new Store(1, 1);
+
+		s.barcodeConfigure(barcodedItems, barcodedProducts);
+
+		SelfCheckoutStationLogic TestSM = new SelfCheckoutStationLogic(SCSTest, s);
+
+		BarcodeScanner testBS = null;
+
+		double originalTotalCost = Double.parseDouble((TestSM).getBarcodeList().get(testBarcode).get("price"));
+
+		double originalExpectedWeight = Double.parseDouble(TestSM.getBarcodeList().get(testBarcode).get("weight"));
+
+		// Causes scannedItemList to put testBarcode in
+		TestSM.barcodeScanned(testBS, testBarcode);
+
+		double afterTotalCost = Double.parseDouble(TestSM.getBarcodeList().get(testBarcode).get("price"));
+
+		double afterExpectedWeight = Double.parseDouble(TestSM.getBarcodeList().get(testBarcode).get("weight"));
+
+		System.out.println(originalExpectedWeight + " " + afterExpectedWeight);
+		System.out.println(originalTotalCost + " " + afterTotalCost);
+		// scannedItemList already has testBarcode
+		// forcing scannedItemList to contain testBarcode
+		TestSM.barcodeScanned(testBS, testBarcode);
+
+		assertEquals(TestSM.getTotalCost(), afterTotalCost + originalTotalCost, 0.01);
+		assertEquals(TestSM.getTotalExpectedWeight(), afterExpectedWeight, 0.01);
+
+	}
+}
diff --git a/SCS - Software - Test/src/StoreTests.java b/SCS - Software - Test/src/StoreTests.java
new file mode 100644
index 0000000..6ed44d3
--- /dev/null
+++ b/SCS - Software - Test/src/StoreTests.java	
@@ -0,0 +1,165 @@
+
+/**
+ * Test Suite for Store class.
+ * 
+ * @author Fu-Yin Lin
+ * @author Ryan McHale
+ * @author Karim Kassouri
+ * @author Munhib Saad
+ * @author Parker Wieck
+ * @author Muhammad Ali
+ * @author Ayomide Alabi
+ *
+ */
+
+import static org.junit.Assert.*;
+
+import java.math.BigDecimal;
+import java.util.Map;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.PriceLookupCode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
+import org.lsmr.selfcheckout.products.PLUCodedProduct;
+
+import Control.Store;
+
+public class StoreTests {
+
+	@Before
+	public void setUp() throws Exception {
+
+	}
+
+	@Test(expected = SimulationException.class)
+	public void item_count_must_be_non_negative() {
+		int barcodeItemCount = -1;
+		int pluItemCount = 5;
+		new Store(barcodeItemCount, pluItemCount);
+	}
+
+	@Test(expected = SimulationException.class)
+	public void plu_item_count_must_be_non_negative() {
+		int barcodeItemCount = 1;
+		int pluItemCount = -1;
+		new Store(barcodeItemCount, pluItemCount);
+	}
+
+	@Test
+	public void store_construction() {
+		new Store(4, 4);
+	}
+
+	@Test(expected = SimulationException.class)
+	public void improper_length_of_barcodedItems() {
+		BarcodedItem[] barcodedItems = new BarcodedItem[0];
+		BarcodedProduct[] barcodedProducts = new BarcodedProduct[1];
+		Store s = new Store(1, 1);
+		s.barcodeConfigure(barcodedItems, barcodedProducts);
+	}
+
+	@Test(expected = SimulationException.class)
+	public void improper_length_of_barcodedProducts() {
+		BarcodedItem[] barcodedItems = new BarcodedItem[1];
+		BarcodedProduct[] barcodedProducts = new BarcodedProduct[0];
+		Store s = new Store(1, 1);
+		s.barcodeConfigure(barcodedItems, barcodedProducts);
+	}
+
+	@Test
+	public void basic_passing_config_call() {
+		BarcodedItem[] barcodedItems = new BarcodedItem[1];
+
+		Numeral[] numerals = new Numeral[1];
+		numerals[0] = Numeral.valueOf((byte) 1);
+		barcodedItems[0] = new BarcodedItem(new Barcode(numerals), 10.0);
+
+		BarcodedProduct[] barcodedProducts = new BarcodedProduct[1];
+		barcodedProducts[0] = new BarcodedProduct(new Barcode(numerals), "foo", BigDecimal.ONE);
+
+		Store s = new Store(1, 1);
+		s.barcodeConfigure(barcodedItems, barcodedProducts);
+	}
+
+	@Test
+	public void duplicated_barcode() {
+		BarcodedItem[] barcodedItems = new BarcodedItem[2];
+
+		Numeral[] numerals = new Numeral[1];
+		numerals[0] = Numeral.valueOf((byte) 1);
+		barcodedItems[0] = new BarcodedItem(new Barcode(numerals), 10.0);
+		barcodedItems[1] = new BarcodedItem(new Barcode(numerals), 6.0);
+
+		BarcodedProduct[] barcodedProducts = new BarcodedProduct[2];
+		barcodedProducts[0] = new BarcodedProduct(new Barcode(numerals), "foo", BigDecimal.ONE);
+		barcodedProducts[1] = new BarcodedProduct(new Barcode(numerals), "foo", BigDecimal.TEN);
+
+		Store s = new Store(2, 2);
+		s.barcodeConfigure(barcodedItems, barcodedProducts);
+	}
+
+	@Test(expected = SimulationException.class)
+	public void product_with_barcode_not_in_items() {
+		Numeral[] item_numerals = new Numeral[1];
+		item_numerals[0] = Numeral.valueOf((byte) 1);
+
+		Numeral[] product_numerals = new Numeral[2];
+		product_numerals[0] = Numeral.valueOf((byte) 1);
+		product_numerals[1] = Numeral.valueOf((byte) 1);
+
+		BarcodedItem[] barcodedItems = new BarcodedItem[1];
+		barcodedItems[0] = new BarcodedItem(new Barcode(item_numerals), 10.0);
+
+		BarcodedProduct[] barcodedProducts = new BarcodedProduct[1];
+		barcodedProducts[0] = new BarcodedProduct(new Barcode(product_numerals), "foo", BigDecimal.ONE);
+
+		Store s = new Store(1, 1);
+		s.barcodeConfigure(barcodedItems, barcodedProducts);
+	}
+
+	@Test
+	public void get_barcode_list() {
+		BarcodedItem[] barcodedItems = new BarcodedItem[2];
+
+		Numeral[] foo_numerals = new Numeral[1];
+		foo_numerals[0] = Numeral.valueOf((byte) 1);
+
+		Numeral[] bar_numerals = new Numeral[1];
+		bar_numerals[0] = Numeral.valueOf((byte) 2);
+
+		barcodedItems[0] = new BarcodedItem(new Barcode(foo_numerals), 50.0);
+		barcodedItems[1] = new BarcodedItem(new Barcode(bar_numerals), 2.0);
+
+		BarcodedProduct[] barcodedProducts = new BarcodedProduct[2];
+		barcodedProducts[0] = new BarcodedProduct(new Barcode(foo_numerals), "foo", BigDecimal.ONE);
+		barcodedProducts[1] = new BarcodedProduct(new Barcode(bar_numerals), "bar", BigDecimal.TEN);
+
+		Store s = new Store(2, 2);
+		s.barcodeConfigure(barcodedItems, barcodedProducts);
+
+		assertEquals(s.getBarcodeItemCount(), 2);
+		Map<Barcode, Map<String, String>> test_result = s.getBarcodeList();
+
+		if (test_result == null) {
+			fail("barcode list is null");
+		}
+
+		double returned_price = Double.parseDouble((test_result.get(new Barcode(foo_numerals)).get("price")));
+		double original_price = barcodedProducts[0].getPrice().doubleValue();
+		assertEquals(returned_price, original_price, 0.01);
+		assertEquals(Double.parseDouble(test_result.get(new Barcode(foo_numerals)).get("weight")),
+				barcodedItems[0].getWeight(), 0.01);
+
+		returned_price = Double.parseDouble((test_result.get(new Barcode(bar_numerals)).get("price")));
+		original_price = barcodedProducts[1].getPrice().doubleValue();
+		assertEquals(returned_price, original_price, 0.01);
+		assertEquals(Double.parseDouble(test_result.get(new Barcode(bar_numerals)).get("weight")),
+				barcodedItems[1].getWeight(), 0.01);
+	}
+}

commit 5cd7b40e1a966b7675572a827fb3fbff603f42da
Author: NuclearTea <muhammad.ali4@ucalgary.ca>
Date:   Thu Mar 24 14:55:10 2022 -0600

    Ali's group version

diff --git a/SCS - Software/.classpath b/SCS - Software/.classpath
new file mode 100644
index 0000000..bc49437
--- /dev/null
+++ b/SCS - Software/.classpath	
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-16">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="/SCS - Hardware - v1.0"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/SCS - Software/.project b/SCS - Software/.project
new file mode 100644
index 0000000..711bba8
--- /dev/null
+++ b/SCS - Software/.project	
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Software</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/SCS - Software/.settings/org.eclipse.jdt.core.prefs b/SCS - Software/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..8aabe8d
--- /dev/null
+++ b/SCS - Software/.settings/org.eclipse.jdt.core.prefs	
@@ -0,0 +1,14 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=16
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=16
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
+org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.source=16
diff --git a/SCS - Software/bin/.gitignore b/SCS - Software/bin/.gitignore
new file mode 100644
index 0000000..02c1ff6
--- /dev/null
+++ b/SCS - Software/bin/.gitignore	
@@ -0,0 +1 @@
+/Control/
diff --git a/SCS - Software/src/Control/SelfCheckoutStationLogic.java b/SCS - Software/src/Control/SelfCheckoutStationLogic.java
new file mode 100644
index 0000000..bcdb7e1
--- /dev/null
+++ b/SCS - Software/src/Control/SelfCheckoutStationLogic.java	
@@ -0,0 +1,292 @@
+package Control;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+import org.lsmr.selfcheckout.devices.observers.TouchScreenObserver;
+
+/**
+ * Represents the logic of a Self-Checkout Station.
+ * 
+ * @author Fu-Yin Lin
+ * @author Ryan McHale
+ * @author Karim Kassouri
+ * @author Munhib Saad
+ * @author Parker Wieck
+ * @author Muhammad Ali
+ * @author Ayomide Alabi
+ *
+ */
+public class SelfCheckoutStationLogic implements BarcodeScannerObserver, ElectronicScaleObserver, TouchScreenObserver,
+		CoinValidatorObserver, BanknoteValidatorObserver {
+	private SelfCheckoutStation selfCheckoutStation;
+	private Map<Barcode, Map<String, String>> barcodeList;
+	private Map<Barcode, Integer> scannedItemList = new HashMap<>();
+	private double totalCost;
+	private double totalPayment;
+	private double currentExpectedWeight;
+	private boolean waitForAttendant = false;
+	private boolean checkingOut = false;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param scs   The self-checkout station to install the logic. Cannot be null.
+	 * @param store The store to provide store product information. Cannot be null.
+	 */
+	public SelfCheckoutStationLogic(SelfCheckoutStation scs, Store store) {
+		if (scs == null || store == null) {
+			throw new SimulationException(new NullPointerException());
+		}
+		selfCheckoutStation = scs;
+		scs.scanner.attach(this);
+		scs.scale.attach(this);
+		scs.coinValidator.attach(this);
+		scs.banknoteValidator.attach(this);
+		barcodeList = store.getBarcodeList();
+		totalCost = 0.0;
+		totalPayment = 0.0;
+		currentExpectedWeight = 0.0;
+	}
+
+
+	
+	
+	
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// not used
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// not used
+	}
+
+	@Override
+	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
+		if (barcode == null) {
+			throw new SimulationException("undefined barcode");
+		}
+
+		if (scannedItemList.containsKey(barcode)) {
+			scannedItemList.replace(barcode, scannedItemList.get(barcode) + 1);
+		} else {
+			scannedItemList.put(barcode, 1);
+		}
+
+		totalCost += Double.parseDouble(barcodeList.get(barcode).get("price"));
+		currentExpectedWeight = Double.parseDouble(barcodeList.get(barcode).get("weight"));
+	}
+
+	@Override
+	public void overload(ElectronicScale scale) {
+		waitForAttendant = true;
+	}
+
+	@Override
+	public void outOfOverload(ElectronicScale scale) {
+		waitForAttendant = false;
+	}
+
+	@Override
+	public void weightChanged(ElectronicScale scale, double weightInGrams) {
+		if (weightInGrams > 0) {
+			double difference = Math.abs(currentExpectedWeight - weightInGrams);
+			if (difference <= selfCheckoutStation.scale.getSensitivity()) {
+				// Good to proceed further actions
+				waitForAttendant = false;
+			} else {
+				// Call attendant for further investigation
+				waitForAttendant = true;
+			}
+		} else {
+			// Call attendant to figure out what gets removed
+			waitForAttendant = true;
+		}
+	}
+
+	/**
+	 * Method deals with button pressed on the touch screen (simulation only)
+	 */
+	/*
+	 * 
+	 
+	 Would be implemented with the appropriate hardware.
+	 We are missing hardware to accept crypto, credit, and any interface with the touchscreen.
+	 
+	public void touchScreenButtonPressed(TouchScreenObserver touchscreen, String buttonPressed) {
+		// button = 'payment'
+		// buttons = 'cash', 'card', 'crypto'
+		// if 'cash', coin slot and banknote slot should be enabled
+		// if 'card', card reader should be enabled
+		// if 'crypto', not sure which hardware to use
+		// if button = 'pay' (in cash case) is enabled (default disabled), that means
+		// payment >= cost
+		// if payment == cost, call printReceipt()
+		// else payment > cost, call returnChange() and printReceipt()
+				
+		if (buttonPressed == "payment") {
+			checkingOut = true;
+		}
+		
+		if (buttonPressed == "cash") {
+			// coin and banknote slots enabled
+		}
+		
+		if (buttonPressed == "card") {
+			// card reader enabled
+		}
+		
+		if (buttonPressed == "crypto") {
+			// cryto payment machine enabled
+		}
+		
+		if (buttonPressed == "cancel") {
+			checkingOut = false;
+		}
+		
+		if (buttonPressed == "pay") {
+			if (totalPayment > totalCost) {
+				//returnChange(); not yet implemented
+			} 
+			printReceipt();
+			checkingOut = false;
+		}
+	}
+	*/
+
+
+	@Override
+	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
+		totalPayment += value.doubleValue();
+		if (totalPayment >= totalCost) {
+			// 'pay' button enabled
+		}
+	}
+
+	@Override
+	public void invalidCoinDetected(CoinValidator validator) {
+		// System block and attendant notified
+		System.out.println("INVALID COIN DETECTED");
+		waitForAttendant = true;
+	}
+
+	@Override
+	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
+		totalPayment += value;
+		if (totalPayment >= totalCost) {
+			// 'pay' button enabled
+		}
+	}
+
+	@Override
+	public void invalidBanknoteDetected(BanknoteValidator validator) {
+		// System block and attendant notified
+		System.out.println("INVALID BANKNOTE DETECTED");
+		waitForAttendant = true;
+	}
+
+	/**
+	 * Method to calculate and return change to customer
+	 
+	public void returnChange() {
+		// to be implemented in future iteration
+	}
+	*/
+
+	/**
+	 * Method to generate and print receipt
+	 */
+	public void printReceipt() {
+		StringBuilder str = new StringBuilder();
+		for (Barcode barcode : scannedItemList.keySet()) {
+			int quantity = scannedItemList.get(barcode);
+			double price = Double.parseDouble(barcodeList.get(barcode).get("price"));
+			str.append(barcode);
+			str.append(" ");
+			str.append(barcodeList.get(barcode).get("name"));
+			str.append(" ");
+			str.append(quantity);
+			str.append(" ");
+			str.append(price);
+			str.append(" ");
+			str.append(quantity * price);
+		}
+
+		for (int i = 0; i < str.length(); i++) {
+			char c = str.charAt(i);
+			selfCheckoutStation.printer.print(c);
+		}
+	}
+
+	/**
+	 * Accesses the list of scanned items.
+	 * 
+	 * @return A Map with current scanned barcode and corresponding quantity.
+	 
+	public Map<Barcode, Integer> getScannedItemList() {
+		return scannedItemList;
+	}
+	 */
+	
+	/**
+	 * Accesses the current total cost.
+	 * 
+	 * @return The current total cost of all scanned items.
+	 */
+	public double getTotalCost() {
+		return totalCost;
+	}
+	/**
+	 * Accesses the current total payment.
+	 * 
+	 * @return The current total ammount paid.
+	 */
+	public double getTotalPayment() {
+		return totalPayment;
+	}
+	/**
+	 * Accesses whether or not we should wait for attendant.
+	 * 
+	 * @return Whether or not we should wait for attendant.
+	 */
+	public boolean getWaitForAttendant() {
+		return waitForAttendant;
+	}
+	
+	/**
+	 * Accesses the current expected weight.
+	 * 
+	 * @return The current expected weight of recently scanned items.
+	 */
+	public double getTotalExpectedWeight() {
+		return currentExpectedWeight;
+	}
+
+	/**
+	 * Accesses the current list information of barcoded items.
+	 * 
+	 * @return A Map with all barcoded items in store and their corresponding info.
+	 */
+	public Map<Barcode, Map<String, String>> getBarcodeList() {
+		return barcodeList;
+	}
+	
+	
+}
diff --git a/SCS - Software/src/Control/Store.java b/SCS - Software/src/Control/Store.java
new file mode 100644
index 0000000..26c1a37
--- /dev/null
+++ b/SCS - Software/src/Control/Store.java	
@@ -0,0 +1,296 @@
+package Control;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.PLUCodedItem;
+import org.lsmr.selfcheckout.PriceLookupCode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
+import org.lsmr.selfcheckout.products.PLUCodedProduct;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Simulate a store database that allows user to configure, add, update, remove
+ * product information (weight, price, name).
+ * 
+ * @author Fu-Yin Lin
+ * @author Ryan McHale
+ * @author Karim Kassouri
+ * @author Munhib Saad
+ * @author Parker Wieck
+ * @author Muhammad Ali
+ * @author Ayomide Alabi
+ *
+ */
+public class Store {
+	private int barcodeItemCount;
+	private int pluItemCount;
+	private Map<Barcode, Map<String, String>> barcodeList = new HashMap<>();
+	private Map<PriceLookupCode, Map<String, String>> PLUList = new HashMap<>();
+
+	/**
+	 * Creates a product database for the self-checkout station.
+	 * 
+	 * @param barcodeItemCount The number of the barcoded items to be configured.
+	 *                         Can be changed with item addition or removal. Must be
+	 *                         positive. Zero count allowed.
+	 * @param pluItemCount     The number of the PLU coded items to be configured.
+	 *                         Can be changed with item addition or removal. Must be
+	 *                         positive. Zero count allowed.
+	 */
+	public Store(int barcodeItemCount, int pluItemCount) {
+		if (barcodeItemCount < 0 || pluItemCount < 0)
+			throw new SimulationException("Counts must be non-negative");
+		this.barcodeItemCount = barcodeItemCount;
+		this.pluItemCount = pluItemCount;
+	}
+
+	/**
+	 * Initial configuration of the store database to record barcoded products.
+	 * 
+	 * @param barcodedItems    A list of barcoded items to be recorded. No item
+	 *                         barcode can be null or weight is not positive.
+	 * @param barcodedProducts A list of barcoded products to be recorded. No
+	 *                         product barcode can be null or price is not positive.
+	 */
+	public void barcodeConfigure(BarcodedItem[] barcodedItems, BarcodedProduct[] barcodedProducts) {
+		if (barcodedItems.length != barcodeItemCount || barcodedProducts.length != barcodeItemCount) {
+			throw new SimulationException(
+					"The number of barcoded items and products must be identical to the barcode item count in the store");
+		}
+
+		for (BarcodedItem item : barcodedItems) {
+			Map<String, String> itemDetails = new HashMap<>();
+			itemDetails.put("weight", String.valueOf(item.getWeight()));
+			if (barcodeList.containsKey(item.getBarcode())) {
+				// Should not happen in initial configuration (barcode should be unique for each
+				// input item)
+				throw new SimulationException("duplicate barcoded item");
+			} else {
+				barcodeList.put(item.getBarcode(), itemDetails);
+			}
+		}
+
+		for (BarcodedProduct product : barcodedProducts) {
+			if (barcodeList.containsKey(product.getBarcode())) {
+				Map<String, String> productDetails = barcodeList.get(product.getBarcode());
+				productDetails.put("price", String.valueOf(product.getPrice()));
+				productDetails.put("name", product.getDescription());
+				barcodeList.replace(product.getBarcode(), productDetails);
+			} else {
+				throw new SimulationException("this barcode product does not match any of the barcode items on list");
+			}
+		}
+	}
+
+	/**
+	 * Initial configuration of the store database to record PLU coded products.
+	 * 
+	 * @param PLUItems A list of PLU coded items to be recorded. No item PLU code
+	 *                 can be null or weight is not positive.
+	 * @param PLUItems A list of PLU coded products to be recorded. No product PLU
+	 *                 code can be null or price is not positive.
+	 */
+	public void pluConfigure(PLUCodedItem[] PLUItems, PLUCodedProduct[] PLUProducts) {
+		if (PLUItems.length != pluItemCount || PLUProducts.length != pluItemCount) {
+			throw new SimulationException(
+					"The number of PLU coded items and products must be identical to the PLU coded item count in the store");
+		}
+
+		for (PLUCodedItem item : PLUItems) {
+			Map<String, String> itemDetails = new HashMap<>();
+			itemDetails.put("weight", String.valueOf(item.getWeight()));
+			if (PLUList.containsKey(item.getPLUCode())) {
+				// Should not happen in initial configuration (PLU code should be unique for
+				// each input item)
+				throw new SimulationException("duplicate PLU coded item");
+			} else {
+				PLUList.put(item.getPLUCode(), itemDetails);
+			}
+		}
+
+		for (PLUCodedProduct product : PLUProducts) {
+			if (PLUList.containsKey(product.getPLUCode())) {
+				Map<String, String> productDetails = PLUList.get(product.getPLUCode());
+				productDetails.put("price", String.valueOf(product.getPrice()));
+				productDetails.put("name", product.getDescription());
+				PLUList.replace(product.getPLUCode(), productDetails);
+			} else {
+				throw new SimulationException(
+						"this PLU code product does not match any of the PLU coded items on list");
+			}
+		}
+	}
+
+	/**
+	 * Add product to the store database. Input item and product must be of the same
+	 * type (barcode / PLU code).
+	 * 
+	 * @param item    Item to be added to the database.
+	 * @param product Product to be added to the database.
+	 */
+	public void addProduct(Item item, Product product) {
+		if (item == null || product == null) {
+			throw new SimulationException(new NullPointerException());
+		}
+		if (item instanceof BarcodedItem && product instanceof BarcodedProduct) {
+			Barcode barcode = ((BarcodedItem) item).getBarcode();
+			Map<String, String> details = new HashMap<>();
+			details.put("weight", String.valueOf(item.getWeight()));
+			details.put("price", String.valueOf(product.getPrice()));
+			details.put("name", ((BarcodedProduct) product).getDescription());
+			if (barcodeList.containsKey(barcode)) {
+				barcodeList.replace(barcode, details);
+			} else {
+				barcodeList.put(barcode, details);
+				barcodeItemCount++;
+			}
+		} else if (item instanceof PLUCodedItem && product instanceof PLUCodedProduct) {
+			PriceLookupCode PLUcode = ((PLUCodedItem) item).getPLUCode();
+			Map<String, String> details = new HashMap<>();
+			details.put("weight", String.valueOf(item.getWeight()));
+			details.put("price", String.valueOf(product.getPrice()));
+			details.put("name", ((PLUCodedProduct) product).getDescription());
+			if (PLUList.containsKey(PLUcode)) {
+				PLUList.replace(PLUcode, details);
+			} else {
+				PLUList.put(PLUcode, details);
+				pluItemCount++;
+			}
+		} else {
+			throw new SimulationException("invalid item/product input");
+		}
+	}
+
+	/**
+	 * Update product information in the database. Input item and product must be of
+	 * the same type (barcode / PLU code).
+	 * 
+	 * @param item    Item to be updated in the database.
+	 * @param product Product to be updated in the database.
+	 */
+	public void updateProduct(Item item, Product product) {
+		if (item == null && product == null) {
+			throw new SimulationException("invalid item/product input");
+		}
+
+		if (item != null && product == null) {
+			if (item instanceof BarcodedItem) {
+				Barcode barcode = ((BarcodedItem) item).getBarcode();
+				Map<String, String> itemDetails = barcodeList.get(barcode);
+				itemDetails.replace("weight", String.valueOf(item.getWeight()));
+			} else if (item instanceof PLUCodedItem) {
+				PriceLookupCode PLUcode = ((PLUCodedItem) item).getPLUCode();
+				Map<String, String> itemDetails = PLUList.get(PLUcode);
+				itemDetails.replace("weight", String.valueOf(item.getWeight()));
+			} else {
+				throw new SimulationException("unknown item");
+			}
+		} else if (item == null && product != null) {
+			if (product instanceof BarcodedProduct) {
+				Barcode barcode = ((BarcodedProduct) product).getBarcode();
+				Map<String, String> productDetails = barcodeList.get(barcode);
+				productDetails.replace("price", String.valueOf(product.getPrice()));
+				productDetails.replace("name", ((BarcodedProduct) product).getDescription());
+			} else if (product instanceof PLUCodedProduct) {
+				PriceLookupCode PLUcode = ((PLUCodedProduct) product).getPLUCode();
+				Map<String, String> productDetails = PLUList.get(PLUcode);
+				productDetails.replace("price", String.valueOf(product.getPrice()));
+				productDetails.replace("name", ((PLUCodedProduct) product).getDescription());
+			} else {
+				throw new SimulationException("unknown product");
+			}
+		} else if (item != null && product != null) {
+			if (item instanceof BarcodedItem) {
+				Barcode barcode = ((BarcodedItem) item).getBarcode();
+				Map<String, String> details = barcodeList.get(barcode);
+				details.replace("weight", String.valueOf(item.getWeight()));
+				details.replace("price", String.valueOf(product.getPrice()));
+				details.replace("name", ((BarcodedProduct) product).getDescription());
+			} else if (item instanceof PLUCodedItem) {
+				PriceLookupCode PLUcode = ((PLUCodedItem) item).getPLUCode();
+				Map<String, String> details = PLUList.get(PLUcode);
+				details.replace("weight", String.valueOf(item.getWeight()));
+				details.replace("price", String.valueOf(product.getPrice()));
+				details.replace("name", ((PLUCodedProduct) product).getDescription());
+			} else {
+				throw new SimulationException("unknown item");
+			}
+		}
+	}
+
+	/**
+	 * Remove product from the database. Input item and product must be of the same
+	 * type (barcode / PLU code).
+	 * 
+	 * @param item    Item to be removed from the database.
+	 * @param product Product to be removed from the database.
+	 */
+	public void removeProduct(Item item, Product product) {
+		if (item == null && product == null) {
+			throw new SimulationException("invalid item/product input");
+		}
+
+		if (item instanceof BarcodedItem || product instanceof BarcodedProduct) {
+			Barcode barcode;
+			if (item != null) {
+				barcode = ((BarcodedItem) item).getBarcode();
+			} else {
+				barcode = ((BarcodedProduct) product).getBarcode();
+			}
+			barcodeList.remove(barcode);
+			barcodeItemCount--;
+		} else if (item instanceof PLUCodedItem || product instanceof PLUCodedProduct) {
+			PriceLookupCode PLUcode;
+			if (item != null) {
+				PLUcode = ((PLUCodedItem) item).getPLUCode();
+			} else {
+				PLUcode = ((PLUCodedProduct) product).getPLUCode();
+			}
+			PLUList.remove(PLUcode);
+			pluItemCount--;
+		} else {
+			throw new SimulationException("unknown item");
+		}
+	}
+
+	/**
+	 * Accesses the number of barcoded items.
+	 * 
+	 * @return The number of barcoded items in the database.
+	 */
+	public int getBarcodeItemCount() {
+		return barcodeItemCount;
+	}
+
+	/**
+	 * Accesses the number of PLU coded items.
+	 * 
+	 * @return The number of PLU coded items in the database.
+	 */
+	public int getPluItemCount() {
+		return pluItemCount;
+	}
+
+	/**
+	 * Accesses the current barcode item list.
+	 * 
+	 * @return The current barcode item list in the store.
+	 */
+	public Map<Barcode, Map<String, String>> getBarcodeList() {
+		return barcodeList;
+	}
+
+	/**
+	 * Accesses the current PLU code item list.
+	 * 
+	 * @return The current PLU code item list in the store.
+	 */
+	public Map<PriceLookupCode, Map<String, String>> getPLUList() {
+		return PLUList;
+	}
+}

commit 8cbad9239ffbd1dc2c2ae5263e09dbd27b8d19cf
Author: NuclearTea <muhammad.ali4@ucalgary.ca>
Date:   Mon Mar 21 12:15:47 2022 -0600

    SCS - Hardware - v2.0/

diff --git a/SCS - Hardware - v2.0/.classpath b/SCS - Hardware - v2.0/.classpath
new file mode 100644
index 0000000..04cc82d
--- /dev/null
+++ b/SCS - Hardware - v2.0/.classpath	
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/SCS - Hardware - v2.0/.project b/SCS - Hardware - v2.0/.project
new file mode 100644
index 0000000..b29667f
--- /dev/null
+++ b/SCS - Hardware - v2.0/.project	
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Hardware - v2.0</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..3a21537
--- /dev/null
+++ b/SCS - Hardware - v2.0/.settings/org.eclipse.jdt.core.prefs	
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java
new file mode 100644
index 0000000..f91d858
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Banknote.java	
@@ -0,0 +1,66 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual banknotes. The value of a
+ * banknote is assumed to always be a positive integer multiple of the base
+ * currency.
+ */
+public class Banknote {
+	private int value;
+	private Currency currency;
+
+	/**
+	 * Constructs a banknote.
+	 * @param currency
+	 *            The currency represented by this banknote.
+	 * @param value
+	 *            The value of the banknote, in multiples of the unit of currency.
+	 * 
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If currency is null.
+	 */
+	public Banknote(Currency currency, int value) {
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the banknote. Should always be &gt;0.
+	 */
+	public int getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this banknote. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
+	 *             dollars, so a Canadian $10 bill would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return Integer.toString(value) + " " + currency;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java
new file mode 100644
index 0000000..b8e1f7c
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Barcode.java	
@@ -0,0 +1,109 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a barcode value (not the graphic barcode itself). Real-world
+ * barcodes are a sequence of digits, so that is what is modelled here.
+ */
+public class Barcode {
+	private Numeral[] digits;
+
+	/**
+	 * Constructs a barcode from an array of numerals.
+	 * 
+	 * @param code
+	 *            An array of numerals.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code is null
+	 * @throws SimulationException
+	 *             If the code's length is &lt;1 or &gt;48.
+	 */
+	public Barcode(Numeral[] code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		digits = new Numeral[code.length];
+
+		if(code.length < 1)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain less than one digit."));
+
+		if(code.length > 48)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
+
+		for(int i = 0; i < code.length; i++) {
+			if(code[i] == null)
+				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
+
+			digits[i] = code[i];
+		}
+	}
+
+	/**
+	 * Gets the count of digits in this code.
+	 * 
+	 * @return The count of digits.
+	 */
+	public int digitCount() {
+		return digits.length;
+	}
+
+	/**
+	 * Gets the digit at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the digit, &ge;0 and &lt;count.
+	 * @return The digit at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getDigitAt(int index) {
+		try {
+			return digits[index];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[digits.length];
+
+		for(int i = 0; i < digits.length; i++)
+			characters[i] = Character.forDigit(digits[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof Barcode) {
+			Barcode other = (Barcode)object;
+
+			if(other.digits.length != digits.length)
+				return false;
+
+			for(int i = 0; i < digits.length; i++)
+				if(!digits[i].equals(other.digits[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(digits);
+	}
+}
\ No newline at end of file
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java
new file mode 100644
index 0000000..fab9792
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BarcodedItem.java	
@@ -0,0 +1,41 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class BarcodedItem extends Item {
+	private Barcode barcode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The real weight of the item.
+	 * @throws SimulationException
+	 *             If the barcode is null.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	public BarcodedItem(Barcode barcode, double weightInGrams) {
+		super(weightInGrams);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		this.barcode = barcode;
+	}
+
+	/**
+	 * Gets the barcode of this item.
+	 * 
+	 * @return The barcode.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java
new file mode 100644
index 0000000..3b6416e
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/BlockedCardException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from a blocked card.
+ */
+public class BlockedCardException extends IOException {
+	private static final long serialVersionUID = 8824192400137175094L;
+
+	/**
+	 * Create an exception.
+	 */
+	public BlockedCardException() {}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java
new file mode 100644
index 0000000..58da94a
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Card.java	
@@ -0,0 +1,289 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
+ */
+public final class Card {
+	private final String type;
+	private final String number;
+	private final String cardholder;
+	private final String cvv;
+	private final String pin;
+	public final boolean isTapEnabled;
+	public final boolean hasChip;
+	private int failedTrials = 0;
+	private boolean isBlocked;
+
+	/**
+	 * Create a card instance.
+	 * 
+	 * @param type
+	 *            The type of the card.
+	 * @param number
+	 *            The number of the card. This has to be a string of digits.
+	 * @param cardholder
+	 *            The name of the cardholder.
+	 * @param cvv
+	 *            The card verification value (CVV), a 3- or 4-digit value often on
+	 *            the back of the card. This can be null.
+	 * @param pin
+	 *            The personal identification number (PIN) for access to the card.
+	 *            This can be null if the card has no chip.
+	 * @param isTapEnabled
+	 *            Whether this card is capable of being tapped.
+	 * @param hasChip
+	 *            Whether this card has a chip.
+	 * @throws SimulationException
+	 *             If type, number, or cardholder is null.
+	 * @throws SimulationException
+	 *             If hasChip is true but pin is null.
+	 */
+	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
+		boolean hasChip) {
+		if(type == null)
+			throw new SimulationException(new NullPointerException("type is null"));
+
+		if(number == null)
+			throw new SimulationException(new NullPointerException("number is null"));
+
+		if(cardholder == null)
+			throw new SimulationException(new NullPointerException("cardholder is null"));
+
+		if(hasChip && pin == null)
+			throw new SimulationException(new NullPointerException("has chip but pin is null"));
+
+		this.type = type;
+		this.number = number;
+		this.cardholder = cardholder;
+		this.cvv = cvv;
+		this.pin = pin;
+		this.isTapEnabled = isTapEnabled;
+		this.hasChip = hasChip;
+	}
+
+	private static final Random random = new Random(0);
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
+	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
+	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
+	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
+
+	/**
+	 * Simulates the action of swiping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardSwipeData swipe() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
+			throw new MagneticStripeFailureException();
+
+		return new CardSwipeData();
+	}
+
+	/**
+	 * Simulates the action of tapping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardTapData tap() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(isTapEnabled) {
+			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
+				throw new TapFailureException();
+
+			return new CardTapData();
+		}
+
+		return null;
+	}
+
+	/**
+	 * Simulates the action of inserting the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardInsertData insert(String pin) throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(hasChip) {
+			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
+				throw new ChipFailureException();
+
+			return new CardInsertData(pin);
+		}
+
+		return null;
+	}
+
+	private String randomize(String original, double probability) {
+		if(random.nextDouble() <= probability) {
+			int length = original.length();
+			int index = random.nextInt(length);
+			String first;
+
+			if(index == 0)
+				first = "";
+			else
+				first = original.substring(0, index);
+
+			char second = original.charAt(index);
+			second++;
+
+			String third;
+
+			if(index == length - 1)
+				third = "";
+			else
+				third = original.substring(index + 1, length);
+
+			return first + second + third;
+		}
+
+		return original;
+	}
+
+	/**
+	 * The abstract base type of card data.
+	 */
+	public interface CardData {
+		/**
+		 * Gets the type of the card.
+		 * 
+		 * @return The type of the card.
+		 */
+		public String getType();
+
+		/**
+		 * Gets the number of the card.
+		 * 
+		 * @return The number of the card.
+		 */
+		public String getNumber();
+
+		/**
+		 * Gets the cardholder's name.
+		 * 
+		 * @return The cardholder's name.
+		 */
+		public String getCardholder();
+
+		/**
+		 * Gets the card verification value (CVV) of the card.
+		 * 
+		 * @return The CVV of the card.
+		 * @throws UnsupportedOperationException
+		 *             If this operation is unsupported by this object.
+		 */
+		public String getCVV();
+	}
+
+	/**
+	 * The data from swiping a card.
+	 */
+	public class CardSwipeData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	/**
+	 * The data from tapping a card.
+	 */
+	public final class CardTapData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+	}
+
+	/**
+	 * The data from inserting a card.
+	 */
+	public final class CardInsertData implements CardData {
+		CardInsertData(String pin) throws InvalidPINException {
+			if(!testPIN(pin))
+				throw new InvalidPINException();
+		}
+
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		private boolean testPIN(String pinToTest) {
+			if(pinToTest == pin) {
+				failedTrials = 0;
+				return true;
+			}
+
+			if(++failedTrials >= 3)
+				isBlocked = true;
+
+			return false;
+		}
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java
new file mode 100644
index 0000000..00c7c18
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/ChipFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the chip.
+ */
+public class ChipFailureException extends IOException {
+	private static final long serialVersionUID = 3518203688837080092L;
+
+	/**
+	 * Create an exception.
+	 */
+	public ChipFailureException() {}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java
new file mode 100644
index 0000000..ede38a9
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Coin.java	
@@ -0,0 +1,98 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual coins.
+ */
+public class Coin {
+	private BigDecimal value;
+	private Currency currency;
+
+	/**
+	 * Rather than specifying a currency for every coin, a default currency can be
+	 * specified which will be used when the currency is not specified.
+	 */
+	public static Currency DEFAULT_CURRENCY;
+
+	/**
+	 * Constructs a coin, using the default currency.
+	 * 
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 */
+	public Coin(BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(DEFAULT_CURRENCY == null)
+			throw new SimulationException(new NullPointerException("Default currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = DEFAULT_CURRENCY;
+	}
+		
+	/**
+	 * Constructs a coin.
+	 * 
+	 * @param currency
+	 *            The currency represented by this coin.
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 */
+	public Coin(Currency currency, BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the coin. Should always be greater than 0.
+	 */
+	public BigDecimal getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this coin. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
+	 *             dollars, so a Canadian dime would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return value.toString() + " " + currency;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
new file mode 100644
index 0000000..22e6f63
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/IllegalDigitException.java	
@@ -0,0 +1,19 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Signals that an illegal character has been used where a digit (0-9) was
+ * expected.
+ */
+public class IllegalDigitException extends IllegalArgumentException {
+	private static final long serialVersionUID = 3352152121776245096L;
+
+	/**
+	 * Constructs an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to display.
+	 */
+	public IllegalDigitException(String message) {
+		super(message);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java
new file mode 100644
index 0000000..7134225
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/InvalidPINException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from entry of an invalid PIN.
+ */
+public class InvalidPINException extends IOException {
+	private static final long serialVersionUID = 5461848339919309513L;
+
+	/**
+	 * Create an exception.
+	 */
+	public InvalidPINException() {}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java
new file mode 100644
index 0000000..24e2842
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Item.java	
@@ -0,0 +1,35 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Abstract base class of items for sale, each with a particular weight.
+ */
+public abstract class Item {
+	private double weightInGrams;
+
+	/**
+	 * Constructs an item with the indicated weight.
+	 * 
+	 * @param weightInGrams
+	 *            The weight of the item.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	protected Item(double weightInGrams) {
+		if(weightInGrams <= 0.0)
+			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
+
+		this.weightInGrams = weightInGrams;
+	}
+
+	/**
+	 * The weight of the item, in grams.
+	 * 
+	 * @return The weight in grams.
+	 */
+	public double getWeight() {
+		return weightInGrams;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
new file mode 100644
index 0000000..fc5396e
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the magnetic stripe.
+ */
+public class MagneticStripeFailureException extends IOException {
+	private static final long serialVersionUID = -4703845851722394414L;
+
+	/**
+	 * Create an exception.
+	 */
+	public MagneticStripeFailureException() {}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java
new file mode 100644
index 0000000..c53e6f7
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/Numeral.java	
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Represents numerals (i.e., number characters) referred to as "Arabic numbers"
+ * in English.
+ */
+public enum Numeral {
+	one((byte)1), two((byte)2), three((byte)3), four((byte)4), five((byte)5), six((byte)6), seven((byte)7),
+	eight((byte)8), nine((byte)9), zero((byte)0);
+
+	private byte value;
+
+	private Numeral(byte value) {
+		this.value = value;
+	}
+
+	/**
+	 * Obtains the numeric value of the numeral.
+	 * 
+	 * @return The numeric value of the numeral.
+	 */
+	public byte getValue() {
+		return value;
+	}
+
+	/**
+	 * Converts a number between 0 and 9 into the corresponding numeral.
+	 * 
+	 * @param number
+	 *            The number to convert. It must be between 0 and 9, inclusive.
+	 * @return {@link IllegalDigitException} If the number is less than 0 or greater than 9.
+	 */
+	public static Numeral valueOf(byte number) {
+		switch(number) {
+		case 0:
+			return zero;
+		case 1:
+			return one;
+		case 2:
+			return two;
+		case 3:
+			return three;
+		case 4:
+			return four;
+		case 5:
+			return five;
+		case 6:
+			return six;
+		case 7:
+			return seven;
+		case 8:
+			return eight;
+		case 9:
+			return nine;
+		default:
+			throw new IllegalDigitException("The number " + number + " does not correspond to a numeral.");
+		}
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
new file mode 100644
index 0000000..e0985d0
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PLUCodedItem.java	
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class PLUCodedItem extends Item {
+	private PriceLookupCode pluCode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The actual weight of the item.
+	 */
+	public PLUCodedItem(PriceLookupCode pluCode, double weightInGrams) {
+		super(weightInGrams);
+		
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("pluCode is null"));
+		
+		this.pluCode = pluCode;
+	}
+
+	/**
+	 * Gets the PLU code of this item.
+	 * 
+	 * @return The PLU code.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
new file mode 100644
index 0000000..c860edc
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/PriceLookupCode.java	
@@ -0,0 +1,114 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a PLU value, a sequence of digits that, in principle, could lie
+ * anywhere in the range 0000-99999. Specific subranges are reserved for specific
+ * purposes in the real world, but we will not worry about that here.
+ */
+public class PriceLookupCode {
+	private Numeral[] numerals;
+
+	/**
+	 * Constructs a PLU code from a string of numerals. There must be at least 4
+	 * digits and at most 5.
+	 * 
+	 * @param code
+	 *            A string of digits.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code contains less than 4 digits or more than 5 digits.
+	 * @throws NullPointerException
+	 *             If code is null.
+	 */
+	public PriceLookupCode(String code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		char[] charArray = code.toCharArray();
+		numerals = new Numeral[charArray.length];
+
+		if(code.length() > 5)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain more than five digits."));
+
+		if(code.length() < 4)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain less than four digits."));
+
+		for(int i = 0; i < charArray.length; i++) {
+			try {
+				numerals[i] = Numeral.valueOf((byte)Character.digit(charArray[i], 10));
+			}
+			catch(IllegalDigitException e) {
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	/**
+	 * Gets the count of numerals in this code.
+	 * 
+	 * @return The count of numerals.
+	 */
+	public int numeralCount() {
+		return numerals.length;
+	}
+
+	/**
+	 * Gets the numeral at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the numeral, &ge;0 and &lt;count.
+	 * @return The numeral at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getNumeralAt(int i) {
+		try {
+			return numerals[i];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[numerals.length];
+
+		for(int i = 0; i < numerals.length; i++)
+			characters[i] = Character.forDigit(numerals[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof PriceLookupCode) {
+			PriceLookupCode other = (PriceLookupCode)object;
+
+			if(other.numerals.length != numerals.length)
+				return false;
+
+			for(int i = 0; i < numerals.length; i++)
+				if(!numerals[i].equals(other.numerals[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(numerals);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java
new file mode 100644
index 0000000..66ea14e
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/TapFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of taps.
+ */
+public class TapFailureException extends IOException {
+	private static final long serialVersionUID = -8812895797883270979L;
+
+	/**
+	 * Create an exception.
+	 */
+	public TapFailureException() {}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
new file mode 100644
index 0000000..20cb12a
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java	
@@ -0,0 +1,193 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+/**
+ * The abstract base class for all devices involved in the simulator.
+ * <p>
+ * This class utilizes the Observer design pattern. Subclasses inherit the
+ * attach method, but each must define its own notifyXXX methods.
+ * </p>
+ * <p>
+ * Each device must be coupled to an appropriate observer interface, which
+ * extends AbstractDeviceObserver; the type parameter T represents this
+ * observer.
+ * <p>
+ * <p>
+ * Any individual device can be disabled, which means it will not permit
+ * physical movements to be caused by the software. Any method that could cause
+ * a physical movement will declare that it throws DisabledException.
+ * </p>
+ * 
+ * @param <T>
+ *            The type of observers used for this device. For a device whose
+ *            class is X, its corresponding observer interface would typically
+ *            be XObserver.
+ */
+public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
+	/**
+	 * Used to represent the operation phase of this device.
+	 */
+	protected enum Phase {
+		/**
+		 * The device is being configured.
+		 */
+		CONFIGURATION,
+		/**
+		 * The device is in normal operation.
+		 */
+		NORMAL,
+		/**
+		 * The device has undergone a fatal error requiring physical repair and reset.
+		 */
+		ERROR
+	}
+
+	/**
+	 * The current operation phase of this device.
+	 */
+	protected Phase phase = Phase.CONFIGURATION;
+
+	/**
+	 * Many devices require configuration before their use. Before configuration is
+	 * complete, the device should not operate. Once configuration is complete, any
+	 * further configuration attempts should cause exceptions.
+	 */
+	public void endConfigurationPhase() {
+		phase = Phase.NORMAL;
+	}
+
+	/**
+	 * For testing purposes only. Forces this device into an erroneous state.
+	 */
+	public void forceErrorPhase() {
+		phase = Phase.ERROR;
+	}
+
+	/**
+	 * A list of the registered observers on this device.
+	 */
+	protected ArrayList<T> observers = new ArrayList<>();
+
+	/**
+	 * Locates the indicated observer and removes it such that it will no longer be
+	 * informed of events from this device. If the observer is not currently
+	 * registered with this device, calls to this method will return false, but
+	 * otherwise have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to remove.
+	 * @return true if the observer was found and removed, false otherwise.
+	 */
+	public final boolean detach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return observers.remove(observer);
+	}
+
+	/**
+	 * All observers registered with this device are removed. If there are none,
+	 * calls to this method have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 */
+	public final void detachAll() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		observers.clear();
+	}
+
+	/**
+	 * Registers the indicated observer to receive event notifications from this
+	 * device.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to be added.
+	 */
+	public final void attach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(observer == null)
+			throw new SimulationException(new IllegalArgumentException(
+				"This method may not receive null, as it has no analogue in the real world."));
+
+		observers.add(observer);
+	}
+
+	private boolean disabled = false;
+
+	/**
+	 * Disables this device from receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void disable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = true;
+		notifyDisabled();
+	}
+
+	private void notifyDisabled() {
+		for(T observer : observers)
+			observer.disabled(this);
+	}
+
+	/**
+	 * Enables this device for receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void enable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = false;
+		notifyEnabled();
+	}
+
+	private void notifyEnabled() {
+		for(T observer : observers)
+			observer.enabled(this);
+	}
+
+	/**
+	 * Returns whether this device is currently disabled from receiving input and
+	 * producing output.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return true if the device is disabled; false if the device is enabled.
+	 */
+	public final boolean isDisabled() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return disabled;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
new file mode 100644
index 0000000..d3890b1
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Acceptor.java	
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that accept things.
+ * 
+ * @param <T>
+ *            The type of the things to accept.
+ */
+public interface Acceptor<T> {
+	/**
+	 * Instructs the device to take the thing as input.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to be taken as input.
+	 * @throws OverloadException
+	 *             If the device does not have enough space for the thing.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 */
+	public void accept(T thing) throws OverloadException, DisabledException;
+
+	/**
+	 * Checks whether the device has enough space to expect one more thing. If this
+	 * method returns true, an immediate call to accept should not throw
+	 * CapacityExceededException, unless an asynchronous addition has occurred in
+	 * the meantime.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @return true If there is space; otherwise, false.
+	 */
+	public boolean hasSpace();
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
new file mode 100644
index 0000000..df4e37e
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java	
@@ -0,0 +1,213 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
+
+/**
+ * Represents a device that stores banknotes (as known as bills, paper money,
+ * etc.) of a particular denomination to dispense them as change.
+ * <p>
+ * Banknote dispensers can receive banknotes from other sources. To simplify the
+ * simulation, no check is performed on the value of each banknote.
+ * </p>
+ */
+public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
+	implements FromStorageEmitter<Banknote> {
+	private int maxCapacity;
+	private Queue<Banknote> queue = new LinkedList<Banknote>();
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that can be stored in the
+	 *            dispenser. Must be positive.
+	 * @throws SimulationException
+	 *             If capacity is not positive.
+	 */
+	public BanknoteDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of banknotes in the dispenser.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return The number of banknotes currently in the dispenser.
+	 */
+	public int size() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
+	 * banknotes in the dispenser are not removed.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each may not be null.
+	 * @throws OverloadException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the dispenser.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + banknotes.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(new NullPointerException("A banknote is null."));
+			else
+				queue.add(banknote);
+
+		notifyBanknotesLoaded(banknotes);
+	}
+
+	/**
+	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
+	 * event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
+
+		return result;
+	}
+
+	/**
+	 * Connects an output channel to this banknote dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this banknote dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return maxCapacity;
+	}
+
+	/**
+	 * Emits a single banknote from this banknote dispenser. If successful, a
+	 * "banknoteRemoved" event is announced to its observers. If a successful
+	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
+	 * event is instead announced to its observers.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             if the output channel is unable to accept another banknote.
+	 * @throws EmptyException
+	 *             if no banknotes are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             if the dispenser is currently disabled.
+	 */
+	public void emit() throws EmptyException, DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Banknote banknote = queue.remove();
+
+		if(sink.hasSpace())
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		else
+			throw new OverloadException("The sink is full.");
+
+		if(queue.isEmpty())
+			notifyBanknotesEmpty();
+		else
+			notifyBanknoteRemoved(banknote);
+	}
+
+	private void notifyBanknoteRemoved(Banknote banknote) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknoteRemoved(this, banknote);
+	}
+
+	private void notifyBanknotesEmpty() {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesEmpty(this);
+	}
+
+	private void notifyBanknotesLoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesLoaded(this, banknotes);
+	}
+
+	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesUnloaded(this, banknotes);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
new file mode 100644
index 0000000..e8f30e4
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java	
@@ -0,0 +1,191 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+
+/**
+ * Represents a simple banknote slot device that can either accept a banknote or
+ * eject the most recently inserted banknote, leaving it dangling until the
+ * customer removes it, via {@link #removeDanglingBanknote()}.
+ */
+public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
+	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
+	private BidirectionalChannel<Banknote> sink;
+	private boolean invert;
+
+	/**
+	 * Creates a banknote slot.
+	 * 
+	 * @param invert
+	 *            If the slot is to be inverted.
+	 */
+	public BanknoteSlot(boolean invert) {
+		this.invert = invert;
+	}
+
+	/**
+	 * Connects an output channel to the banknote slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where banknotes are passed into the machine.
+	 */
+	public void connect(BidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the banknote slot that the indicated banknote is being inserted. If the
+	 * sink can accept the banknote, the banknote is passed to the sink and a
+	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
+	 * "banknoteEjected" event is announced to the slot's observers, meaning that
+	 * the banknote is returned to the user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote slot is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 * @throws OverloadException
+	 *             If a banknote is dangling from the slot.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(danglingEjectedBanknote != null)
+			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
+
+		notifyBanknoteInserted();
+
+		if(!invert && sink.hasSpace()) {
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else {
+			danglingEjectedBanknote = banknote;
+			notifyBanknoteEjected();
+		}
+	}
+
+	private Banknote danglingEjectedBanknote = null;
+
+	/**
+	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
+	 * it.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be ejected.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 * @throws SimulationException
+	 *             If a banknote is already dangling from the slot.
+	 */
+	public void emit(Banknote banknote) throws DisabledException, SimulationException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(danglingEjectedBanknote != null)
+			throw new SimulationException(
+				"A banknote is already dangling from the slot. Remove that before ejecting another.");
+
+		danglingEjectedBanknote = banknote;
+
+		notifyBanknoteEjected();
+	}
+
+	/**
+	 * Simulates the user removing a banknote that is dangling from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The formerly dangling banknote.
+	 */
+	public Banknote removeDanglingBanknote() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(danglingEjectedBanknote == null)
+			throw new SimulationException("A banknote that does not exist cannot be removed.");
+
+		Banknote b = danglingEjectedBanknote;
+		danglingEjectedBanknote = null;
+		notifyBanknoteRemoved();
+
+		return b;
+	}
+
+	/**
+	 * Tests whether a banknote can be accepted by or ejected from this slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
+	 *             false.
+	 */
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return danglingEjectedBanknote == null;
+	}
+
+	private void notifyBanknoteInserted() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteInserted(this);
+	}
+
+	private void notifyBanknoteEjected() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteEjected(this);
+	}
+
+	private void notifyBanknoteRemoved() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteRemoved(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
new file mode 100644
index 0000000..d773a2b
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java	
@@ -0,0 +1,199 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+/**
+ * Represents devices that store banknotes. They only receive banknotes, not
+ * dispense them. To access the banknotes inside, a human operator needs to
+ * physically remove the banknotes, simulated with the {@link #unload()} method.
+ * A {@link #load(Banknote...)} method is provided for symmetry.
+ */
+public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
+	private Banknote[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a banknote storage unit that can hold the indicated number of
+	 * banknotes.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public BanknoteStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Banknote[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of banknotes that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of banknotes contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getBanknoteCount() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the storage unit directly.
+	 * Existing banknotes in the dispenser are not removed. Causes a
+	 * "banknotesLoaded" event to be announced. Disabling has no effect on
+	 * loading/unloading.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the unit.
+	 * @throws SimulationException
+	 *             If the banknotes argument is null.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 * @throws OverloadException
+	 *             If too many banknotes are stuffed in the unit.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(banknotes == null)
+			throw new SimulationException(
+				new NullPointerException("banknotes is null which has no analogue in the real world"));
+
+		if(banknotes.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(
+					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
+
+		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
+		nextIndex += banknotes.length;
+
+		notifyBanknotesLoaded();
+	}
+
+	/**
+	 * Unloads banknotes from the storage unit directly. Causes a
+	 * "banknotesUnloaded" event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> banknotes = Arrays.asList(storage);
+
+		storage = new Banknote[storage.length];
+		nextIndex = 0;
+		notifyBanknotesUnloaded();
+
+		return banknotes;
+	}
+
+	/**
+	 * Causes the indicated banknote to be added to the storage unit. If successful,
+	 * a "banknoteAdded" event is announced to its observers. If a successful
+	 * banknote addition causes the unit to become full, a "banknotesFull" event is
+	 * instead announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to add.
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If banknote is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(
+				new NullPointerException("banknote is null, which has no analogue in the real world."));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = banknote;
+
+			if(nextIndex == storage.length)
+				notifyBanknotesFull();
+			else
+				notifyBanknoteAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyBanknotesLoaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesLoaded(this);
+	}
+
+	private void notifyBanknotesUnloaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesUnloaded(this);
+	}
+
+	private void notifyBanknotesFull() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesFull(this);
+	}
+
+	private void notifyBanknoteAdded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknoteAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
new file mode 100644
index 0000000..56323a2
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
@@ -0,0 +1,201 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+/**
+ * Represents a device for optically and/or magnetically validating banknotes.
+ * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
+ * ejected.
+ */
+public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
+	implements Acceptor<Banknote>, Emitter<Banknote> {
+	private final Currency currency;
+	private final int[] denominations;
+	private BidirectionalChannel<Banknote> source;
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote validator that recognizes banknotes of the specified
+	 * denominations (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid banknote denominations (like $5, $10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public BanknoteValidator(Currency currency, int[] denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.length < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Arrays.sort(denominations);
+
+		HashSet<Integer> set = new HashSet<>();
+
+		for(int denomination : denominations) {
+			if(denomination <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(set.contains(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			set.add(denomination);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the banknote slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param source
+	 *            The channel from which banknotes normally arrive for validation,
+	 *            and to which invalid banknotes will be ejected.
+	 * @param sink
+	 *            The channel to which all valid banknotes are routed.
+	 */
+	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.source = source;
+		this.sink = sink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Banknote banknote) {
+		if(currency.equals(banknote.getCurrency()))
+			for(int denomination : denominations)
+				if(denomination == banknote.getValue())
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the banknote validator that the indicated banknote is being inserted.
+	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
+	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
+	 * observers.
+	 * <p>
+	 * If there is space in the machine to store a valid banknote, it is passed to
+	 * the sink channel.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the banknote is invalid,
+	 * the banknote is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 */
+	@Override
+	public void accept(Banknote banknote) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(isValid(banknote)) {
+			notifyValidBanknoteDetected(banknote);
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					source.eject(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidBanknoteDetected();
+
+			try {
+				source.eject(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException("Unable to route banknote: sink is full");
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return true;
+	}
+
+	private void notifyValidBanknoteDetected(Banknote banknote) {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
+	}
+
+	private void notifyInvalidBanknoteDetected() {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.invalidBanknoteDetected(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
new file mode 100644
index 0000000..7e926a5
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java	
@@ -0,0 +1,60 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Random;
+
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+
+/**
+ * A complex device hidden behind a simple simulation. They can scan and that is
+ * about all.
+ */
+public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
+	/**
+	 * Create a barcode scanner.
+	 */
+	public BarcodeScanner() {}
+
+	private Random random = new Random();
+	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
+
+	/**
+	 * Simulates the customer's action of scanning an item. The result of the scan
+	 * is only announced to any registered observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to scan. Of course, it will only work if the item has a
+	 *            barcode, and maybe not even then.
+	 * @throws SimulationException
+	 *             If item is null.
+	 */
+	public void scan(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			return; // silently ignore it
+
+		if(item == null)
+			throw new SimulationException(
+				new NullPointerException("item is null, which has no analogue in the real world."));
+
+		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
+			notifyBarcodeScanned((BarcodedItem)item);
+
+		// otherwise, silently ignore it
+	}
+
+	private void notifyBarcodeScanned(BarcodedItem item) {
+		for(BarcodeScannerObserver l : observers)
+			l.barcodeScanned(this, item.getBarcode());
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
new file mode 100644
index 0000000..433dc07
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java	
@@ -0,0 +1,69 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+
+/**
+ * Represents a simple device (like, say, a tube or just a physical connection)
+ * that moves things between other devices. This channel is bidirectional.
+ * 
+ * @param <T>
+ *            The type of the things to move.
+ */
+public final class BidirectionalChannel<T> {
+	private FlowThroughEmitter<T> source;
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new channel whose input is connected to the indicated source and
+	 * whose output is connected to the indicated sink.
+	 * 
+	 * @param source
+	 *            The device at the output end of the channel.
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
+		this.source = source;
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the source. This method should be called by
+	 * the sink device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void eject(T thing) throws OverloadException, DisabledException {
+		source.emit(thing);
+	}
+
+	/**
+	 * Moves the indicated banknote to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param banknote
+	 *            The banknote to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void deliver(T banknote) throws OverloadException, DisabledException {
+		sink.accept(banknote);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more banknote.
+	 * 
+	 * @return true if the sink can accept a banknote; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java
new file mode 100644
index 0000000..6f54d0d
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CardReader.java	
@@ -0,0 +1,185 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.ChipFailureException;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+
+/**
+ * Represents the card reader, capable of tap, chip insert, and swipe. Either
+ * the reader or the card may fail, or the data read in can be corrupted, with
+ * varying probabilities.
+ */
+public class CardReader extends AbstractDevice<CardReaderObserver> {
+	private boolean cardIsInserted = false;
+
+	/**
+	 * Create a card reader.
+	 */
+	public CardReader() {}
+
+	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
+	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
+
+	/**
+	 * Tap the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to tap.
+	 * @return The card's (possibly corrupted) data, or null if the card is not tap
+	 *             enabled.
+	 * @throws IOException
+	 *             If the tap failed (lack of failure does not mean that the data is
+	 *             not corrupted).
+	 */
+	public CardData tap(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(card.isTapEnabled) {
+			notifyCardTapped();
+
+			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
+				CardData data = card.tap();
+
+				notifyCardDataRead(data);
+
+				return data;
+			}
+			else
+				throw new ChipFailureException();
+		}
+
+		// else ignore
+		return null;
+	}
+
+	/**
+	 * Swipe the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to swipe.
+	 * @return The card data.
+	 * @throws IOException
+	 *             If the swipe failed.
+	 */
+	public CardData swipe(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		notifyCardSwiped();
+
+		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
+			CardData data = card.swipe();
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new MagneticStripeFailureException();
+	}
+
+	/**
+	 * Insert the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to insert.
+	 * @param pin
+	 *            The customer's PIN.
+	 * @return The card data.
+	 * @throws SimulationException
+	 *             If there is already a card in the slot.
+	 * @throws IOException
+	 *             The insertion failed.
+	 */
+	public CardData insert(Card card, String pin) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(cardIsInserted)
+			throw new IllegalStateException("There is already a card in the slot");
+
+		cardIsInserted = true;
+
+		notifyCardInserted();
+
+		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
+			CardData data = card.insert(pin);
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new ChipFailureException();
+	}
+
+	/**
+	 * Remove the card from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void remove() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		cardIsInserted = false;
+		notifyCardRemoved();
+	}
+
+	private void notifyCardTapped() {
+		for(CardReaderObserver l : observers)
+			l.cardTapped(this);
+	}
+
+	private void notifyCardInserted() {
+		for(CardReaderObserver l : observers)
+			l.cardInserted(this);
+	}
+
+	private void notifyCardSwiped() {
+		for(CardReaderObserver l : observers)
+			l.cardSwiped(this);
+	}
+
+	private void notifyCardDataRead(CardData data) {
+		for(CardReaderObserver l : observers)
+			l.cardDataRead(this, data);
+	}
+
+	private void notifyCardRemoved() {
+		for(CardReaderObserver l : observers)
+			l.cardRemoved(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
new file mode 100644
index 0000000..838766e
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java	
@@ -0,0 +1,262 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
+
+/**
+ * Represents a device that stores coins of a particular denomination to
+ * dispense them as change.
+ * <p>
+ * Coin dispensers can receive coins from other sources. To simplify the
+ * simulation, no check is performed on the value of each coin, meaning it is an
+ * external responsibility to ensure the correct routing of coins.
+ * </p>
+ */
+public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
+	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
+	private int maxCapacity;
+	private Queue<Coin> queue = new LinkedList<Coin>();
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that can be stored in the dispenser.
+	 *            Must be positive.
+	 * @throws SimulationException
+	 *             if capacity is not positive.
+	 */
+	public CoinDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of coins in the dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The number of coins currently in the dispenser.
+	 */
+	public int size() {
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the dispenser directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws OverloadException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             dispenser.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + coins.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("A coin is null"));
+			else
+				queue.add(coin);
+
+		notifyLoad(coins);
+	}
+
+	private void notifyLoad(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsLoaded(this, coins);
+	}
+
+	/**
+	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
+	 * be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyUnload(result.toArray(new Coin[result.size()]));
+
+		return result;
+	}
+
+	private void notifyUnload(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsUnloaded(this, coins);
+	}
+
+	/**
+	 * Connects an output channel to this coin dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is only permissible during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this coin dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		return maxCapacity;
+	}
+
+	/**
+	 * Causes the indicated coin to be added into the dispenser. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition causes the dispenser to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the coin dispenser is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the coin dispenser is already full.
+	 */
+	@Override
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(queue.size() >= maxCapacity)
+			throw new OverloadException();
+
+		queue.add(coin);
+		notifyCoinAdded(coin);
+
+		if(queue.size() >= maxCapacity)
+			notifyCoinsFull();
+	}
+
+	/**
+	 * Releases a single coin from this coin dispenser. If successful, a
+	 * "coinRemoved" event is announced to its observers. If a successful coin
+	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             If the output channel is unable to accept another coin.
+	 * @throws EmptyException
+	 *             If no coins are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             If the dispenser is currently disabled.
+	 */
+	public void emit() throws OverloadException, EmptyException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Coin coin = queue.remove();
+
+		notifyCoinRemoved(coin);
+		sink.deliver(coin);
+
+		if(queue.isEmpty())
+			notifyCoinsEmpty();
+	}
+
+	/**
+	 * Returns whether this coin dispenser has enough space to accept at least one
+	 * more coin. Announces no events.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size() < maxCapacity;
+	}
+
+	private void notifyCoinAdded(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinAdded(this, coin);
+	}
+
+	private void notifyCoinRemoved(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinRemoved(this, coin);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsFull(this);
+	}
+
+	private void notifyCoinsEmpty() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsEmpty(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
new file mode 100644
index 0000000..9cc3516
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java	
@@ -0,0 +1,97 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+
+/**
+ * Represents a simple coin slot device that has one output channel. The slot is
+ * stupid: it has no functionality other than being enabled/disabled, and cannot
+ * determine the value and currency of the coin.
+ */
+public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin slot.
+	 */
+	public CoinSlot() {}
+
+	/**
+	 * Connects channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where coins will always be passed.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
+	 * enabled, this causes a "coinInserted" event to be announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             If the coin slot is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws NullPointerException
+	 *             If the coin is null.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		notifyCoinInserted();
+
+		if(sink.hasSpace()) {
+			try {
+				sink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else
+			throw new SimulationException("Unable to route coin: Output channel is full");
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return sink.hasSpace();
+	}
+
+	private void notifyCoinInserted() {
+		for(CoinSlotObserver observer : observers)
+			observer.coinInserted(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
new file mode 100644
index 0000000..97d5929
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java	
@@ -0,0 +1,186 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+/**
+ * Represents devices that store coins. They only receive coins, not dispense
+ * them. To access the coins inside, a human operator needs to physically remove
+ * the coins, simulated with the {@link #unload()} method. A
+ * {@link #load(Coin...)} method is provided for symmetry.
+ */
+public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
+	private Coin[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin storage unit that can hold the indicated number of coins.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public CoinStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Coin[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of coins that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of coins contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getCoinCount() {
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the storage unit directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced. Disabling has no effect on loading/unloading.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             unit.
+	 * @throws SimulationException
+	 *             If coins is null.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 * @throws OverloadException
+	 *             If too many coins are loaded.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(coins == null)
+			throw new SimulationException(
+				new NullPointerException("coins is null, which has no analogue in the real world."));
+
+		if(coins.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("No coin may be null"));
+
+		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
+		nextIndex += coins.length;
+
+		notifyCoinsLoaded();
+	}
+
+	/**
+	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
+	 * to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> coins = Arrays.asList(storage);
+
+		storage = new Coin[storage.length];
+		nextIndex = 0;
+		notifyCoinsUnloaded();
+
+		return coins;
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the storage unit. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition instead causes the unit to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Coin coin) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = coin;
+
+			if(nextIndex == storage.length)
+				notifyCoinsFull();
+			else
+				notifyCoinAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyCoinsLoaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsLoaded(this);
+	}
+
+	private void notifyCoinsUnloaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsUnloaded(this);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsFull(this);
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
new file mode 100644
index 0000000..3ee4da7
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinTray.java	
@@ -0,0 +1,102 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+/**
+ * Simulates the tray where dispensed coins go for the user to collect them.
+ */
+public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
+	private Coin[] coins;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin tray.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that this tray can hold without
+	 *            overflowing.
+	 * @throws SimulationException
+	 *             If the capacity is &le;0.
+	 */
+	public CoinTray(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
+
+		coins = new Coin[capacity];
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
+	 * announced to observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to add.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the tray overflows.
+	 */
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(nextIndex < coins.length) {
+			coins[nextIndex++] = coin;
+			notifyCoinAdded();
+		}
+		else
+			throw new OverloadException("The tray has overflowed.");
+	}
+
+	/**
+	 * Simulates the act of physically removing coins from the try by a user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The list of coins collected. May not be null. May be empty.
+	 */
+	public List<Coin> collectCoins() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		List<Coin> result = Arrays.asList(coins);
+
+		coins = new Coin[coins.length];
+		nextIndex = 0;
+
+		return result;
+	}
+
+	/**
+	 * Returns whether this coin receptacle has enough space to accept at least one
+	 * more coin: always true. Causes no events.
+	 */
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < coins.length;
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinTrayObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
new file mode 100644
index 0000000..47b43a8
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
@@ -0,0 +1,268 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.Collections;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+/**
+ * Represents a device for optically and/or physically validating coins. Coins
+ * deemed valid are moved to storage; coins deemed invalid are ejected.
+ */
+public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
+	public final Currency currency;
+	private List<BigDecimal> denominations;
+	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
+	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
+
+	/**
+	 * Creates a coin validator that recognizes coins of the specified denominations
+	 * (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.size() < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Collections.sort(denominations);
+
+		standardSinks = new HashMap<>();
+
+		for(BigDecimal denomination : denominations) {
+			if(denomination == null)
+				throw new SimulationException(new NullPointerException("A denomination is null"));
+
+			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(standardSinks.containsKey(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			standardSinks.put(denomination, null);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param rejectionSink
+	 *            The channel to which rejected coins are routed.
+	 * @param overflowSink
+	 *            The channel to which valid coins are routed when the normal sink
+	 *            is full.
+	 * @param standardSinks
+	 *            The channels to which valid coins are normally routed. There must
+	 *            be one sink to correspond to each valid currency denomination, and
+	 *            they must be in the same order as the valid denominations.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If any standard sink is null.
+	 * @throws SimulationException
+	 *             If the number of standard sinks differs from the number of
+	 *             denominations.
+	 * @throws SimulationException
+	 *             If any sink is used in more than one position.
+	 */
+	public void connect(UnidirectionalChannel<Coin> rejectionSink,
+		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		if(rejectionSink == null)
+			throw new SimulationException(
+				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
+
+		if(overflowSink == null)
+			throw new SimulationException(
+				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
+
+		if(standardSinks == null)
+			throw new SimulationException(
+				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
+
+		if(standardSinks.keySet().size() != denominations.size())
+			throw new SimulationException(
+				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
+
+		this.rejectionSink = rejectionSink;
+		this.overflowSink = overflowSink;
+
+		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
+
+		for(BigDecimal denomination : standardSinks.keySet()) {
+			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
+			if(sink == null)
+				throw new SimulationException(
+					new NullPointerException("The sink for denomination " + denomination + " is null."));
+			else {
+				if(set.contains(sink))
+					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+				set.add(sink);
+			}
+		}
+
+		this.standardSinks = standardSinks;
+
+		if(set.contains(rejectionSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+		else
+			set.add(rejectionSink);
+
+		if(set.contains(overflowSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+		this.overflowSink = overflowSink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Coin coin) {
+		if(currency.equals(coin.getCurrency()))
+			for(BigDecimal denomination : denominations)
+				if(denomination.equals(coin.getValue()))
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the coin validator that the indicated coin is being inserted. If the
+	 * coin is valid, a "validCoinDetected" event is announced to its observers;
+	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
+	 * <p>
+	 * If there is space in the machine to store a valid coin, it is passed to the
+	 * sink channel corresponding to the denomination of the coin.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the coin is invalid, the
+	 * coin is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the coin validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the coin is null.
+	 * @throws SimulationException
+	 *             If the coin cannot be delivered.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(isValid(coin)) {
+			notifyValidCoinDetected(coin);
+
+			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					overflowSink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidCoinDetected(coin);
+
+			try {
+				rejectionSink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
+	}
+
+	private void notifyValidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.validCoinDetected(this, coin.getValue());
+	}
+
+	private void notifyInvalidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.invalidCoinDetected(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
new file mode 100644
index 0000000..7fce25d
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/DisabledException.java	
@@ -0,0 +1,8 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Issued when a device cannot perform its usual functions because it has been
+ * disabled.
+ */
+@SuppressWarnings("serial")
+public class DisabledException extends Exception {}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
new file mode 100644
index 0000000..844e0c8
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
@@ -0,0 +1,188 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
+	private ArrayList<Item> items = new ArrayList<>();
+
+	private double weightLimitInGrams;
+	private double currentWeightInGrams = 0;
+	private double weightAtLastEvent = 0;
+	private double sensitivity;
+
+	/**
+	 * Constructs an electronic scale with the indicated maximum weight that it can
+	 * handle before going into overload. The constructed scale will initially be in
+	 * the configuration phase.
+	 * 
+	 * @param weightLimitInGrams
+	 *            The weight threshold beyond which the scale will overload.
+	 * @param sensitivity
+	 *            The number of grams that can be added or removed since the last
+	 *            change event, without causing a new change event.
+	 * @throws SimulationException
+	 *             If either argument is &le;0.
+	 */
+	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
+		if(weightLimitInGrams <= 0)
+			throw new SimulationException("The maximum weight cannot be zero or less.");
+
+		if(sensitivity <= 0)
+			throw new SimulationException("The sensitivity cannot be zero or less.");
+
+		this.weightLimitInGrams = weightLimitInGrams;
+		this.sensitivity = sensitivity;
+	}
+
+	/**
+	 * Gets the weight limit for the scale. Weights greater than this will not be
+	 * weighable by the scale, but will cause overload.
+	 * <p>
+	 * This operation is permissible during all phases.
+	 * 
+	 * @return The weight limit.
+	 */
+	public double getWeightLimit() {
+		return weightLimitInGrams;
+	}
+
+	/**
+	 * Gets the current weight on the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration or error phases.
+	 * 
+	 * @return The current weight.
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
+	 * @throws OverloadException
+	 *             If the weight has overloaded the scale.
+	 */
+	public double getCurrentWeight() throws OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
+
+		if(currentWeightInGrams <= weightLimitInGrams)
+			return currentWeightInGrams + new Random().nextDouble() / 10.0;
+
+		throw new OverloadException();
+	}
+
+	/**
+	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
+	 * noticed or announced.
+	 * <p>
+	 * This operation is permissible during all phases.
+	 * 
+	 * @return The sensitivity.
+	 */
+	public double getSensitivity() {
+		return sensitivity;
+	}
+
+	/**
+	 * Adds an item to the scale. If the addition is successful, a weight changed
+	 * event is announced. If the weight is greater than the weight limit, an
+	 * overload event is announced.
+	 * <p>
+	 * This operation is not permissible during the configuration or error phase.
+	 * 
+	 * @param item
+	 *            The item to add.
+	 * @throws SimulationException
+	 *             If the same item is added more than once or is null.
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
+	 */
+	public void add(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
+
+		if(item == null)
+			throw new SimulationException("Null is not a valid item.");
+
+		if(items.contains(item))
+			throw new SimulationException("The same item cannot be added more than once to the scale.");
+		
+		currentWeightInGrams += item.getWeight();
+
+		items.add(item);
+
+		if(currentWeightInGrams > weightLimitInGrams)
+			notifyOverload();
+
+		if(Math.abs(currentWeightInGrams - weightAtLastEvent) > sensitivity)
+			notifyWeightChanged();
+	}
+
+	/**
+	 * Removes an item from the scale. If the operation is successful, a weight
+	 * changed event is announced. If the scale was overloaded and this removal
+	 * causes it to no longer be overloaded, an out of overload event is announced.
+	 * <p>
+	 * This operation is not permissible during the configuration or error phases.
+	 * 
+	 * @param item
+	 *            The item to remove.
+	 * @throws SimulationException
+	 *             If the item is not on the scale (including if it is null).
+	 * @throws SimulationException
+	 *             If this operation is called during the configuration or error
+	 *             phases.
+	 */
+	public void remove(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(
+				"This method may not be used when the device is in an erroneous operation phase.");
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException("This method may not be called during the configuration phase.");
+
+		if(!items.remove(item))
+			throw new SimulationException("The item was not found amongst those on the scale.");
+
+		// To avoid drift in the sum due to round-off error, recalculate the weight.
+		double newWeightInGrams = 0.0;
+		for(Item itemOnScale : items)
+			newWeightInGrams += itemOnScale.getWeight();
+
+		double original = currentWeightInGrams;
+		currentWeightInGrams = newWeightInGrams;
+
+		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
+			notifyOutOfOverload();
+
+		if(currentWeightInGrams <= weightLimitInGrams && Math.abs(original - currentWeightInGrams) > sensitivity)
+			notifyWeightChanged();
+	}
+
+	private void notifyOverload() {
+		for(ElectronicScaleObserver l : observers)
+			l.overload(this);
+	}
+
+	private void notifyOutOfOverload() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.outOfOverload(this);
+	}
+
+	private void notifyWeightChanged() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.weightChanged(this, currentWeightInGrams);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java
new file mode 100644
index 0000000..e4942a1
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/Emitter.java	
@@ -0,0 +1,12 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple base interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface Emitter<T> {
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
new file mode 100644
index 0000000..f8564db
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/EmptyException.java	
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents the situation when a device is emptied but an attempt is made to
+ * remove something from it.
+ */
+public class EmptyException extends Exception {
+	private static final long serialVersionUID = 3566954386000387724L;
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
new file mode 100644
index 0000000..089d324
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FlowThroughEmitter<T> {
+	/**
+	 * Instructs the device to emit a specific thing, meaning that the device is
+	 * being handed this thing to pass onwards.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to emit.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit(T thing) throws DisabledException, OverloadException;
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
new file mode 100644
index 0000000..5fb3376
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FromStorageEmitter<T> {
+	/**
+	 * Instructs the device to emit one thing, meaning that the device stores a set
+	 * of things and one of them is to be emitted.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws EmptyException
+	 *             If the device is empty and cannot emit.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit() throws DisabledException, EmptyException, OverloadException;
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
new file mode 100644
index 0000000..7fcc01d
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/OverloadException.java	
@@ -0,0 +1,24 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents situations where a device has been overloaded, in terms of weight,
+ * quantity of items, etc.
+ */
+public class OverloadException extends Exception {
+	private static final long serialVersionUID = 7813659161520664284L;
+
+	/**
+	 * Create an exception without an error message.
+	 */
+	public OverloadException() {}
+
+	/**
+	 * Create an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to use.
+	 */
+	public OverloadException(String message) {
+		super(message);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
new file mode 100644
index 0000000..e1c16e6
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java	
@@ -0,0 +1,204 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+/**
+ * Represents printers used for printing receipts. A printer has a finite amount
+ * of paper (measured in lines that can be printed) and ink (measured in
+ * characters that can be printed).
+ * <p>
+ * Since this is a simulation, each character is assumed to require the same
+ * amount of ink (except blanks and newlines) and the font size is fixed.
+ * </p>
+ */
+public class ReceiptPrinter extends AbstractDevice<ReceiptPrinterObserver> {
+	public static final int MAXIMUM_INK = 1 << 20;
+	public static final int MAXIMUM_PAPER = 1 << 10;
+	private int charactersOfInkRemaining = 0;
+	private int linesOfPaperRemaining = 0;
+	private StringBuilder sb = new StringBuilder();
+	private int charactersOnCurrentLine = 0;
+
+	/**
+	 * Represents the maximum number of characters that can fit on one line of the
+	 * receipt. This is a simulation, so the font is assumed monospaced and of fixed
+	 * size.
+	 */
+	public final static int CHARACTERS_PER_LINE = 60;
+
+	/**
+	 * Creates a receipt printer.
+	 */
+	public ReceiptPrinter() {}
+
+	/**
+	 * Prints a single character to the receipt. Whitespace characters are ignored,
+	 * with the exception of ' ' (blank) and '\n', which signals to move to the
+	 * start of the next line.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param c
+	 *            The character to print.
+	 * @throws SimulationException
+	 *             If there is no ink or no paper in the printer.
+	 * @throws SimulationException
+	 *             If the extra character would spill off the end of the line.
+	 */
+	public void print(char c) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(c == '\n') {
+			--linesOfPaperRemaining;
+			charactersOnCurrentLine = 0;
+		}
+		else if(c != ' ' && Character.isWhitespace(c))
+			return;
+		else if(charactersOnCurrentLine == CHARACTERS_PER_LINE)
+			throw new SimulationException("The line is too long. Add a newline");
+		else if(linesOfPaperRemaining == 0)
+			throw new SimulationException("There is no paper in the printer.");
+		else
+			charactersOnCurrentLine++;
+
+		if(!Character.isWhitespace(c)) {
+			if(charactersOfInkRemaining == 0)
+				throw new SimulationException("There is no ink in the printer");
+
+			charactersOfInkRemaining--;
+		}
+
+		sb.append(c);
+
+		if(charactersOfInkRemaining == 0)
+			notifyOutOfInk();
+
+		if(linesOfPaperRemaining == 0)
+			notifyOutOfPaper();
+	}
+
+	/**
+	 * The receipt is finished printing, so cut it so that the customer can easily
+	 * remove it. Failure to cut the paper means that the receipt will not be
+	 * retrievable by the customer.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void cutPaper() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		lastReceipt = sb.toString();
+	}
+
+	private String lastReceipt = null;
+
+	/**
+	 * Simulates the customer removing the receipt. Failure to cut the receipt
+	 * first, or to always remove the receipt means that the customer will end up
+	 * with other customers' receipts too!
+	 * 
+	 * @return The receipt if it has been cut; otherwise, null.
+	 */
+	public String removeReceipt() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		String receipt = lastReceipt;
+
+		if(lastReceipt != null) {
+			lastReceipt = null;
+			sb = new StringBuilder();
+		}
+		else
+			throw new SimulationException("A non-existent receipt cannot be removed.");
+
+		return receipt;
+	}
+
+	/**
+	 * Adds ink to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of characters-worth of ink to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing ink plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addInk(int quantity) {
+		if(quantity < 0)
+			throw new SimulationException("Are you trying to remove ink?");
+
+		if(charactersOfInkRemaining + quantity > MAXIMUM_INK)
+			throw new SimulationException("You spilled a bunch of ink!");
+
+		if(quantity > 0) {
+			charactersOfInkRemaining += quantity;
+			notifyInkAdded();
+		}
+	}
+
+	/**
+	 * Adds paper to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of lines-worth of paper to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing paper plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addPaper(int units) {
+		if(units < 0)
+			throw new SimulationException("Are you trying to remove paper?");
+
+		if(linesOfPaperRemaining + units > MAXIMUM_PAPER)
+			throw new SimulationException("You may have broken the printer, jamming so much in there!");
+
+		if(units > 0) {
+			linesOfPaperRemaining += units;
+			notifyPaperAdded();
+		}
+	}
+
+	private void notifyOutOfInk() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfInk(this);
+	}
+
+	private void notifyInkAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.inkAdded(this);
+	}
+
+	private void notifyOutOfPaper() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfPaper(this);
+	}
+
+	private void notifyPaperAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.paperAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
new file mode 100644
index 0000000..ff66327
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
@@ -0,0 +1,273 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.sound.sampled.AudioSystem;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Simulates the overall self-checkout station.
+ * <p>
+ * A self-checkout possesses the following units of hardware that the customer
+ * can see and interact with:
+ * <ul>
+ * <li>two electronic scales, with a configurable maximum weight before it
+ * overloads, one for the bagging area and one for the scanning area;</li>
+ * <li>one receipt printer;</li>
+ * <li>one card reader;</li>
+ * <li>two scanners (the main one and the handheld one);</li>
+ * <li>one input slot for banknotes;</li>
+ * <li>one output slot for banknotes;</li>
+ * <li>one input slot for coins;</li>
+ * <li>one output tray for coins; and,</li>
+ * <li>one speaker for audio output (note: you should directly use the
+ * {@link AudioSystem} class, if you want to produce sounds).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * In addition, these units of hardware are accessible to personnel with a key
+ * to unlock the front of the station:
+ * <li>one banknote storage unit, with configurable capacity;</li>
+ * <li>one or more banknote dispensers, one for each supported denomination of
+ * banknote, as configured;</li>
+ * <li>one coin storage unit, with configurable capacity; and,</li>
+ * <li>one or more coin dispensers, one for each supported denomination of coin,
+ * as configured.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * And finally, there are certain, additional units of hardware that would only
+ * be accessible to someone with the appropriate tools (like a screwdriver,
+ * crowbar, or sledge hammer):
+ * <ul>
+ * <li>one banknote validator; and</li>
+ * <li>one coin validator.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * Many of these devices are interconnected, to permit coins or banknotes to
+ * pass between them. Specifically:
+ * <ul>
+ * <li>the coin slot is connected to the coin validator (this is a
+ * one-directional chain of devices);</li>
+ * <li>the coin validator is connected to each of the coin dispensers (i.e., the
+ * coin dispensers can be replenished with coins entered by customers), to the
+ * coin storage unit (for any overflow coins that do not fit in the dispensers),
+ * and to the coin tray for any rejected coins either because the coins are
+ * invalid or because even the overflow storage unit is full (this is a
+ * one-directional chain of devices);
+ * <li>each coin dispenser is connected to the coin tray, to provide change
+ * (this is a one-directional chain of devices);</li>
+ * <li>the banknote input slot is connected to the banknote validator (this is a
+ * <b>two</b>-directional chain of devices as an entered banknotes that are
+ * rejected by the validator can be returned to the customer);</li>
+ * <li>the banknote validator is connected to the banknote storage unit (this is
+ * a one-directional chain of devices); and,</li>
+ * <li>each banknote dispenser is connected to the output banknote slot; these
+ * dispensers cannot be replenished by banknotes provided by customers (this is
+ * a one-directional chain of devices).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * All other functionality of the system must be performed in software,
+ * installed on the self-checkout station through custom observer classes
+ * implementing the various observer interfaces provided.
+ * </p>
+ * <p>
+ * Note that banknote denominations are required to be positive integers, while
+ * coin denominations are positive decimal values ({@link BigDecimal} is used
+ * for the latter to avoid roundoff problems arising from floating-point
+ * operations).
+ */
+public class SelfCheckoutStation {
+	public final ElectronicScale baggingArea, scanningArea;
+	public final ReceiptPrinter printer;
+	public final CardReader cardReader;
+	public final BarcodeScanner mainScanner;
+	public final BarcodeScanner handheldScanner;
+
+	public final BanknoteSlot banknoteInput, banknoteOutput;
+	public final BanknoteValidator banknoteValidator;
+	public final BanknoteStorageUnit banknoteStorage;
+	public final static int BANKNOTE_STORAGE_CAPACITY = 1000;
+	public final int[] banknoteDenominations;
+	public final Map<Integer, BanknoteDispenser> banknoteDispensers;
+	public final static int BANKNOTE_DISPENSER_CAPACITY = 100;
+
+	public final CoinSlot coinSlot;
+	public final CoinValidator coinValidator;
+	public final CoinStorageUnit coinStorage;
+	public static final int COIN_STORAGE_CAPACITY = 1000;
+	public final List<BigDecimal> coinDenominations;
+	public final Map<BigDecimal, CoinDispenser> coinDispensers;
+	public static final int COIN_DISPENSER_CAPACITY = 200;
+	public final CoinTray coinTray;
+	public static final int COIN_TRAY_CAPACITY = 20;
+
+	/**
+	 * Creates a self-checkout station.
+	 * 
+	 * @param currency
+	 *            The kind of currency permitted.
+	 * @param banknoteDenominations
+	 *            The set of denominations (i.e., $5, $10, etc.) to accept.
+	 * @param coinDenominations
+	 *            The set of denominations (i.e., $0.05, $0.10, etc.) to accept.
+	 * @param scaleMaximumWeight
+	 *            The most weight that can be placed on the scale before it
+	 *            overloads.
+	 * @param scaleSensitivity
+	 *            Any weight changes smaller than this will not be detected or
+	 *            announced.
+	 * @throws SimulationException
+	 *             If any argument is null or negative.
+	 * @throws SimulationException
+	 *             If the number of banknote or coin denominations is &lt;1.
+	 */
+	public SelfCheckoutStation(Currency currency, int[] banknoteDenominations, BigDecimal[] coinDenominations,
+		int scaleMaximumWeight, int scaleSensitivity) {
+		if(currency == null || banknoteDenominations == null || coinDenominations == null)
+			throw new SimulationException(new NullPointerException("No argument may be null."));
+
+		if(scaleMaximumWeight <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's maximum weight must be positive."));
+
+		if(scaleSensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's sensitivity must be positive."));
+
+		if(banknoteDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable banknote denomination defined."));
+
+		if(coinDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
+
+		// Create the devices.
+		baggingArea = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		scanningArea = new ElectronicScale(scaleMaximumWeight / 10 + 1, scaleSensitivity);
+		printer = new ReceiptPrinter();
+		cardReader = new CardReader();
+		mainScanner = new BarcodeScanner();
+		handheldScanner = new BarcodeScanner();
+
+		this.banknoteDenominations = banknoteDenominations;
+		banknoteInput = new BanknoteSlot(false);
+		banknoteValidator = new BanknoteValidator(currency, banknoteDenominations);
+		banknoteStorage = new BanknoteStorageUnit(BANKNOTE_STORAGE_CAPACITY);
+		banknoteOutput = new BanknoteSlot(true);
+
+		banknoteDispensers = new HashMap<>();
+
+		for(int i = 0; i < banknoteDenominations.length; i++)
+			banknoteDispensers.put(banknoteDenominations[i], new BanknoteDispenser(BANKNOTE_DISPENSER_CAPACITY));
+
+		this.coinDenominations = Arrays.asList(coinDenominations);
+		coinSlot = new CoinSlot();
+		coinValidator = new CoinValidator(currency, this.coinDenominations);
+		coinStorage = new CoinStorageUnit(COIN_STORAGE_CAPACITY);
+		coinTray = new CoinTray(COIN_TRAY_CAPACITY);
+
+		coinDispensers = new HashMap<>();
+
+		for(int i = 0; i < coinDenominations.length; i++)
+			coinDispensers.put(coinDenominations[i], new CoinDispenser(COIN_DISPENSER_CAPACITY));
+
+		// Hook up everything.
+		interconnect(banknoteInput, banknoteValidator);
+		interconnect(banknoteValidator, banknoteStorage);
+
+		for(BanknoteDispenser dispenser : banknoteDispensers.values())
+			interconnect(dispenser, banknoteOutput);
+
+		interconnect(coinSlot, coinValidator);
+		interconnect(coinValidator, coinTray, coinDispensers, coinStorage);
+
+		for(CoinDispenser coinDispenser : coinDispensers.values())
+			interconnect(coinDispenser, coinTray);
+
+		baggingArea.endConfigurationPhase();
+		scanningArea.endConfigurationPhase();
+		printer.endConfigurationPhase();
+		cardReader.endConfigurationPhase();
+		mainScanner.endConfigurationPhase();
+		handheldScanner.endConfigurationPhase();
+
+		banknoteInput.endConfigurationPhase();
+		banknoteValidator.endConfigurationPhase();
+		banknoteStorage.endConfigurationPhase();
+		banknoteOutput.endConfigurationPhase();
+
+		for(BanknoteDispenser bd : banknoteDispensers.values())
+			bd.endConfigurationPhase();
+
+		coinSlot.endConfigurationPhase();
+		coinValidator.endConfigurationPhase();
+		// coinStorage.enable();
+		coinStorage.endConfigurationPhase();
+		coinTray.endConfigurationPhase();
+
+		for(CoinDispenser cd : coinDispensers.values())
+			cd.endConfigurationPhase();
+	}
+
+	private BidirectionalChannel<Banknote> validatorSource;
+
+	private boolean supervised = false;
+
+	boolean isSupervised() {
+		return supervised;
+	}
+
+	void setSupervised(boolean isSupervised) {
+		supervised = isSupervised;
+	}
+
+	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
+		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
+		slot.connect(validatorSource);
+	}
+
+	private void interconnect(BanknoteValidator validator, BanknoteStorageUnit storage) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(storage);
+		validator.connect(validatorSource, bc);
+	}
+
+	private void interconnect(BanknoteDispenser dispenser, BanknoteSlot slot) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(slot);
+		dispenser.connect(bc);
+	}
+
+	private void interconnect(CoinSlot slot, CoinValidator validator) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(validator);
+		slot.connect(cc);
+	}
+
+	private void interconnect(CoinValidator validator, CoinTray tray, Map<BigDecimal, CoinDispenser> dispensers,
+		CoinStorageUnit storage) {
+		UnidirectionalChannel<Coin> rejectChannel = new UnidirectionalChannel<Coin>(tray);
+		Map<BigDecimal, UnidirectionalChannel<Coin>> dispenserChannels = new HashMap<BigDecimal, UnidirectionalChannel<Coin>>();
+
+		for(BigDecimal denomination : dispensers.keySet()) {
+			CoinDispenser dispenser = dispensers.get(denomination);
+			dispenserChannels.put(denomination, new UnidirectionalChannel<Coin>(dispenser));
+		}
+
+		UnidirectionalChannel<Coin> overflowChannel = new UnidirectionalChannel<Coin>(storage);
+
+		validator.connect(rejectChannel, dispenserChannels, overflowChannel);
+	}
+
+	private void interconnect(CoinDispenser dispenser, CoinTray tray) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(tray);
+		dispenser.connect(cc);
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
new file mode 100644
index 0000000..7001f20
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/SimulationException.java	
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * An exception that can be raised when the behaviour within the simulator makes
+ * no sense, typically when it has not been configured correctly. This is
+ * different from an exception being raised because the preconditions of a
+ * component are violated, but that would make sense in the real world.
+ */
+@SuppressWarnings("serial")
+public class SimulationException extends RuntimeException {
+	private String nested;
+
+	/**
+	 * Constructor used to nest other exceptions.
+	 * 
+	 * @param nested
+	 *            An underlying exception that is to be wrapped.
+	 */
+	public SimulationException(Exception nested) {
+		this.nested = nested.toString();
+	}
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param message
+	 *            An explanatory message of the problem.
+	 */
+	public SimulationException(String message) {
+		nested = message;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
new file mode 100644
index 0000000..888ab32
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java	
@@ -0,0 +1,49 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Represents a simple device (like, say, a tube) that allows things to move in
+ * one direction between other devices.
+ * 
+ * @param <T>
+ *            The type of the things to be transported.
+ */
+public class UnidirectionalChannel<T> {
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new coin channel whose output is connected to the indicated
+	 * sink.
+	 * 
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public UnidirectionalChannel(Acceptor<T> sink) {
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             If the sink has no space for the thing.
+	 * @throws DisabledException
+	 *             If the sink is currently disabled.
+	 */
+	public void deliver(T thing) throws OverloadException, DisabledException {
+		sink.accept(thing);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more thing.
+	 * 
+	 * @return true if the channel can accept a thing; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
new file mode 100644
index 0000000..5faa152
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * This class represents the abstract interface for all device observers. All
+ * subclasses should add their own event notification methods, the first
+ * parameter of which should always be the device affected.
+ */
+public interface AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated device has been enabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+
+	/**
+	 * Announces that the indicated device has been disabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
new file mode 100644
index 0000000..08d8fcd
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java	
@@ -0,0 +1,71 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+
+/**
+ * Observes events emanating from a banknote dispenser.
+ */
+public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote dispenser is full of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void moneyFull(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote dispenser is empty of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void banknotesEmpty(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was added.
+	 */
+	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was removed.
+	 */
+	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been added to the
+	 * indicated banknote dispenser. Used to simulate direct, physical loading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were loaded.
+	 */
+	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been removed to the
+	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were unloaded.
+	 */
+	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
new file mode 100644
index 0000000..f690ec9
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java	
@@ -0,0 +1,34 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public interface BanknoteSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteInserted(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteEjected(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteRemoved(BanknoteSlot slot);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
new file mode 100644
index 0000000..d4087a5
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java	
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
+public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesFull(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknoteAdded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesLoaded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesUnloaded(BanknoteStorageUnit unit);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
new file mode 100644
index 0000000..d63191a
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java	
@@ -0,0 +1,33 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+
+/**
+ * Observes events emanating from a banknote validator.
+ */
+public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
+	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
+
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidBanknoteDetected(BanknoteValidator validator);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
new file mode 100644
index 0000000..e3945d0
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java	
@@ -0,0 +1,20 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+
+/**
+ * Observes events emanating from a barcode scanner.
+ */
+public interface BarcodeScannerObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
+	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
+
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
new file mode 100644
index 0000000..173be6c
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java	
@@ -0,0 +1,52 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.CardReader;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CardReaderObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a card has been inserted in the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardInserted(CardReader reader);
+
+	/**
+	 * Announces that a card has been removed from the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardRemoved(CardReader reader);
+
+	/**
+	 * Announces that a (tap-enabled) card has been tapped on the indicated card
+	 * reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardTapped(CardReader reader);
+
+	/**
+	 * Announces that a card has swiped on the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardSwiped(CardReader reader);
+
+	/**
+	 * Announces that the data has been read from a card.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 * @param data
+	 *            The data that was read. Note that this data may be corrupted.
+	 */
+	void cardDataRead(CardReader reader, CardData data);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
new file mode 100644
index 0000000..2494e38
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java	
@@ -0,0 +1,67 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinDispenser;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CoinDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin dispenser is full of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsFull(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin dispenser is empty of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsEmpty(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was added.
+	 */
+	void coinAdded(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was removed.
+	 */
+	void coinRemoved(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated sequence of coins has been added to the
+	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were loaded.
+	 */
+	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
+
+	/**
+	 * Announces that the indicated sequence of coins has been removed to the
+	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were unloaded.
+	 */
+	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
new file mode 100644
index 0000000..75900f2
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java	
@@ -0,0 +1,17 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+/**
+ * Observes events emanating from a coin slot.
+ */
+public interface CoinSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
+	void coinInserted(CoinSlot slot);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
new file mode 100644
index 0000000..4c6f974
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java	
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+
+/**
+ * Observes events emanating from a coin storage unit.
+ */
+public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsFull(CoinStorageUnit unit);
+
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinAdded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsLoaded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsUnloaded(CoinStorageUnit unit);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
new file mode 100644
index 0000000..5a67bb4
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java	
@@ -0,0 +1,18 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinTray;
+
+/**
+ * Observes events emanating from a coin tray. Coin trays are dumb devices so
+ * very few kinds of events can be announced by them.
+ */
+public interface CoinTrayObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a coin has been added to the indicated tray.
+	 * 
+	 * @param tray
+	 *            The tray where the event occurred.
+	 */
+	void coinAdded(CoinTray tray);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
new file mode 100644
index 0000000..7229824
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java	
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+
+/**
+ * Observes events emanating from a coin validator.
+ */
+public interface CoinValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated coin has been detected and determined
+	 * to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param value
+	 *            The value of the coin.
+	 */
+	void validCoinDetected(CoinValidator validator, BigDecimal value);
+
+	/**
+	 * An event announcing that a coin has been detected and determined to be
+	 * invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidCoinDetected(CoinValidator validator);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
new file mode 100644
index 0000000..dcbdb49
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java	
@@ -0,0 +1,36 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+
+/**
+ * Observes events emanating from an electronic scale.
+ */
+public interface ElectronicScaleObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the weight on the indicated scale has changed.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 * @param weightInGrams
+	 *            The new weight.
+	 */
+	void weightChanged(ElectronicScale scale, double weightInGrams);
+
+	/**
+	 * Announces that excessive weight has been placed on the indicated scale.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void overload(ElectronicScale scale);
+
+	/**
+	 * Announces that the former excessive weight has been removed from the
+	 * indicated scale, and it is again able to measure weight.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void outOfOverload(ElectronicScale scale);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
new file mode 100644
index 0000000..16e810f
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java	
@@ -0,0 +1,40 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+
+/**
+ * Observes events emanating from a receipt printer.
+ */
+public interface ReceiptPrinterObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated printer is out of paper.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfPaper(ReceiptPrinter printer);
+
+	/**
+	 * Announces that the indicated printer is out of ink.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfInk(ReceiptPrinter printer);
+
+	/**
+	 * Announces that paper has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void paperAdded(ReceiptPrinter printer);
+
+	/**
+	 * Announces that ink has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void inkAdded(ReceiptPrinter printer);
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
new file mode 100644
index 0000000..d630fea
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java	
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * Represents observers that respond only to enable/disable events on touch screens.
+ */
+public interface TouchScreenObserver extends AbstractDeviceObserver {
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
new file mode 100644
index 0000000..e8f166c
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
@@ -0,0 +1,77 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with barcodes. Such products always have prices per-unit.
+ */
+public class BarcodedProduct extends Product {
+	private final Barcode barcode;
+	private final String description;
+	private final double expectedWeightInGrams;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param barcode
+	 *            The barcode of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-unit of the product.
+	 * @param expectedWeightInGrams
+	 *            The expected weight of each item of this product.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If the price is &le;0.
+	 * @throws IllegalArgumentException
+	 *             If the expected weight is &le;0.
+	 */
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price, double expectedWeightInGrams) {
+		super(price, true);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		if(expectedWeightInGrams <= 0.0)
+			throw new IllegalArgumentException("Products have to have a positive expected weight.");
+		
+		this.barcode = barcode;
+		this.description = description;
+		this.expectedWeightInGrams = expectedWeightInGrams;
+	}
+
+	/**
+	 * Get the barcode.
+	 * 
+	 * @return The barcode. Cannot be null.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+
+	/**
+	 * Get the expected weight.
+	 * 
+	 * @return The expected weight in grams.
+	 */
+	public double getExpectedWeight() {
+		return expectedWeightInGrams;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
new file mode 100644
index 0000000..ef28888
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java	
@@ -0,0 +1,57 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.PriceLookupCode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with price-lookup (PLU) codes. Such products always have
+ * prices per-kilogram.
+ */
+public class PLUCodedProduct extends Product {
+	private final PriceLookupCode pluCode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param pluCode
+	 *            The PLU code of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-kilogram of the product.
+	 */
+	public PLUCodedProduct(PriceLookupCode pluCode, String description, BigDecimal price) {
+		super(price, false);
+
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.pluCode = pluCode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the PLU code.
+	 * 
+	 * @return The PLU code. Cannot be null.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java
new file mode 100644
index 0000000..cd7ccb4
--- /dev/null
+++ b/SCS - Hardware - v2.0/src/org/lsmr/selfcheckout/products/Product.java	
@@ -0,0 +1,55 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Abstract base class for products. Note that a "product" is the <b>kind</> of
+ * item (e.g., 2 litre container of Dairyland brand 2% milk) and not an
+ * individual item, which would be the specific physical object (e.g.,
+ * <b>that</b> bottle of milk and not <b>this</b> one).
+ */
+public abstract class Product {
+	private final BigDecimal price;
+	private final boolean isPerUnit;
+
+	/**
+	 * Create a product instance.
+	 * 
+	 * @param price
+	 *            The price per unit or per kilogram.
+	 * @param isPerUnit
+	 *            True if the price is per unit; false if it is per kilogram.
+	 * @throws SimulationException
+	 *             If the price is null or &le;0.
+	 */
+	protected Product(BigDecimal price, boolean isPerUnit) {
+		if(price == null)
+			throw new SimulationException(new NullPointerException("price is null"));
+
+		if(price.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(new IllegalArgumentException("A product's price can only be positive."));
+
+		this.price = price;
+		this.isPerUnit = isPerUnit;
+	}
+
+	/**
+	 * Gets the price of the product.
+	 * 
+	 * @return The price. Cannot be null. Must be &gt;0.
+	 */
+	public BigDecimal getPrice() {
+		return price;
+	}
+
+	/**
+	 * Tests whether the price is per-unit, as opposed to per-kilogram.
+	 * 
+	 * @return true if the price is per-unit; otherwise, false.
+	 */
+	public boolean isPerUnit() {
+		return isPerUnit;
+	}
+}

commit 9434f45bd2b8e65aa0b92a3a5663d4857c600e9d
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Mon Mar 21 11:43:20 2022 -0600

    Delete SCS - Hardware - v2.0.zip

diff --git a/SCS - Hardware - v2.0.zip b/SCS - Hardware - v2.0.zip
deleted file mode 100644
index 06ba7cd..0000000
Binary files a/SCS - Hardware - v2.0.zip and /dev/null differ

commit e344818b662dc7b8c3fb7557f175193a2b218082
Author: Muhammad Ali <87144559+NuclearTea@users.noreply.github.com>
Date:   Mon Mar 21 11:42:21 2022 -0600

    Add files via upload

diff --git a/SCS - Hardware - v2.0.zip b/SCS - Hardware - v2.0.zip
new file mode 100644
index 0000000..06ba7cd
Binary files /dev/null and b/SCS - Hardware - v2.0.zip differ

commit 08be3adf77833113285f390e7c9eb3d2170e3e17
Author: Adarsh Dudhat <92228157+adam-25@users.noreply.github.com>
Date:   Mon Mar 21 11:32:16 2022 -0600

    Initial commit

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..a1c2a23
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,23 @@
+# Compiled class file
+*.class
+
+# Log file
+*.log
+
+# BlueJ files
+*.ctxt
+
+# Mobile Tools for Java (J2ME)
+.mtj.tmp/
+
+# Package Files #
+*.jar
+*.war
+*.nar
+*.ear
+*.zip
+*.tar.gz
+*.rar
+
+# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
+hs_err_pid*
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..5007727
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+# SENG-300-Iteration--2
\ No newline at end of file
